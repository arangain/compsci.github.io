{"ast":null,"code":"class Node {\n  constructor(data) {\n    this.data = data;\n    this.next = null;\n  }\n\n} /// Push, and declaring first, last and size properties of the stack \n/// Create method which accepts data as argument, declare a new node with that data, \n/// If a stack is empty set first and last node to newly created node, \n/// If there is data in stack then set new node.next to first property \n/// Update the first property with new node, then increment stack size by one \n\n\nclass Stack {\n  constructor() {\n    this.first = null;\n    this.last = null;\n    this.size = 0;\n  }\n\n  push(data) {\n    let node = new Node(data); // new mode\n    // stack is empty \n\n    if (!this.first) {\n      this.first = node;\n      this.last = node;\n    } else {\n      node.next = this.first;\n      this.first = node;\n    }\n\n    this.size++;\n  }\n\n  pop() {\n    if (!this.first) return null;\n    let node = this.first;\n\n    if (node.next) {\n      node = node.next;\n      this.first = node;\n    } else {\n      this.first = null;\n      this.last = null;\n    }\n\n    this.size--;\n  }\n\n}\n\nconst charstack = new Stack();\nconst tempstack = new Stack();\nexport default charstack;","map":{"version":3,"sources":["/Users/isogain/Desktop/Everything/compsci/project/src/components/charstack.js"],"names":["Node","constructor","data","next","Stack","first","last","size","push","node","pop","charstack","tempstack"],"mappings":"AAAA,MAAMA,IAAN,CAAU;AACNC,EAAAA,WAAW,CAACC,IAAD,EAAO;AAChB,SAAKA,IAAL,GAAYA,IAAZ;AACA,SAAKC,IAAL,GAAY,IAAZ;AACD;;AAJK,C,CAMR;AACA;AACA;AACA;AACA;;;AACA,MAAMC,KAAN,CAAW;AACTH,EAAAA,WAAW,GAAE;AACX,SAAKI,KAAL,GAAa,IAAb;AACA,SAAKC,IAAL,GAAY,IAAZ;AACA,SAAKC,IAAL,GAAY,CAAZ;AACD;;AAEDC,EAAAA,IAAI,CAACN,IAAD,EAAM;AAER,QAAIO,IAAI,GAAG,IAAIT,IAAJ,CAASE,IAAT,CAAX,CAFQ,CAEkB;AAC1B;;AACA,QAAG,CAAC,KAAKG,KAAT,EAAe;AACb,WAAKA,KAAL,GAAaI,IAAb;AACA,WAAKH,IAAL,GAAYG,IAAZ;AACD,KAHD,MAGK;AACHA,MAAAA,IAAI,CAACN,IAAL,GAAY,KAAKE,KAAjB;AACA,WAAKA,KAAL,GAAaI,IAAb;AACD;;AAED,SAAKF,IAAL;AACD;;AAEDG,EAAAA,GAAG,GAAE;AAEH,QAAG,CAAC,KAAKL,KAAT,EAAgB,OAAO,IAAP;AAEhB,QAAII,IAAI,GAAG,KAAKJ,KAAhB;;AAEA,QAAGI,IAAI,CAACN,IAAR,EAAa;AACXM,MAAAA,IAAI,GAAGA,IAAI,CAACN,IAAZ;AACA,WAAKE,KAAL,GAAaI,IAAb;AACD,KAHD,MAGK;AACH,WAAKJ,KAAL,GAAa,IAAb;AACA,WAAKC,IAAL,GAAY,IAAZ;AACD;;AACD,SAAKC,IAAL;AACD;;AApCQ;;AAuCb,MAAMI,SAAS,GAAG,IAAIP,KAAJ,EAAlB;AACA,MAAMQ,SAAS,GAAG,IAAIR,KAAJ,EAAlB;AAEA,eAAeO,SAAf","sourcesContent":["class Node{\n    constructor(data) {\n      this.data = data;\n      this.next = null;\n    }\n  }\n  /// Push, and declaring first, last and size properties of the stack \n  /// Create method which accepts data as argument, declare a new node with that data, \n  /// If a stack is empty set first and last node to newly created node, \n  /// If there is data in stack then set new node.next to first property \n  /// Update the first property with new node, then increment stack size by one \n  class Stack{\n    constructor(){\n      this.first = null;\n      this.last = null\n      this.size = 0\n    }\n    \n    push(data){\n  \n      let node = new Node(data) // new mode\n      // stack is empty \n      if(!this.first){\n        this.first = node\n        this.last = node\n      }else{\n        node.next = this.first\n        this.first = node\n      }\n  \n      this.size++\n    }\n  \n    pop(){\n      \n      if(!this.first) return null;\n  \n      let node = this.first\n  \n      if(node.next){\n        node = node.next\n        this.first = node\n      }else{\n        this.first = null\n        this.last = null\n      }\n      this.size--\n    }\n  }\n  \nconst charstack = new Stack();\nconst tempstack = new Stack();\n\nexport default charstack"]},"metadata":{},"sourceType":"module"}