var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb2, mod) => function __require() {
  return mod || (0, cb2[Object.keys(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key6 of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key6) && key6 !== "default")
        __defProp(target, key6, { get: () => module[key6], enumerable: !(desc = __getOwnPropDesc(module, key6)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};
var __accessCheck = (obj, member, msg2) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg2);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// ../../node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "../../node_modules/tslib/tslib.js"(exports, module) {
    var __extends2;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __createBinding2;
    (function(factory) {
      var root = typeof window === "object" ? window : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b2) {
        d.__proto__ = b2;
      } || function(d, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d[p] = b2[p];
      };
      __extends2 = function(d, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d, b2);
        function __() {
          this.constructor = d;
        }
        d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      __rest2 = function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      __decorate2 = function(decorators, target, key6, desc) {
        var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key6) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key6, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key6, r) : d(target, key6)) || r;
        return c2 > 3 && r && Object.defineProperty(target, key6, r), r;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key6) {
          decorator(target, key6, paramIndex);
        };
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar2 = function(m2, o) {
        for (var p in m2)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding2(o, m2, p);
      };
      __createBinding2 = Object.create ? function(o, m2, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m2[k];
        } });
      } : function(o, m2, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m2[k];
      };
      __values2 = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
        if (m2)
          return m2.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o, n) {
        var m2 = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m2)
          return o;
        var i = m2.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m2 = i["return"]))
              m2.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read2(arguments[i]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a2 = arguments[i], j = 0, jl = a2.length; j < jl; j++, k++)
            r[k] = a2[j];
        return r;
      };
      __spreadArray2 = function(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
          to[j] = from[i];
        return to;
      };
      __await2 = function(v) {
        return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a2, b2) {
                q.push([n, v, a2, b2]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator2 = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues2 = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o[Symbol.asyncIterator], i;
        return m2 ? m2.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar2 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault2 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
    });
  }
});

// ../../node_modules/@emotion/memoize/dist/memoize.browser.cjs.js
var require_memoize_browser_cjs = __commonJS({
  "../../node_modules/@emotion/memoize/dist/memoize.browser.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function memoize2(fn) {
      var cache4 = {};
      return function(arg) {
        if (cache4[arg] === void 0)
          cache4[arg] = fn(arg);
        return cache4[arg];
      };
    }
    exports.default = memoize2;
  }
});

// ../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.cjs.js
var require_is_prop_valid_browser_cjs = __commonJS({
  "../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var memoize2 = _interopDefault(require_memoize_browser_cjs());
    var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
    var index = memoize2(function(prop) {
      return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
    });
    exports.default = index;
  }
});

// ../../node_modules/hsluv/hsluv.js
var require_hsluv = __commonJS({
  "../../node_modules/hsluv/hsluv.js"(exports, module) {
    var hsluv = hsluv || {};
    hsluv.Geometry = function() {
    };
    hsluv.Geometry.intersectLineLine = function(a2, b2) {
      var x = (a2.intercept - b2.intercept) / (b2.slope - a2.slope);
      var y = a2.slope * x + a2.intercept;
      return { x, y };
    };
    hsluv.Geometry.distanceFromOrigin = function(point) {
      return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
    };
    hsluv.Geometry.distanceLineFromOrigin = function(line) {
      return Math.abs(line.intercept) / Math.sqrt(Math.pow(line.slope, 2) + 1);
    };
    hsluv.Geometry.perpendicularThroughPoint = function(line, point) {
      var slope = -1 / line.slope;
      var intercept = point.y - slope * point.x;
      return { slope, intercept };
    };
    hsluv.Geometry.angleFromOrigin = function(point) {
      return Math.atan2(point.y, point.x);
    };
    hsluv.Geometry.normalizeAngle = function(angle) {
      var m2 = 2 * Math.PI;
      return (angle % m2 + m2) % m2;
    };
    hsluv.Geometry.lengthOfRayUntilIntersect = function(theta, line) {
      return line.intercept / (Math.sin(theta) - line.slope * Math.cos(theta));
    };
    hsluv.Hsluv = function() {
    };
    hsluv.Hsluv.getBounds = function(L) {
      var result = [];
      var sub1 = Math.pow(L + 16, 3) / 1560896;
      var sub2 = sub1 > hsluv.Hsluv.epsilon ? sub1 : L / hsluv.Hsluv.kappa;
      var _g = 0;
      while (_g < 3) {
        var c2 = _g++;
        var m1 = hsluv.Hsluv.m[c2][0];
        var m2 = hsluv.Hsluv.m[c2][1];
        var m3 = hsluv.Hsluv.m[c2][2];
        var _g1 = 0;
        while (_g1 < 2) {
          var t = _g1++;
          var top1 = (284517 * m1 - 94839 * m3) * sub2;
          var top2 = (838422 * m3 + 769860 * m2 + 731718 * m1) * L * sub2 - 769860 * t * L;
          var bottom = (632260 * m3 - 126452 * m2) * sub2 + 126452 * t;
          result.push({ slope: top1 / bottom, intercept: top2 / bottom });
        }
      }
      return result;
    };
    hsluv.Hsluv.maxSafeChromaForL = function(L) {
      var bounds = hsluv.Hsluv.getBounds(L);
      var min = Infinity;
      var _g = 0;
      while (_g < bounds.length) {
        var bound = bounds[_g];
        ++_g;
        var length = hsluv.Geometry.distanceLineFromOrigin(bound);
        min = Math.min(min, length);
      }
      return min;
    };
    hsluv.Hsluv.maxChromaForLH = function(L, H) {
      var hrad = H / 360 * Math.PI * 2;
      var bounds = hsluv.Hsluv.getBounds(L);
      var min = Infinity;
      var _g = 0;
      while (_g < bounds.length) {
        var bound = bounds[_g];
        ++_g;
        var length = hsluv.Geometry.lengthOfRayUntilIntersect(hrad, bound);
        if (length >= 0) {
          min = Math.min(min, length);
        }
      }
      return min;
    };
    hsluv.Hsluv.dotProduct = function(a2, b2) {
      var sum = 0;
      var _g1 = 0;
      var _g = a2.length;
      while (_g1 < _g) {
        var i = _g1++;
        sum += a2[i] * b2[i];
      }
      return sum;
    };
    hsluv.Hsluv.fromLinear = function(c2) {
      if (c2 <= 31308e-7) {
        return 12.92 * c2;
      } else {
        return 1.055 * Math.pow(c2, 0.4166666666666667) - 0.055;
      }
    };
    hsluv.Hsluv.toLinear = function(c2) {
      if (c2 > 0.04045) {
        return Math.pow((c2 + 0.055) / 1.055, 2.4);
      } else {
        return c2 / 12.92;
      }
    };
    hsluv.Hsluv.xyzToRgb = function(tuple) {
      return [hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[0], tuple)), hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[1], tuple)), hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[2], tuple))];
    };
    hsluv.Hsluv.rgbToXyz = function(tuple) {
      var rgbl = [hsluv.Hsluv.toLinear(tuple[0]), hsluv.Hsluv.toLinear(tuple[1]), hsluv.Hsluv.toLinear(tuple[2])];
      return [hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[0], rgbl), hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[1], rgbl), hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[2], rgbl)];
    };
    hsluv.Hsluv.yToL = function(Y) {
      if (Y <= hsluv.Hsluv.epsilon) {
        return Y / hsluv.Hsluv.refY * hsluv.Hsluv.kappa;
      } else {
        return 116 * Math.pow(Y / hsluv.Hsluv.refY, 0.3333333333333333) - 16;
      }
    };
    hsluv.Hsluv.lToY = function(L) {
      if (L <= 8) {
        return hsluv.Hsluv.refY * L / hsluv.Hsluv.kappa;
      } else {
        return hsluv.Hsluv.refY * Math.pow((L + 16) / 116, 3);
      }
    };
    hsluv.Hsluv.xyzToLuv = function(tuple) {
      var X = tuple[0];
      var Y = tuple[1];
      var Z = tuple[2];
      var divider = X + 15 * Y + 3 * Z;
      var varU = 4 * X;
      var varV = 9 * Y;
      if (divider != 0) {
        varU /= divider;
        varV /= divider;
      } else {
        varU = NaN;
        varV = NaN;
      }
      var L = hsluv.Hsluv.yToL(Y);
      if (L == 0) {
        return [0, 0, 0];
      }
      var U = 13 * L * (varU - hsluv.Hsluv.refU);
      var V = 13 * L * (varV - hsluv.Hsluv.refV);
      return [L, U, V];
    };
    hsluv.Hsluv.luvToXyz = function(tuple) {
      var L = tuple[0];
      var U = tuple[1];
      var V = tuple[2];
      if (L == 0) {
        return [0, 0, 0];
      }
      var varU = U / (13 * L) + hsluv.Hsluv.refU;
      var varV = V / (13 * L) + hsluv.Hsluv.refV;
      var Y = hsluv.Hsluv.lToY(L);
      var X = 0 - 9 * Y * varU / ((varU - 4) * varV - varU * varV);
      var Z = (9 * Y - 15 * varV * Y - varV * X) / (3 * varV);
      return [X, Y, Z];
    };
    hsluv.Hsluv.luvToLch = function(tuple) {
      var L = tuple[0];
      var U = tuple[1];
      var V = tuple[2];
      var C = Math.sqrt(U * U + V * V);
      var H;
      if (C < 1e-8) {
        H = 0;
      } else {
        var Hrad = Math.atan2(V, U);
        H = Hrad * 180 / Math.PI;
        if (H < 0) {
          H = 360 + H;
        }
      }
      return [L, C, H];
    };
    hsluv.Hsluv.lchToLuv = function(tuple) {
      var L = tuple[0];
      var C = tuple[1];
      var H = tuple[2];
      var Hrad = H / 360 * 2 * Math.PI;
      var U = Math.cos(Hrad) * C;
      var V = Math.sin(Hrad) * C;
      return [L, U, V];
    };
    hsluv.Hsluv.hsluvToLch = function(tuple) {
      var H = tuple[0];
      var S = tuple[1];
      var L = tuple[2];
      if (L > 99.9999999) {
        return [100, 0, H];
      }
      if (L < 1e-8) {
        return [0, 0, H];
      }
      var max = hsluv.Hsluv.maxChromaForLH(L, H);
      var C = max / 100 * S;
      return [L, C, H];
    };
    hsluv.Hsluv.lchToHsluv = function(tuple) {
      var L = tuple[0];
      var C = tuple[1];
      var H = tuple[2];
      if (L > 99.9999999) {
        return [H, 0, 100];
      }
      if (L < 1e-8) {
        return [H, 0, 0];
      }
      var max = hsluv.Hsluv.maxChromaForLH(L, H);
      var S = C / max * 100;
      return [H, S, L];
    };
    hsluv.Hsluv.hpluvToLch = function(tuple) {
      var H = tuple[0];
      var S = tuple[1];
      var L = tuple[2];
      if (L > 99.9999999) {
        return [100, 0, H];
      }
      if (L < 1e-8) {
        return [0, 0, H];
      }
      var max = hsluv.Hsluv.maxSafeChromaForL(L);
      var C = max / 100 * S;
      return [L, C, H];
    };
    hsluv.Hsluv.lchToHpluv = function(tuple) {
      var L = tuple[0];
      var C = tuple[1];
      var H = tuple[2];
      if (L > 99.9999999) {
        return [H, 0, 100];
      }
      if (L < 1e-8) {
        return [H, 0, 0];
      }
      var max = hsluv.Hsluv.maxSafeChromaForL(L);
      var S = C / max * 100;
      return [H, S, L];
    };
    hsluv.Hsluv.rgbToHex = function(tuple) {
      var h = "#";
      var _g = 0;
      while (_g < 3) {
        var i = _g++;
        var chan = tuple[i];
        var c2 = Math.round(chan * 255);
        var digit2 = c2 % 16;
        var digit1 = (c2 - digit2) / 16 | 0;
        h += hsluv.Hsluv.hexChars.charAt(digit1) + hsluv.Hsluv.hexChars.charAt(digit2);
      }
      return h;
    };
    hsluv.Hsluv.hexToRgb = function(hex2) {
      hex2 = hex2.toLowerCase();
      var ret = [];
      var _g = 0;
      while (_g < 3) {
        var i = _g++;
        var digit1 = hsluv.Hsluv.hexChars.indexOf(hex2.charAt(i * 2 + 1));
        var digit2 = hsluv.Hsluv.hexChars.indexOf(hex2.charAt(i * 2 + 2));
        var n = digit1 * 16 + digit2;
        ret.push(n / 255);
      }
      return ret;
    };
    hsluv.Hsluv.lchToRgb = function(tuple) {
      return hsluv.Hsluv.xyzToRgb(hsluv.Hsluv.luvToXyz(hsluv.Hsluv.lchToLuv(tuple)));
    };
    hsluv.Hsluv.rgbToLch = function(tuple) {
      return hsluv.Hsluv.luvToLch(hsluv.Hsluv.xyzToLuv(hsluv.Hsluv.rgbToXyz(tuple)));
    };
    hsluv.Hsluv.hsluvToRgb = function(tuple) {
      return hsluv.Hsluv.lchToRgb(hsluv.Hsluv.hsluvToLch(tuple));
    };
    hsluv.Hsluv.rgbToHsluv = function(tuple) {
      return hsluv.Hsluv.lchToHsluv(hsluv.Hsluv.rgbToLch(tuple));
    };
    hsluv.Hsluv.hpluvToRgb = function(tuple) {
      return hsluv.Hsluv.lchToRgb(hsluv.Hsluv.hpluvToLch(tuple));
    };
    hsluv.Hsluv.rgbToHpluv = function(tuple) {
      return hsluv.Hsluv.lchToHpluv(hsluv.Hsluv.rgbToLch(tuple));
    };
    hsluv.Hsluv.hsluvToHex = function(tuple) {
      return hsluv.Hsluv.rgbToHex(hsluv.Hsluv.hsluvToRgb(tuple));
    };
    hsluv.Hsluv.hpluvToHex = function(tuple) {
      return hsluv.Hsluv.rgbToHex(hsluv.Hsluv.hpluvToRgb(tuple));
    };
    hsluv.Hsluv.hexToHsluv = function(s) {
      return hsluv.Hsluv.rgbToHsluv(hsluv.Hsluv.hexToRgb(s));
    };
    hsluv.Hsluv.hexToHpluv = function(s) {
      return hsluv.Hsluv.rgbToHpluv(hsluv.Hsluv.hexToRgb(s));
    };
    hsluv.Hsluv.m = [[3.240969941904521, -1.537383177570093, -0.498610760293], [-0.96924363628087, 1.87596750150772, 0.041555057407175], [0.055630079696993, -0.20397695888897, 1.056971514242878]];
    hsluv.Hsluv.minv = [[0.41239079926595, 0.35758433938387, 0.18048078840183], [0.21263900587151, 0.71516867876775, 0.072192315360733], [0.019330818715591, 0.11919477979462, 0.95053215224966]];
    hsluv.Hsluv.refY = 1;
    hsluv.Hsluv.refU = 0.19783000664283;
    hsluv.Hsluv.refV = 0.46831999493879;
    hsluv.Hsluv.kappa = 903.2962962;
    hsluv.Hsluv.epsilon = 0.0088564516;
    hsluv.Hsluv.hexChars = "0123456789abcdef";
    var root = {
      "hsluvToRgb": hsluv.Hsluv.hsluvToRgb,
      "rgbToHsluv": hsluv.Hsluv.rgbToHsluv,
      "hpluvToRgb": hsluv.Hsluv.hpluvToRgb,
      "rgbToHpluv": hsluv.Hsluv.rgbToHpluv,
      "hsluvToHex": hsluv.Hsluv.hsluvToHex,
      "hexToHsluv": hsluv.Hsluv.hexToHsluv,
      "hpluvToHex": hsluv.Hsluv.hpluvToHex,
      "hexToHpluv": hsluv.Hsluv.hexToHpluv,
      "lchToHpluv": hsluv.Hsluv.lchToHpluv,
      "hpluvToLch": hsluv.Hsluv.hpluvToLch,
      "lchToHsluv": hsluv.Hsluv.lchToHsluv,
      "hsluvToLch": hsluv.Hsluv.hsluvToLch,
      "lchToLuv": hsluv.Hsluv.lchToLuv,
      "luvToLch": hsluv.Hsluv.luvToLch,
      "xyzToLuv": hsluv.Hsluv.xyzToLuv,
      "luvToXyz": hsluv.Hsluv.luvToXyz,
      "xyzToRgb": hsluv.Hsluv.xyzToRgb,
      "rgbToXyz": hsluv.Hsluv.rgbToXyz,
      "lchToRgb": hsluv.Hsluv.lchToRgb,
      "rgbToLch": hsluv.Hsluv.rgbToLch
    };
    module.exports = root;
  }
});

// ../../node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "../../node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names2 = [], events2, name;
      if (this._eventsCount === 0)
        return names2;
      for (name in events2 = this._events) {
        if (has.call(events2, name))
          names2.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names2.concat(Object.getOwnPropertySymbols(events2));
      }
      return names2;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events2 = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events2.push(listeners[i]);
          }
        }
        if (events2.length)
          this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if (typeof module !== "undefined") {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
    "use strict";
    var REACT_STATICS = {
      childContextTypes: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = getPrototypeOf && getPrototypeOf(Object);
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys2 = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys2 = keys2.concat(getOwnPropertySymbols(sourceComponent));
        }
        for (var i = 0; i < keys2.length; ++i) {
          var key6 = keys2[i];
          if (!REACT_STATICS[key6] && !KNOWN_STATICS[key6] && (!blacklist || !blacklist[key6])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key6);
            try {
              defineProperty(targetComponent, key6, descriptor);
            } catch (e) {
            }
          }
        }
        return targetComponent;
      }
      return targetComponent;
    }
    module.exports = hoistNonReactStatics;
  }
});

// ../../node_modules/fontfaceobserver/fontfaceobserver.standalone.js
var require_fontfaceobserver_standalone = __commonJS({
  "../../node_modules/fontfaceobserver/fontfaceobserver.standalone.js"(exports, module) {
    (function() {
      function l(a2, b2) {
        document.addEventListener ? a2.addEventListener("scroll", b2, false) : a2.attachEvent("scroll", b2);
      }
      function m2(a2) {
        document.body ? a2() : document.addEventListener ? document.addEventListener("DOMContentLoaded", function c2() {
          document.removeEventListener("DOMContentLoaded", c2);
          a2();
        }) : document.attachEvent("onreadystatechange", function k() {
          if (document.readyState == "interactive" || document.readyState == "complete")
            document.detachEvent("onreadystatechange", k), a2();
        });
      }
      ;
      function t(a2) {
        this.a = document.createElement("div");
        this.a.setAttribute("aria-hidden", "true");
        this.a.appendChild(document.createTextNode(a2));
        this.b = document.createElement("span");
        this.c = document.createElement("span");
        this.h = document.createElement("span");
        this.f = document.createElement("span");
        this.g = -1;
        this.b.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";
        this.c.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";
        this.f.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";
        this.h.style.cssText = "display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;";
        this.b.appendChild(this.h);
        this.c.appendChild(this.f);
        this.a.appendChild(this.b);
        this.a.appendChild(this.c);
      }
      function u(a2, b2) {
        a2.a.style.cssText = "max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:" + b2 + ";";
      }
      function z(a2) {
        var b2 = a2.a.offsetWidth, c2 = b2 + 100;
        a2.f.style.width = c2 + "px";
        a2.c.scrollLeft = c2;
        a2.b.scrollLeft = a2.b.scrollWidth + 100;
        return a2.g !== b2 ? (a2.g = b2, true) : false;
      }
      function A(a2, b2) {
        function c2() {
          var a3 = k;
          z(a3) && a3.a.parentNode && b2(a3.g);
        }
        var k = a2;
        l(a2.b, c2);
        l(a2.c, c2);
        z(a2);
      }
      ;
      function B(a2, b2) {
        var c2 = b2 || {};
        this.family = a2;
        this.style = c2.style || "normal";
        this.weight = c2.weight || "normal";
        this.stretch = c2.stretch || "normal";
      }
      var C = null, D = null, E = null, F = null;
      function G() {
        if (D === null)
          if (J() && /Apple/.test(window.navigator.vendor)) {
            var a2 = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent);
            D = !!a2 && 603 > parseInt(a2[1], 10);
          } else
            D = false;
        return D;
      }
      function J() {
        F === null && (F = !!document.fonts);
        return F;
      }
      function K() {
        if (E === null) {
          var a2 = document.createElement("div");
          try {
            a2.style.font = "condensed 100px sans-serif";
          } catch (b2) {
          }
          E = a2.style.font !== "";
        }
        return E;
      }
      function L(a2, b2) {
        return [a2.style, a2.weight, K() ? a2.stretch : "", "100px", b2].join(" ");
      }
      B.prototype.load = function(a2, b2) {
        var c2 = this, k = a2 || "BESbswy", r = 0, n = b2 || 3e3, H = new Date().getTime();
        return new Promise(function(a3, b3) {
          if (J() && !G()) {
            var M = new Promise(function(a4, b4) {
              function e() {
                new Date().getTime() - H >= n ? b4(Error("" + n + "ms timeout exceeded")) : document.fonts.load(L(c2, '"' + c2.family + '"'), k).then(function(c3) {
                  1 <= c3.length ? a4() : setTimeout(e, 25);
                }, b4);
              }
              e();
            }), N = new Promise(function(a4, c3) {
              r = setTimeout(function() {
                c3(Error("" + n + "ms timeout exceeded"));
              }, n);
            });
            Promise.race([N, M]).then(function() {
              clearTimeout(r);
              a3(c2);
            }, b3);
          } else
            m2(function() {
              function v() {
                var b4;
                if (b4 = f != -1 && g != -1 || f != -1 && h != -1 || g != -1 && h != -1)
                  (b4 = f != g && f != h && g != h) || (C === null && (b4 = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent), C = !!b4 && (536 > parseInt(b4[1], 10) || parseInt(b4[1], 10) === 536 && 11 >= parseInt(b4[2], 10))), b4 = C && (f == w && g == w && h == w || f == x && g == x && h == x || f == y && g == y && h == y)), b4 = !b4;
                b4 && (d.parentNode && d.parentNode.removeChild(d), clearTimeout(r), a3(c2));
              }
              function I() {
                if (new Date().getTime() - H >= n)
                  d.parentNode && d.parentNode.removeChild(d), b3(Error("" + n + "ms timeout exceeded"));
                else {
                  var a4 = document.hidden;
                  if (a4 === true || a4 === void 0)
                    f = e.a.offsetWidth, g = p.a.offsetWidth, h = q.a.offsetWidth, v();
                  r = setTimeout(I, 50);
                }
              }
              var e = new t(k), p = new t(k), q = new t(k), f = -1, g = -1, h = -1, w = -1, x = -1, y = -1, d = document.createElement("div");
              d.dir = "ltr";
              u(e, L(c2, "sans-serif"));
              u(p, L(c2, "serif"));
              u(q, L(c2, "monospace"));
              d.appendChild(e.a);
              d.appendChild(p.a);
              d.appendChild(q.a);
              document.body.appendChild(d);
              w = e.a.offsetWidth;
              x = p.a.offsetWidth;
              y = q.a.offsetWidth;
              I();
              A(e, function(a4) {
                f = a4;
                v();
              });
              u(e, L(c2, '"' + c2.family + '",sans-serif'));
              A(p, function(a4) {
                g = a4;
                v();
              });
              u(p, L(c2, '"' + c2.family + '",serif'));
              A(q, function(a4) {
                h = a4;
                v();
              });
              u(q, L(c2, '"' + c2.family + '",monospace'));
            });
        });
      };
      typeof module === "object" ? module.exports = B : (window.FontFaceObserver = B, window.FontFaceObserver.prototype.load = B.prototype.load);
    })();
  }
});

// ../../node_modules/tslib/modules/index.js
var import_tslib = __toModule(require_tslib());
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet
} = import_tslib.default;

// ../../node_modules/framer-motion/dist/es/motion/index.js
import {
  Fragment,
  createElement as createElement2
} from "react";
import { forwardRef, useContext as useContext6 } from "react";

// ../../node_modules/framer-motion/dist/es/motion/features/use-features.js
import {
  createElement
} from "react";
import { useContext } from "react";

// ../../node_modules/framer-motion/dist/es/motion/features/definitions.js
var createDefinition = function(propNames) {
  return {
    isEnabled: function(props) {
      return propNames.some(function(name) {
        return !!props[name];
      });
    }
  };
};
var featureDefinitions = {
  measureLayout: createDefinition([
    "layout",
    "layoutId",
    "drag",
    "_layoutResetTransform"
  ]),
  animation: createDefinition([
    "animate",
    "exit",
    "variants",
    "whileHover",
    "whileTap",
    "whileFocus",
    "whileDrag"
  ]),
  exit: createDefinition(["exit"]),
  drag: createDefinition(["drag", "dragControls"]),
  focus: createDefinition(["whileFocus"]),
  hover: createDefinition(["whileHover", "onHoverStart", "onHoverEnd"]),
  tap: createDefinition(["whileTap", "onTap", "onTapStart", "onTapCancel"]),
  pan: createDefinition([
    "onPan",
    "onPanStart",
    "onPanSessionStart",
    "onPanEnd"
  ]),
  layoutAnimation: createDefinition(["layout", "layoutId"])
};
function loadFeatures(features) {
  for (var key6 in features) {
    var Component19 = features[key6];
    if (Component19 !== null)
      featureDefinitions[key6].Component = Component19;
  }
}

// ../../node_modules/hey-listen/dist/hey-listen.es.js
var warning = function() {
};
var invariant = function() {
};
if (true) {
  warning = function(check, message) {
    if (!check && typeof console !== "undefined") {
      console.warn(message);
    }
  };
  invariant = function(check, message) {
    if (!check) {
      throw new Error(message);
    }
  };
}

// ../../node_modules/framer-motion/dist/es/context/LazyContext.js
import { createContext } from "react";
var LazyContext = createContext({ strict: false });

// ../../node_modules/framer-motion/dist/es/motion/features/use-features.js
var featureNames = Object.keys(featureDefinitions);
var numFeatures = featureNames.length;
function useFeatures(props, visualElement2, preloadedFeatures) {
  var features = [];
  var lazyContext = useContext(LazyContext);
  if (!visualElement2)
    return null;
  if (preloadedFeatures && lazyContext.strict) {
    invariant(false, "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.");
  }
  for (var i = 0; i < numFeatures; i++) {
    var name_1 = featureNames[i];
    var _a = featureDefinitions[name_1], isEnabled = _a.isEnabled, Component19 = _a.Component;
    if (isEnabled(props) && Component19) {
      features.push(createElement(Component19, __assign({ key: name_1 }, props, { visualElement: visualElement2 })));
    }
  }
  return features;
}

// ../../node_modules/framer-motion/dist/es/context/MotionConfigContext.js
import { createContext as createContext2 } from "react";
var MotionConfigContext = createContext2({
  transformPagePoint: function(p) {
    return p;
  },
  isStatic: false
});

// ../../node_modules/framer-motion/dist/es/context/MotionContext/index.js
import { useContext as useContext2, createContext as createContext3 } from "react";
var MotionContext = createContext3({});
function useVisualElementContext() {
  return useContext2(MotionContext).visualElement;
}

// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-element.js
import { useContext as useContext4, useRef as useRef2, useEffect as useEffect3 } from "react";

// ../../node_modules/framer-motion/dist/es/context/PresenceContext.js
import { createContext as createContext4 } from "react";
var PresenceContext = createContext4(null);

// ../../node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.js
import { useContext as useContext3, useEffect } from "react";

// ../../node_modules/framer-motion/dist/es/utils/use-constant.js
import { useRef } from "react";
function useConstant(init) {
  var ref = useRef(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}

// ../../node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.js
function usePresence() {
  var context = useContext3(PresenceContext);
  if (context === null)
    return [true, null];
  var isPresent2 = context.isPresent, onExitComplete = context.onExitComplete, register = context.register;
  var id = useUniqueId();
  useEffect(function() {
    return register(id);
  }, []);
  var safeToRemove = function() {
    return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id);
  };
  return !isPresent2 && onExitComplete ? [false, safeToRemove] : [true];
}
function useIsPresent() {
  return isPresent(useContext3(PresenceContext));
}
function isPresent(context) {
  return context === null ? true : context.isPresent;
}
var counter = 0;
var incrementId = function() {
  return counter++;
};
var useUniqueId = function() {
  return useConstant(incrementId);
};

// ../../node_modules/framer-motion/dist/es/context/LayoutGroupContext.js
import { createContext as createContext5 } from "react";
var LayoutGroupContext = createContext5(null);

// ../../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.js
import { useLayoutEffect, useEffect as useEffect2 } from "react";

// ../../node_modules/framer-motion/dist/es/utils/is-browser.js
var isBrowser = typeof window !== "undefined";

// ../../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.js
var useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : useEffect2;

// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-element.js
function useLayoutId(_a) {
  var layoutId = _a.layoutId;
  var layoutGroupId = useContext4(LayoutGroupContext);
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function useVisualElement(Component19, visualState, props, createVisualElement) {
  var config = useContext4(MotionConfigContext);
  var lazyContext = useContext4(LazyContext);
  var parent = useVisualElementContext();
  var presenceContext = useContext4(PresenceContext);
  var layoutId = useLayoutId(props);
  var visualElementRef = useRef2(void 0);
  if (!createVisualElement)
    createVisualElement = lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component19, {
      visualState,
      parent,
      props: __assign(__assign({}, props), { layoutId }),
      presenceId: presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id,
      blockInitialAnimation: (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false
    });
  }
  var visualElement2 = visualElementRef.current;
  useIsomorphicLayoutEffect(function() {
    if (!visualElement2)
      return;
    visualElement2.setProps(__assign(__assign(__assign({}, config), props), { layoutId }));
    visualElement2.isPresent = isPresent(presenceContext);
    visualElement2.isPresenceRoot = !parent || parent.presenceId !== (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id);
    visualElement2.syncRender();
  });
  useEffect3(function() {
    var _a;
    if (!visualElement2)
      return;
    (_a = visualElement2.animationState) === null || _a === void 0 ? void 0 : _a.animateChanges();
  });
  useIsomorphicLayoutEffect(function() {
    return function() {
      return visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.notifyUnmount();
    };
  }, []);
  return visualElement2;
}

// ../../node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.js
import { useCallback } from "react";

// ../../node_modules/framer-motion/dist/es/utils/is-ref-object.js
function isRefObject(ref) {
  return typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}

// ../../node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.js
function useMotionRef(visualState, visualElement2, externalRef) {
  return useCallback(function(instance) {
    var _a;
    instance && ((_a = visualState.mount) === null || _a === void 0 ? void 0 : _a.call(visualState, instance));
    if (visualElement2) {
      instance ? visualElement2.mount(instance) : visualElement2.unmount();
    }
    if (externalRef) {
      if (typeof externalRef === "function") {
        externalRef(instance);
      } else if (isRefObject(externalRef)) {
        externalRef.current = instance;
      }
    }
  }, [visualElement2]);
}

// ../../node_modules/framer-motion/dist/es/context/MotionContext/create.js
import { useMemo, useContext as useContext5 } from "react";

// ../../node_modules/framer-motion/dist/es/render/utils/variants.js
function isVariantLabels(v) {
  return Array.isArray(v);
}
function isVariantLabel(v) {
  return typeof v === "string" || isVariantLabels(v);
}
function getCurrent(visualElement2) {
  var current = {};
  visualElement2.forEachValue(function(value, key6) {
    return current[key6] = value.get();
  });
  return current;
}
function getVelocity(visualElement2) {
  var velocity = {};
  visualElement2.forEachValue(function(value, key6) {
    return velocity[key6] = value.getVelocity();
  });
  return velocity;
}
function resolveVariantFromProps(props, definition, custom, currentValues, currentVelocity) {
  var _a;
  if (currentValues === void 0) {
    currentValues = {};
  }
  if (currentVelocity === void 0) {
    currentVelocity = {};
  }
  if (typeof definition === "string") {
    definition = (_a = props.variants) === null || _a === void 0 ? void 0 : _a[definition];
  }
  return typeof definition === "function" ? definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity) : definition;
}
function resolveVariant(visualElement2, definition, custom) {
  var props = visualElement2.getProps();
  return resolveVariantFromProps(props, definition, custom !== null && custom !== void 0 ? custom : props.custom, getCurrent(visualElement2), getVelocity(visualElement2));
}
function checkIfControllingVariants(props) {
  var _a;
  return typeof ((_a = props.animate) === null || _a === void 0 ? void 0 : _a.start) === "function" || isVariantLabel(props.initial) || isVariantLabel(props.animate) || isVariantLabel(props.whileHover) || isVariantLabel(props.whileDrag) || isVariantLabel(props.whileTap) || isVariantLabel(props.whileFocus) || isVariantLabel(props.exit);
}
function checkIfVariantNode(props) {
  return Boolean(checkIfControllingVariants(props) || props.variants);
}

// ../../node_modules/framer-motion/dist/es/context/MotionContext/utils.js
function getCurrentTreeVariants(props, context) {
  if (checkIfControllingVariants(props)) {
    var initial = props.initial, animate4 = props.animate;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate4) ? animate4 : void 0
    };
  }
  return props.inherit !== false ? context : {};
}

// ../../node_modules/framer-motion/dist/es/context/MotionContext/create.js
function useCreateMotionContext(props, isStatic) {
  var _a = getCurrentTreeVariants(props, useContext5(MotionContext)), initial = _a.initial, animate4 = _a.animate;
  return useMemo(function() {
    return { initial, animate: animate4 };
  }, isStatic ? [
    variantLabelsAsDependency(initial),
    variantLabelsAsDependency(animate4)
  ] : []);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}

// ../../node_modules/framer-motion/dist/es/motion/index.js
function createMotionComponent(_a) {
  var preloadedFeatures = _a.preloadedFeatures, createVisualElement = _a.createVisualElement, useRender = _a.useRender, useVisualState2 = _a.useVisualState, Component19 = _a.Component;
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    var isStatic = useContext6(MotionConfigContext).isStatic;
    var features = null;
    var context = useCreateMotionContext(props, isStatic);
    var visualState = useVisualState2(props, isStatic);
    if (!isStatic && isBrowser) {
      context.visualElement = useVisualElement(Component19, visualState, props, createVisualElement);
      features = useFeatures(props, context.visualElement, preloadedFeatures);
    }
    return createElement2(Fragment, null, createElement2(MotionContext.Provider, { value: context }, useRender(Component19, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic)), features);
  }
  return forwardRef(MotionComponent);
}

// ../../node_modules/framer-motion/dist/es/render/dom/motion-proxy.js
function createMotionProxy(createConfig) {
  function custom(Component19, customMotionComponentConfig) {
    if (customMotionComponentConfig === void 0) {
      customMotionComponentConfig = {};
    }
    return createMotionComponent(createConfig(Component19, customMotionComponentConfig));
  }
  var componentCache = new Map();
  return new Proxy(custom, {
    get: function(_target, key6) {
      if (!componentCache.has(key6)) {
        componentCache.set(key6, custom(key6));
      }
      return componentCache.get(key6);
    }
  });
}

// ../../node_modules/framer-motion/dist/es/render/svg/lowercase-elements.js
var lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "tspan",
  "use",
  "view"
];

// ../../node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.js
function isSVGComponent(Component19) {
  if (typeof Component19 !== "string" || Component19.includes("-")) {
    return false;
  } else if (lowercaseSVGElements.indexOf(Component19) > -1 || /[A-Z]/.test(Component19)) {
    return true;
  }
  return false;
}

// ../../node_modules/framer-motion/dist/es/render/dom/use-render.js
import { createElement as createElement3 } from "react";

// ../../node_modules/framer-motion/dist/es/render/html/use-props.js
import { useMemo as useMemo2 } from "react";

// ../../node_modules/framer-motion/dist/es/render/dom/projection/scale-correction.js
var valueScaleCorrection = {};
function addScaleCorrection(correctors) {
  for (var key6 in correctors) {
    valueScaleCorrection[key6] = correctors[key6];
  }
}

// ../../node_modules/framer-motion/dist/es/render/html/utils/transform.js
var transformAxes = ["", "X", "Y", "Z"];
var order = ["translate", "scale", "rotate", "skew"];
var transformProps = ["transformPerspective", "x", "y", "z"];
order.forEach(function(operationKey) {
  return transformAxes.forEach(function(axesKey) {
    return transformProps.push(operationKey + axesKey);
  });
});
function sortTransformProps(a2, b2) {
  return transformProps.indexOf(a2) - transformProps.indexOf(b2);
}
var transformPropSet = new Set(transformProps);
function isTransformProp(key6) {
  return transformPropSet.has(key6);
}
var transformOriginProps = new Set(["originX", "originY", "originZ"]);
function isTransformOriginProp(key6) {
  return transformOriginProps.has(key6);
}

// ../../node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.js
function isForcedMotionValue(key6, _a) {
  var layout = _a.layout, layoutId = _a.layoutId;
  return isTransformProp(key6) || isTransformOriginProp(key6) || (layout || layoutId !== void 0) && (!!valueScaleCorrection[key6] || key6 === "opacity");
}

// ../../node_modules/framer-motion/dist/es/value/utils/is-motion-value.js
var isMotionValue = function(value) {
  return value !== null && typeof value === "object" && value.getVelocity;
};

// ../../node_modules/framer-motion/dist/es/render/html/utils/build-transform.js
var translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
function buildTransform(_a, _b, transformIsDefault, transformTemplate2) {
  var transform2 = _a.transform, transformKeys2 = _a.transformKeys;
  var _c = _b.enableHardwareAcceleration, enableHardwareAcceleration = _c === void 0 ? true : _c, _d = _b.allowTransformNone, allowTransformNone = _d === void 0 ? true : _d;
  var transformString2 = "";
  transformKeys2.sort(sortTransformProps);
  var transformHasZ = false;
  var numTransformKeys = transformKeys2.length;
  for (var i = 0; i < numTransformKeys; i++) {
    var key6 = transformKeys2[i];
    transformString2 += (translateAlias[key6] || key6) + "(" + transform2[key6] + ") ";
    if (key6 === "z")
      transformHasZ = true;
  }
  if (!transformHasZ && enableHardwareAcceleration) {
    transformString2 += "translateZ(0)";
  } else {
    transformString2 = transformString2.trim();
  }
  if (transformTemplate2) {
    transformString2 = transformTemplate2(transform2, transformIsDefault ? "" : transformString2);
  } else if (allowTransformNone && transformIsDefault) {
    transformString2 = "none";
  }
  return transformString2;
}
function buildTransformOrigin(_a) {
  var _b = _a.originX, originX = _b === void 0 ? "50%" : _b, _c = _a.originY, originY = _c === void 0 ? "50%" : _c, _d = _a.originZ, originZ = _d === void 0 ? 0 : _d;
  return originX + " " + originY + " " + originZ;
}

// ../../node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.js
function isCSSVariable(key6) {
  return key6.startsWith("--");
}

// ../../node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.js
var getValueAsType = function(value, type) {
  return type && typeof value === "number" ? type.transform(value) : value;
};

// ../../node_modules/style-value-types/dist/es/utils.js
var clamp = function(min, max) {
  return function(v) {
    return Math.max(Math.min(v, max), min);
  };
};
var sanitize = function(v) {
  return v % 1 ? Number(v.toFixed(5)) : v;
};
var floatRegex = /(-)?([\d]*\.?[\d])+/g;
var colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi;
var singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;
function isString(v) {
  return typeof v === "string";
}

// ../../node_modules/style-value-types/dist/es/numbers/index.js
var number = {
  test: function(v) {
    return typeof v === "number";
  },
  parse: parseFloat,
  transform: function(v) {
    return v;
  }
};
var alpha = __assign(__assign({}, number), { transform: clamp(0, 1) });
var scale = __assign(__assign({}, number), { default: 1 });

// ../../node_modules/style-value-types/dist/es/numbers/units.js
var createUnitType = function(unit) {
  return {
    test: function(v) {
      return isString(v) && v.endsWith(unit) && v.split(" ").length === 1;
    },
    parse: parseFloat,
    transform: function(v) {
      return "" + v + unit;
    }
  };
};
var degrees = createUnitType("deg");
var percent = createUnitType("%");
var px = createUnitType("px");
var vh = createUnitType("vh");
var vw = createUnitType("vw");
var progressPercentage = __assign(__assign({}, percent), { parse: function(v) {
  return percent.parse(v) / 100;
}, transform: function(v) {
  return percent.transform(v * 100);
} });

// ../../node_modules/style-value-types/dist/es/color/utils.js
var isColorString = function(type, testProp) {
  return function(v) {
    return Boolean(isString(v) && singleColorRegex.test(v) && v.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v, testProp));
  };
};
var splitColor = function(aName, bName, cName) {
  return function(v) {
    var _a;
    if (!isString(v))
      return v;
    var _b = v.match(floatRegex), a2 = _b[0], b2 = _b[1], c2 = _b[2], alpha2 = _b[3];
    return _a = {}, _a[aName] = parseFloat(a2), _a[bName] = parseFloat(b2), _a[cName] = parseFloat(c2), _a.alpha = alpha2 !== void 0 ? parseFloat(alpha2) : 1, _a;
  };
};

// ../../node_modules/style-value-types/dist/es/color/hsla.js
var hsla = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: function(_a) {
    var hue = _a.hue, saturation = _a.saturation, lightness = _a.lightness, _b = _a.alpha, alpha$1 = _b === void 0 ? 1 : _b;
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};

// ../../node_modules/style-value-types/dist/es/color/rgba.js
var clampRgbUnit = clamp(0, 255);
var rgbUnit = __assign(__assign({}, number), { transform: function(v) {
  return Math.round(clampRgbUnit(v));
} });
var rgba = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: function(_a) {
    var red = _a.red, green = _a.green, blue = _a.blue, _b = _a.alpha, alpha$1 = _b === void 0 ? 1 : _b;
    return "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};

// ../../node_modules/style-value-types/dist/es/color/hex.js
function parseHex(v) {
  var r = "";
  var g = "";
  var b2 = "";
  var a2 = "";
  if (v.length > 5) {
    r = v.substr(1, 2);
    g = v.substr(3, 2);
    b2 = v.substr(5, 2);
    a2 = v.substr(7, 2);
  } else {
    r = v.substr(1, 1);
    g = v.substr(2, 1);
    b2 = v.substr(3, 1);
    a2 = v.substr(4, 1);
    r += r;
    g += g;
    b2 += b2;
    a2 += a2;
  }
  return {
    red: parseInt(r, 16),
    green: parseInt(g, 16),
    blue: parseInt(b2, 16),
    alpha: a2 ? parseInt(a2, 16) / 255 : 1
  };
}
var hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};

// ../../node_modules/style-value-types/dist/es/color/index.js
var color = {
  test: function(v) {
    return rgba.test(v) || hex.test(v) || hsla.test(v);
  },
  parse: function(v) {
    if (rgba.test(v)) {
      return rgba.parse(v);
    } else if (hsla.test(v)) {
      return hsla.parse(v);
    } else {
      return hex.parse(v);
    }
  },
  transform: function(v) {
    return isString(v) ? v : v.hasOwnProperty("red") ? rgba.transform(v) : hsla.transform(v);
  }
};

// ../../node_modules/style-value-types/dist/es/complex/index.js
var colorToken = "${c}";
var numberToken = "${n}";
function test(v) {
  var _a, _b, _c, _d;
  return isNaN(v) && isString(v) && ((_b = (_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = v.match(colorRegex)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0;
}
function analyse(v) {
  var values = [];
  var numColors = 0;
  var colors = v.match(colorRegex);
  if (colors) {
    numColors = colors.length;
    v = v.replace(colorRegex, colorToken);
    values.push.apply(values, colors.map(color.parse));
  }
  var numbers = v.match(floatRegex);
  if (numbers) {
    v = v.replace(floatRegex, numberToken);
    values.push.apply(values, numbers.map(number.parse));
  }
  return { values, numColors, tokenised: v };
}
function parse(v) {
  return analyse(v).values;
}
function createTransformer(v) {
  var _a = analyse(v), values = _a.values, numColors = _a.numColors, tokenised = _a.tokenised;
  var numValues = values.length;
  return function(v2) {
    var output = tokenised;
    for (var i = 0; i < numValues; i++) {
      output = output.replace(i < numColors ? colorToken : numberToken, i < numColors ? color.transform(v2[i]) : sanitize(v2[i]));
    }
    return output;
  };
}
var convertNumbersToZero = function(v) {
  return typeof v === "number" ? 0 : v;
};
function getAnimatableNone(v) {
  var parsed = parse(v);
  var transformer = createTransformer(v);
  return transformer(parsed.map(convertNumbersToZero));
}
var complex = { test, parse, createTransformer, getAnimatableNone };

// ../../node_modules/style-value-types/dist/es/complex/filter.js
var maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v) {
  var _a = v.slice(0, -1).split("("), name = _a[0], value = _a[1];
  if (name === "drop-shadow")
    return v;
  var number2 = (value.match(floatRegex) || [])[0];
  if (!number2)
    return v;
  var unit = value.replace(number2, "");
  var defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name + "(" + defaultValue + unit + ")";
}
var functionRegex = /([a-z-]*)\(.*?\)/g;
var filter = __assign(__assign({}, complex), { getAnimatableNone: function(v) {
  var functions = v.match(functionRegex);
  return functions ? functions.map(applyDefaultFilter).join(" ") : v;
} });

// ../../node_modules/framer-motion/dist/es/render/dom/value-types/type-int.js
var int = __assign(__assign({}, number), { transform: Math.round });

// ../../node_modules/framer-motion/dist/es/render/dom/value-types/number.js
var numberValueTypes = {
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: __assign(__assign({}, alpha), { default: 1 }),
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  zIndex: int,
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};

// ../../node_modules/framer-motion/dist/es/render/html/utils/build-styles.js
function buildHTMLStyles(state, latestValues, projection, layoutState, options, transformTemplate2, buildProjectionTransform, buildProjectionTransformOrigin) {
  var _a;
  var style = state.style, vars = state.vars, transform2 = state.transform, transformKeys2 = state.transformKeys, transformOrigin = state.transformOrigin;
  transformKeys2.length = 0;
  var hasTransform = false;
  var hasTransformOrigin = false;
  var transformIsNone = true;
  for (var key6 in latestValues) {
    var value = latestValues[key6];
    if (isCSSVariable(key6)) {
      vars[key6] = value;
      continue;
    }
    var valueType = numberValueTypes[key6];
    var valueAsType = getValueAsType(value, valueType);
    if (isTransformProp(key6)) {
      hasTransform = true;
      transform2[key6] = valueAsType;
      transformKeys2.push(key6);
      if (!transformIsNone)
        continue;
      if (value !== ((_a = valueType.default) !== null && _a !== void 0 ? _a : 0))
        transformIsNone = false;
    } else if (isTransformOriginProp(key6)) {
      transformOrigin[key6] = valueAsType;
      hasTransformOrigin = true;
    } else {
      if (layoutState && projection && layoutState.isHydrated && valueScaleCorrection[key6]) {
        var correctedValue = valueScaleCorrection[key6].process(value, layoutState, projection);
        var applyTo = valueScaleCorrection[key6].applyTo;
        if (applyTo) {
          var num = applyTo.length;
          for (var i = 0; i < num; i++) {
            style[applyTo[i]] = correctedValue;
          }
        } else {
          style[key6] = correctedValue;
        }
      } else {
        style[key6] = valueAsType;
      }
    }
  }
  if (layoutState && projection && buildProjectionTransform && buildProjectionTransformOrigin) {
    style.transform = buildProjectionTransform(layoutState.deltaFinal, layoutState.treeScale, hasTransform ? transform2 : void 0);
    if (transformTemplate2) {
      style.transform = transformTemplate2(transform2, style.transform);
    }
    style.transformOrigin = buildProjectionTransformOrigin(layoutState);
  } else {
    if (hasTransform) {
      style.transform = buildTransform(state, options, transformIsNone, transformTemplate2);
    }
    if (hasTransformOrigin) {
      style.transformOrigin = buildTransformOrigin(transformOrigin);
    }
  }
}

// ../../node_modules/framer-motion/dist/es/render/html/utils/create-render-state.js
var createHtmlRenderState = function() {
  return {
    style: {},
    transform: {},
    transformKeys: [],
    transformOrigin: {},
    vars: {}
  };
};

// ../../node_modules/framer-motion/dist/es/render/html/use-props.js
function copyRawValuesOnly(target, source, props) {
  for (var key6 in source) {
    if (!isMotionValue(source[key6]) && !isForcedMotionValue(key6, props)) {
      target[key6] = source[key6];
    }
  }
}
function useInitialMotionValues(_a, visualState, isStatic) {
  var transformTemplate2 = _a.transformTemplate;
  return useMemo2(function() {
    var state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, void 0, void 0, { enableHardwareAcceleration: !isStatic }, transformTemplate2);
    var vars = state.vars, style = state.style;
    return __assign(__assign({}, vars), style);
  }, [visualState]);
}
function useStyle(props, visualState, isStatic) {
  var styleProp = props.style || {};
  var style = {};
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState, isStatic));
  if (props.transformValues) {
    style = props.transformValues(style);
  }
  return style;
}
function useHTMLProps(props, visualState, isStatic) {
  var htmlProps = {};
  var style = useStyle(props, visualState, isStatic);
  if (Boolean(props.drag)) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props.drag === true ? "none" : "pan-" + (props.drag === "x" ? "y" : "x");
  }
  htmlProps.style = style;
  return htmlProps;
}

// ../../node_modules/framer-motion/dist/es/motion/utils/valid-prop.js
var validMotionProps = new Set([
  "initial",
  "animate",
  "exit",
  "style",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "layout",
  "layoutId",
  "_layoutResetTransform",
  "onLayoutAnimationComplete",
  "onViewportBoxUpdate",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "drag",
  "dragControls",
  "dragListener",
  "dragConstraints",
  "dragDirectionLock",
  "_dragX",
  "_dragY",
  "dragElastic",
  "dragMomentum",
  "dragPropagation",
  "dragTransition",
  "whileDrag",
  "onPan",
  "onPanStart",
  "onPanEnd",
  "onPanSessionStart",
  "onTap",
  "onTapStart",
  "onTapCancel",
  "onHoverStart",
  "onHoverEnd",
  "whileFocus",
  "whileTap",
  "whileHover"
]);
function isValidMotionProp(key6) {
  return validMotionProps.has(key6);
}

// ../../node_modules/framer-motion/dist/es/render/dom/utils/filter-props.js
var shouldForward = function(key6) {
  return !isValidMotionProp(key6);
};
try {
  emotionIsPropValid_1 = require_is_prop_valid_browser_cjs().default;
  shouldForward = function(key6) {
    if (key6.startsWith("on")) {
      return !isValidMotionProp(key6);
    } else {
      return emotionIsPropValid_1(key6);
    }
  };
} catch (_a) {
}
var emotionIsPropValid_1;
function filterProps(props, isDom, forwardMotionProps) {
  var filteredProps2 = {};
  for (var key6 in props) {
    if (shouldForward(key6) || forwardMotionProps === true && isValidMotionProp(key6) || !isDom && !isValidMotionProp(key6)) {
      filteredProps2[key6] = props[key6];
    }
  }
  return filteredProps2;
}

// ../../node_modules/framer-motion/dist/es/render/svg/use-props.js
import { useMemo as useMemo3 } from "react";

// ../../node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.js
function calcOrigin(origin, offset, size2) {
  return typeof origin === "string" ? origin : px.transform(offset + size2 * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  var pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);
  var pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
  return pxOriginX + " " + pxOriginY;
}

// ../../node_modules/framer-motion/dist/es/render/svg/utils/path.js
var progressToPixels = function(progress2, length) {
  return px.transform(progress2 * length);
};
var dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
var camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {
  if (spacing === void 0) {
    spacing = 1;
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (useDashCase === void 0) {
    useDashCase = true;
  }
  var keys2 = useDashCase ? dashKeys : camelKeys;
  attrs[keys2.offset] = progressToPixels(-offset, totalLength);
  var pathLength = progressToPixels(length, totalLength);
  var pathSpacing = progressToPixels(spacing, totalLength);
  attrs[keys2.array] = pathLength + " " + pathSpacing;
}

// ../../node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.js
function buildSVGAttrs(state, _a, projection, layoutState, options, transformTemplate2, buildProjectionTransform, buildProjectionTransformOrigin) {
  var attrX = _a.attrX, attrY = _a.attrY, originX = _a.originX, originY = _a.originY, pathLength = _a.pathLength, _b = _a.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a.pathOffset, pathOffset = _c === void 0 ? 0 : _c, latest = __rest(_a, ["attrX", "attrY", "originX", "originY", "pathLength", "pathSpacing", "pathOffset"]);
  buildHTMLStyles(state, latest, projection, layoutState, options, transformTemplate2, buildProjectionTransform, buildProjectionTransformOrigin);
  state.attrs = state.style;
  state.style = {};
  var attrs = state.attrs, style = state.style, dimensions = state.dimensions, totalPathLength = state.totalPathLength;
  if (attrs.transform) {
    if (dimensions)
      style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (totalPathLength !== void 0 && pathLength !== void 0) {
    buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);
  }
}

// ../../node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.js
var createSvgRenderState = function() {
  return __assign(__assign({}, createHtmlRenderState()), { attrs: {} });
};

// ../../node_modules/framer-motion/dist/es/render/svg/use-props.js
function useSVGProps(props, visualState) {
  var visualProps = useMemo3(function() {
    var state = createSvgRenderState();
    buildSVGAttrs(state, visualState, void 0, void 0, { enableHardwareAcceleration: false }, props.transformTemplate);
    return __assign(__assign({}, state.attrs), { style: __assign({}, state.style) });
  }, [visualState]);
  if (props.style) {
    var rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = __assign(__assign({}, rawStyles), visualProps.style);
  }
  return visualProps;
}

// ../../node_modules/framer-motion/dist/es/render/dom/use-render.js
function createUseRender(forwardMotionProps) {
  if (forwardMotionProps === void 0) {
    forwardMotionProps = false;
  }
  var useRender = function(Component19, props, ref, _a, isStatic) {
    var latestValues = _a.latestValues;
    var useVisualProps = isSVGComponent(Component19) ? useSVGProps : useHTMLProps;
    var visualProps = useVisualProps(props, latestValues, isStatic);
    var filteredProps2 = filterProps(props, typeof Component19 === "string", forwardMotionProps);
    var elementProps = __assign(__assign(__assign({}, filteredProps2), visualProps), { ref });
    return createElement3(Component19, elementProps);
  };
  return useRender;
}

// ../../node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.js
var CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;
var REPLACE_TEMPLATE = "$1-$2";
var camelToDash = function(str) {
  return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();
};

// ../../node_modules/framer-motion/dist/es/render/html/utils/render.js
function renderHTML(element, _a) {
  var style = _a.style, vars = _a.vars;
  Object.assign(element.style, style);
  for (var key6 in vars) {
    element.style.setProperty(key6, vars[key6]);
  }
}

// ../../node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.js
var camelCaseAttributes = new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox"
]);

// ../../node_modules/framer-motion/dist/es/render/svg/utils/render.js
function renderSVG(element, renderState) {
  renderHTML(element, renderState);
  for (var key6 in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key6) ? camelToDash(key6) : key6, renderState.attrs[key6]);
  }
}

// ../../node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.js
function scrapeMotionValuesFromProps(props) {
  var style = props.style;
  var newValues = {};
  for (var key6 in style) {
    if (isMotionValue(style[key6]) || isForcedMotionValue(key6, props)) {
      newValues[key6] = style[key6];
    }
  }
  return newValues;
}

// ../../node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.js
function scrapeMotionValuesFromProps2(props) {
  var newValues = scrapeMotionValuesFromProps(props);
  for (var key6 in props) {
    if (isMotionValue(props[key6])) {
      var targetKey = key6 === "x" || key6 === "y" ? "attr" + key6.toUpperCase() : key6;
      newValues[targetKey] = props[key6];
    }
  }
  return newValues;
}

// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-state.js
import { useContext as useContext7 } from "react";

// ../../node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.js
function isAnimationControls(v) {
  return typeof v === "object" && typeof v.start === "function";
}

// ../../node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.js
var isKeyframesTarget = function(v) {
  return Array.isArray(v);
};

// ../../node_modules/framer-motion/dist/es/utils/resolve-value.js
var isCustomValue = function(v) {
  return Boolean(v && typeof v === "object" && v.mix && v.toValue);
};
var resolveFinalValueInKeyframes = function(v) {
  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
};

// ../../node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.js
function resolveMotionValue(value) {
  var unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}

// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-state.js
function makeState(_a, props, context, presenceContext) {
  var scrapeMotionValuesFromProps3 = _a.scrapeMotionValuesFromProps, createRenderState = _a.createRenderState, onMount = _a.onMount;
  var state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),
    renderState: createRenderState()
  };
  if (onMount) {
    state.mount = function(instance) {
      return onMount(props, instance, state);
    };
  }
  return state;
}
var makeUseVisualState = function(config) {
  return function(props, isStatic) {
    var context = useContext7(MotionContext);
    var presenceContext = useContext7(PresenceContext);
    return isStatic ? makeState(config, props, context, presenceContext) : useConstant(function() {
      return makeState(config, props, context, presenceContext);
    });
  };
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  var values = {};
  var blockInitialAnimation = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false;
  var motionValues = scrapeMotionValues(props);
  for (var key6 in motionValues) {
    values[key6] = resolveMotionValue(motionValues[key6]);
  }
  var initial = props.initial, animate4 = props.animate;
  var isControllingVariants = checkIfControllingVariants(props);
  var isVariantNode = checkIfVariantNode(props);
  if (context && isVariantNode && !isControllingVariants && props.inherit !== false) {
    initial !== null && initial !== void 0 ? initial : initial = context.initial;
    animate4 !== null && animate4 !== void 0 ? animate4 : animate4 = context.animate;
  }
  var variantToSet = blockInitialAnimation || initial === false ? animate4 : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    var list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    list.forEach(function(definition) {
      var resolved = resolveVariantFromProps(props, definition);
      if (!resolved)
        return;
      var transitionEnd = resolved.transitionEnd;
      resolved.transition;
      var target = __rest(resolved, ["transitionEnd", "transition"]);
      for (var key7 in target)
        values[key7] = target[key7];
      for (var key7 in transitionEnd)
        values[key7] = transitionEnd[key7];
    });
  }
  return values;
}

// ../../node_modules/framer-motion/dist/es/render/svg/config-motion.js
var svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
    createRenderState: createSvgRenderState,
    onMount: function(props, instance, _a) {
      var renderState = _a.renderState, latestValues = _a.latestValues;
      try {
        renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
      } catch (e) {
        renderState.dimensions = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }
      if (isPath(instance)) {
        renderState.totalPathLength = instance.getTotalLength();
      }
      buildSVGAttrs(renderState, latestValues, void 0, void 0, { enableHardwareAcceleration: false }, props.transformTemplate);
      renderSVG(instance, renderState);
    }
  })
};
function isPath(element) {
  return element.tagName === "path";
}

// ../../node_modules/framer-motion/dist/es/render/html/config-motion.js
var htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createHtmlRenderState
  })
};

// ../../node_modules/framer-motion/dist/es/render/dom/utils/create-config.js
function createDomMotionConfig(Component19, _a, preloadedFeatures, createVisualElement) {
  var _b = _a.forwardMotionProps, forwardMotionProps = _b === void 0 ? false : _b;
  var baseConfig = isSVGComponent(Component19) ? svgMotionConfig : htmlMotionConfig;
  return __assign(__assign({}, baseConfig), {
    preloadedFeatures,
    useRender: createUseRender(forwardMotionProps),
    createVisualElement,
    Component: Component19
  });
}

// ../../node_modules/framer-motion/dist/es/render/utils/types.js
var AnimationType;
(function(AnimationType2) {
  AnimationType2["Animate"] = "animate";
  AnimationType2["Hover"] = "whileHover";
  AnimationType2["Tap"] = "whileTap";
  AnimationType2["Drag"] = "whileDrag";
  AnimationType2["Focus"] = "whileFocus";
  AnimationType2["Exit"] = "exit";
})(AnimationType || (AnimationType = {}));

// ../../node_modules/framer-motion/dist/es/events/use-dom-event.js
import { useEffect as useEffect4 } from "react";
function addDomEvent(target, eventName, handler, options) {
  target.addEventListener(eventName, handler, options);
  return function() {
    return target.removeEventListener(eventName, handler, options);
  };
}
function useDomEvent(ref, eventName, handler, options) {
  useEffect4(function() {
    var element = ref.current;
    if (handler && element) {
      return addDomEvent(element, eventName, handler, options);
    }
  }, [ref, eventName, handler, options]);
}

// ../../node_modules/framer-motion/dist/es/gestures/use-focus-gesture.js
function useFocusGesture(_a) {
  var whileFocus = _a.whileFocus, visualElement2 = _a.visualElement;
  var onFocus = function() {
    var _a2;
    (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Focus, true);
  };
  var onBlur = function() {
    var _a2;
    (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Focus, false);
  };
  useDomEvent(visualElement2, "focus", whileFocus ? onFocus : void 0);
  useDomEvent(visualElement2, "blur", whileFocus ? onBlur : void 0);
}

// ../../node_modules/framer-motion/dist/es/gestures/utils/event-type.js
function isMouseEvent(event) {
  if (typeof PointerEvent !== "undefined" && event instanceof PointerEvent) {
    return !!(event.pointerType === "mouse");
  }
  return event instanceof MouseEvent;
}
function isTouchEvent(event) {
  var hasTouches = !!event.touches;
  return hasTouches;
}

// ../../node_modules/framer-motion/dist/es/events/event-info.js
function filterPrimaryPointer(eventHandler) {
  return function(event) {
    var isMouseEvent2 = event instanceof MouseEvent;
    var isPrimaryPointer = !isMouseEvent2 || isMouseEvent2 && event.button === 0;
    if (isPrimaryPointer) {
      eventHandler(event);
    }
  };
}
var defaultPagePoint = { pageX: 0, pageY: 0 };
function pointFromTouch(e, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  var primaryTouch = e.touches[0] || e.changedTouches[0];
  var point = primaryTouch || defaultPagePoint;
  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}
function pointFromMouse(point, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}
function extractEventInfo(event, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  return {
    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)
  };
}
function getViewportPointFromEvent(event) {
  return extractEventInfo(event, "client");
}
var wrapHandler = function(handler, shouldFilterPrimaryPointer) {
  if (shouldFilterPrimaryPointer === void 0) {
    shouldFilterPrimaryPointer = false;
  }
  var listener = function(event) {
    return handler(event, extractEventInfo(event));
  };
  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;
};

// ../../node_modules/framer-motion/dist/es/events/utils.js
var supportsPointerEvents = function() {
  return isBrowser && window.onpointerdown === null;
};
var supportsTouchEvents = function() {
  return isBrowser && window.ontouchstart === null;
};
var supportsMouseEvents = function() {
  return isBrowser && window.onmousedown === null;
};

// ../../node_modules/framer-motion/dist/es/events/use-pointer-event.js
var mouseEventNames = {
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointercancel: "mousecancel",
  pointerover: "mouseover",
  pointerout: "mouseout",
  pointerenter: "mouseenter",
  pointerleave: "mouseleave"
};
var touchEventNames = {
  pointerdown: "touchstart",
  pointermove: "touchmove",
  pointerup: "touchend",
  pointercancel: "touchcancel"
};
function getPointerEventName(name) {
  if (supportsPointerEvents()) {
    return name;
  } else if (supportsTouchEvents()) {
    return touchEventNames[name];
  } else if (supportsMouseEvents()) {
    return mouseEventNames[name];
  }
  return name;
}
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === "pointerdown"), options);
}
function usePointerEvent(ref, eventName, handler, options) {
  return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === "pointerdown"), options);
}

// ../../node_modules/framer-motion/dist/es/gestures/drag/utils/lock.js
function createLock(name) {
  var lock = null;
  return function() {
    var openLock = function() {
      lock = null;
    };
    if (lock === null) {
      lock = name;
      return openLock;
    }
    return false;
  };
}
var globalHorizontalLock = createLock("dragHorizontal");
var globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  var lock = false;
  if (drag2 === "y") {
    lock = globalVerticalLock();
  } else if (drag2 === "x") {
    lock = globalHorizontalLock();
  } else {
    var openHorizontal_1 = globalHorizontalLock();
    var openVertical_1 = globalVerticalLock();
    if (openHorizontal_1 && openVertical_1) {
      lock = function() {
        openHorizontal_1();
        openVertical_1();
      };
    } else {
      if (openHorizontal_1)
        openHorizontal_1();
      if (openVertical_1)
        openVertical_1();
    }
  }
  return lock;
}
function isDragActive() {
  var openGestureLock = getGlobalLock(true);
  if (!openGestureLock)
    return true;
  openGestureLock();
  return false;
}

// ../../node_modules/framer-motion/dist/es/gestures/use-hover-gesture.js
function createHoverEvent(visualElement2, isActive, callback) {
  return function(event, info) {
    var _a;
    if (!isMouseEvent(event) || !visualElement2.isHoverEventsEnabled || isDragActive()) {
      return;
    }
    callback === null || callback === void 0 ? void 0 : callback(event, info);
    (_a = visualElement2.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Hover, isActive);
  };
}
function useHoverGesture(_a) {
  var onHoverStart = _a.onHoverStart, onHoverEnd = _a.onHoverEnd, whileHover = _a.whileHover, visualElement2 = _a.visualElement;
  usePointerEvent(visualElement2, "pointerenter", onHoverStart || whileHover ? createHoverEvent(visualElement2, true, onHoverStart) : void 0);
  usePointerEvent(visualElement2, "pointerleave", onHoverEnd || whileHover ? createHoverEvent(visualElement2, false, onHoverEnd) : void 0);
}

// ../../node_modules/framer-motion/dist/es/gestures/use-tap-gesture.js
import { useRef as useRef3 } from "react";

// ../../node_modules/framer-motion/dist/es/gestures/utils/is-node-or-child.js
var isNodeOrChild = function(parent, child) {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};

// ../../node_modules/framer-motion/dist/es/utils/use-unmount-effect.js
import { useEffect as useEffect5 } from "react";
function useUnmountEffect(callback) {
  return useEffect5(function() {
    return function() {
      return callback();
    };
  }, []);
}

// ../../node_modules/popmotion/dist/es/utils/clamp.js
var clamp2 = function(min, max, v) {
  return Math.min(Math.max(v, min), max);
};

// ../../node_modules/popmotion/dist/es/animations/utils/find-spring.js
var safeMin = 1e-3;
var minDuration = 0.01;
var maxDuration = 10;
var minDamping = 0.05;
var maxDamping = 1;
function findSpring(_a) {
  var _b = _a.duration, duration = _b === void 0 ? 800 : _b, _c = _a.bounce, bounce = _c === void 0 ? 0.25 : _c, _d = _a.velocity, velocity = _d === void 0 ? 0 : _d, _e = _a.mass, mass = _e === void 0 ? 1 : _e;
  var envelope;
  var derivative;
  warning(duration <= maxDuration * 1e3, "Spring duration must be 10 seconds or less");
  var dampingRatio = 1 - bounce;
  dampingRatio = clamp2(minDamping, maxDamping, dampingRatio);
  duration = clamp2(minDuration, maxDuration, duration / 1e3);
  if (dampingRatio < 1) {
    envelope = function(undampedFreq2) {
      var exponentialDecay = undampedFreq2 * dampingRatio;
      var delta2 = exponentialDecay * duration;
      var a2 = exponentialDecay - velocity;
      var b2 = calcAngularFreq(undampedFreq2, dampingRatio);
      var c2 = Math.exp(-delta2);
      return safeMin - a2 / b2 * c2;
    };
    derivative = function(undampedFreq2) {
      var exponentialDecay = undampedFreq2 * dampingRatio;
      var delta2 = exponentialDecay * duration;
      var d = delta2 * velocity + velocity;
      var e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      var f = Math.exp(-delta2);
      var g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      var factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d - e) * f) / g;
    };
  } else {
    envelope = function(undampedFreq2) {
      var a2 = Math.exp(-undampedFreq2 * duration);
      var b2 = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a2 * b2;
    };
    derivative = function(undampedFreq2) {
      var a2 = Math.exp(-undampedFreq2 * duration);
      var b2 = (velocity - undampedFreq2) * (duration * duration);
      return a2 * b2;
    };
  }
  var initialGuess = 5 / duration;
  var undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = duration * 1e3;
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  } else {
    var stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
var rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  var result = initialGuess;
  for (var i = 1; i < rootIterations; i++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}

// ../../node_modules/popmotion/dist/es/animations/generators/spring.js
var durationKeys = ["duration", "bounce"];
var physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys2) {
  return keys2.some(function(key6) {
    return options[key6] !== void 0;
  });
}
function getSpringOptions(options) {
  var springOptions = __assign({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false }, options);
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    var derived = findSpring(options);
    springOptions = __assign(__assign(__assign({}, springOptions), derived), { velocity: 0, mass: 1 });
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
function spring(_a) {
  var _b = _a.from, from = _b === void 0 ? 0 : _b, _c = _a.to, to = _c === void 0 ? 1 : _c, _d = _a.restSpeed, restSpeed = _d === void 0 ? 2 : _d, restDelta = _a.restDelta, options = __rest(_a, ["from", "to", "restSpeed", "restDelta"]);
  var state = { done: false, value: from };
  var _e = getSpringOptions(options), stiffness = _e.stiffness, damping = _e.damping, mass = _e.mass, velocity = _e.velocity, duration = _e.duration, isResolvedFromDuration = _e.isResolvedFromDuration;
  var resolveSpring = zero;
  var resolveVelocity = zero;
  function createSpring() {
    var initialVelocity = velocity ? -(velocity / 1e3) : 0;
    var initialDelta = to - from;
    var dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    var undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;
    restDelta !== null && restDelta !== void 0 ? restDelta : restDelta = Math.abs(to - from) <= 1 ? 0.01 : 0.4;
    if (dampingRatio < 1) {
      var angularFreq_1 = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = function(t) {
        var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq_1 * Math.sin(angularFreq_1 * t) + initialDelta * Math.cos(angularFreq_1 * t));
      };
      resolveVelocity = function(t) {
        var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq_1 * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq_1 + initialDelta * Math.cos(angularFreq_1 * t)) - envelope * (Math.cos(angularFreq_1 * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq_1 * initialDelta * Math.sin(angularFreq_1 * t));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = function(t) {
        return to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
      };
    } else {
      var dampedAngularFreq_1 = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = function(t) {
        var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        var freqForT = Math.min(dampedAngularFreq_1 * t, 300);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq_1 * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq_1;
      };
    }
  }
  createSpring();
  return {
    next: function(t) {
      var current = resolveSpring(t);
      if (!isResolvedFromDuration) {
        var currentVelocity = resolveVelocity(t) * 1e3;
        var isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        var isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t >= duration;
      }
      state.value = state.done ? to : current;
      return state;
    },
    flipTarget: function() {
      var _a2;
      velocity = -velocity;
      _a2 = [to, from], from = _a2[0], to = _a2[1];
      createSpring();
    }
  };
}
spring.needsInterpolation = function(a2, b2) {
  return typeof a2 === "string" || typeof b2 === "string";
};
var zero = function(_t) {
  return 0;
};

// ../../node_modules/popmotion/dist/es/utils/progress.js
var progress = function(from, to, value) {
  var toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};

// ../../node_modules/popmotion/dist/es/utils/mix.js
var mix = function(from, to, progress2) {
  return -progress2 * from + progress2 * to + from;
};

// ../../node_modules/popmotion/dist/es/utils/mix-color.js
var mixLinearColor = function(from, to, v) {
  var fromExpo = from * from;
  var toExpo = to * to;
  return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));
};
var colorTypes = [hex, rgba, hsla];
var getColorType = function(v) {
  return colorTypes.find(function(type) {
    return type.test(v);
  });
};
var notAnimatable = function(color2) {
  return "'" + color2 + "' is not an animatable color. Use the equivalent color code instead.";
};
var mixColor = function(from, to) {
  var fromColorType = getColorType(from);
  var toColorType = getColorType(to);
  invariant(!!fromColorType, notAnimatable(from));
  invariant(!!toColorType, notAnimatable(to));
  invariant(fromColorType.transform === toColorType.transform, "Both colors must be hex/RGBA, OR both must be HSLA.");
  var fromColor = fromColorType.parse(from);
  var toColor = toColorType.parse(to);
  var blended = __assign({}, fromColor);
  var mixFunc = fromColorType === hsla ? mix : mixLinearColor;
  return function(v) {
    for (var key6 in blended) {
      if (key6 !== "alpha") {
        blended[key6] = mixFunc(fromColor[key6], toColor[key6], v);
      }
    }
    blended.alpha = mix(fromColor.alpha, toColor.alpha, v);
    return fromColorType.transform(blended);
  };
};

// ../../node_modules/popmotion/dist/es/utils/inc.js
var isNum = function(v) {
  return typeof v === "number";
};

// ../../node_modules/popmotion/dist/es/utils/pipe.js
var combineFunctions = function(a2, b2) {
  return function(v) {
    return b2(a2(v));
  };
};
var pipe = function() {
  var transformers = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    transformers[_i] = arguments[_i];
  }
  return transformers.reduce(combineFunctions);
};

// ../../node_modules/popmotion/dist/es/utils/mix-complex.js
function getMixer(origin, target) {
  if (isNum(origin)) {
    return function(v) {
      return mix(origin, target, v);
    };
  } else if (color.test(origin)) {
    return mixColor(origin, target);
  } else {
    return mixComplex(origin, target);
  }
}
var mixArray = function(from, to) {
  var output = __spreadArray([], from);
  var numValues = output.length;
  var blendValue = from.map(function(fromThis, i) {
    return getMixer(fromThis, to[i]);
  });
  return function(v) {
    for (var i = 0; i < numValues; i++) {
      output[i] = blendValue[i](v);
    }
    return output;
  };
};
var mixObject = function(origin, target) {
  var output = __assign(__assign({}, origin), target);
  var blendValue = {};
  for (var key6 in output) {
    if (origin[key6] !== void 0 && target[key6] !== void 0) {
      blendValue[key6] = getMixer(origin[key6], target[key6]);
    }
  }
  return function(v) {
    for (var key7 in blendValue) {
      output[key7] = blendValue[key7](v);
    }
    return output;
  };
};
function analyse2(value) {
  var parsed = complex.parse(value);
  var numValues = parsed.length;
  var numNumbers = 0;
  var numRGB = 0;
  var numHSL = 0;
  for (var i = 0; i < numValues; i++) {
    if (numNumbers || typeof parsed[i] === "number") {
      numNumbers++;
    } else {
      if (parsed[i].hue !== void 0) {
        numHSL++;
      } else {
        numRGB++;
      }
    }
  }
  return { parsed, numNumbers, numRGB, numHSL };
}
var mixComplex = function(origin, target) {
  var template = complex.createTransformer(target);
  var originStats = analyse2(origin);
  var targetStats = analyse2(target);
  invariant(originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers, "Complex values '" + origin + "' and '" + target + "' too different to mix. Ensure all colors are of the same type.");
  return pipe(mixArray(originStats.parsed, targetStats.parsed), template);
};

// ../../node_modules/popmotion/dist/es/utils/interpolate.js
var mixNumber = function(from, to) {
  return function(p) {
    return mix(from, to, p);
  };
};
function detectMixerFactory(v) {
  if (typeof v === "number") {
    return mixNumber;
  } else if (typeof v === "string") {
    if (color.test(v)) {
      return mixColor;
    } else {
      return mixComplex;
    }
  } else if (Array.isArray(v)) {
    return mixArray;
  } else if (typeof v === "object") {
    return mixObject;
  }
}
function createMixers(output, ease, customMixer) {
  var mixers = [];
  var mixerFactory = customMixer || detectMixerFactory(output[0]);
  var numMixers = output.length - 1;
  for (var i = 0; i < numMixers; i++) {
    var mixer = mixerFactory(output[i], output[i + 1]);
    if (ease) {
      var easingFunction = Array.isArray(ease) ? ease[i] : ease;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function fastInterpolate(_a, _b) {
  var from = _a[0], to = _a[1];
  var mixer = _b[0];
  return function(v) {
    return mixer(progress(from, to, v));
  };
}
function slowInterpolate(input, mixers) {
  var inputLength = input.length;
  var lastInputIndex = inputLength - 1;
  return function(v) {
    var mixerIndex = 0;
    var foundMixerIndex = false;
    if (v <= input[0]) {
      foundMixerIndex = true;
    } else if (v >= input[lastInputIndex]) {
      mixerIndex = lastInputIndex - 1;
      foundMixerIndex = true;
    }
    if (!foundMixerIndex) {
      var i = 1;
      for (; i < inputLength; i++) {
        if (input[i] > v || i === lastInputIndex) {
          break;
        }
      }
      mixerIndex = i - 1;
    }
    var progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);
    return mixers[mixerIndex](progressInRange);
  };
}
function interpolate(input, output, _a) {
  var _b = _a === void 0 ? {} : _a, _c = _b.clamp, isClamp = _c === void 0 ? true : _c, ease = _b.ease, mixer = _b.mixer;
  var inputLength = input.length;
  invariant(inputLength === output.length, "Both input and output ranges must be the same length");
  invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, "Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.");
  if (input[0] > input[inputLength - 1]) {
    input = [].concat(input);
    output = [].concat(output);
    input.reverse();
    output.reverse();
  }
  var mixers = createMixers(output, ease, mixer);
  var interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);
  return isClamp ? function(v) {
    return interpolator(clamp2(input[0], input[inputLength - 1], v));
  } : interpolator;
}

// ../../node_modules/popmotion/dist/es/easing/utils.js
var reverseEasing = function(easing) {
  return function(p) {
    return 1 - easing(1 - p);
  };
};
var mirrorEasing = function(easing) {
  return function(p) {
    return p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
  };
};
var createExpoIn = function(power) {
  return function(p) {
    return Math.pow(p, power);
  };
};
var createBackIn = function(power) {
  return function(p) {
    return p * p * ((power + 1) * p - power);
  };
};
var createAnticipate = function(power) {
  var backEasing = createBackIn(power);
  return function(p) {
    return (p *= 2) < 1 ? 0.5 * backEasing(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
  };
};

// ../../node_modules/popmotion/dist/es/easing/index.js
var DEFAULT_OVERSHOOT_STRENGTH = 1.525;
var BOUNCE_FIRST_THRESHOLD = 4 / 11;
var BOUNCE_SECOND_THRESHOLD = 8 / 11;
var BOUNCE_THIRD_THRESHOLD = 9 / 10;
var linear = function(p) {
  return p;
};
var easeIn = createExpoIn(2);
var easeOut = reverseEasing(easeIn);
var easeInOut = mirrorEasing(easeIn);
var circIn = function(p) {
  return 1 - Math.sin(Math.acos(p));
};
var circOut = reverseEasing(circIn);
var circInOut = mirrorEasing(circOut);
var backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);
var backOut = reverseEasing(backIn);
var backInOut = mirrorEasing(backIn);
var anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);
var ca = 4356 / 361;
var cb = 35442 / 1805;
var cc = 16061 / 1805;
var bounceOut = function(p) {
  if (p === 1 || p === 0)
    return p;
  var p2 = p * p;
  return p < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p2 : p < BOUNCE_SECOND_THRESHOLD ? 9.075 * p2 - 9.9 * p + 3.4 : p < BOUNCE_THIRD_THRESHOLD ? ca * p2 - cb * p + cc : 10.8 * p * p - 20.52 * p + 10.72;
};
var bounceIn = reverseEasing(bounceOut);
var bounceInOut = function(p) {
  return p < 0.5 ? 0.5 * (1 - bounceOut(1 - p * 2)) : 0.5 * bounceOut(p * 2 - 1) + 0.5;
};

// ../../node_modules/popmotion/dist/es/animations/generators/keyframes.js
function defaultEasing(values, easing) {
  return values.map(function() {
    return easing || easeInOut;
  }).splice(0, values.length - 1);
}
function defaultOffset(values) {
  var numValues = values.length;
  return values.map(function(_value, i) {
    return i !== 0 ? i / (numValues - 1) : 0;
  });
}
function convertOffsetToTimes(offset, duration) {
  return offset.map(function(o) {
    return o * duration;
  });
}
function keyframes(_a) {
  var _b = _a.from, from = _b === void 0 ? 0 : _b, _c = _a.to, to = _c === void 0 ? 1 : _c, ease = _a.ease, offset = _a.offset, _d = _a.duration, duration = _d === void 0 ? 300 : _d;
  var state = { done: false, value: from };
  var values = Array.isArray(to) ? to : [from, to];
  var times = convertOffsetToTimes(offset && offset.length === values.length ? offset : defaultOffset(values), duration);
  function createInterpolator() {
    return interpolate(times, values, {
      ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)
    });
  }
  var interpolator = createInterpolator();
  return {
    next: function(t) {
      state.value = interpolator(t);
      state.done = t >= duration;
      return state;
    },
    flipTarget: function() {
      values.reverse();
      interpolator = createInterpolator();
    }
  };
}

// ../../node_modules/popmotion/dist/es/animations/generators/decay.js
function decay(_a) {
  var _b = _a.velocity, velocity = _b === void 0 ? 0 : _b, _c = _a.from, from = _c === void 0 ? 0 : _c, _d = _a.power, power = _d === void 0 ? 0.8 : _d, _e = _a.timeConstant, timeConstant2 = _e === void 0 ? 350 : _e, _f = _a.restDelta, restDelta = _f === void 0 ? 0.5 : _f, modifyTarget = _a.modifyTarget;
  var state = { done: false, value: from };
  var amplitude = power * velocity;
  var ideal = from + amplitude;
  var target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - from;
  return {
    next: function(t) {
      var delta2 = -amplitude * Math.exp(-t / timeConstant2);
      state.done = !(delta2 > restDelta || delta2 < -restDelta);
      state.value = state.done ? target : target + delta2;
      return state;
    },
    flipTarget: function() {
    }
  };
}

// ../../node_modules/popmotion/dist/es/animations/utils/detect-animation-from-options.js
var types = { keyframes, spring, decay };
function detectAnimationFromOptions(config) {
  if (Array.isArray(config.to)) {
    return keyframes;
  } else if (types[config.type]) {
    return types[config.type];
  }
  var keys2 = new Set(Object.keys(config));
  if (keys2.has("ease") || keys2.has("duration") && !keys2.has("dampingRatio")) {
    return keyframes;
  } else if (keys2.has("dampingRatio") || keys2.has("stiffness") || keys2.has("mass") || keys2.has("damping") || keys2.has("restSpeed") || keys2.has("restDelta")) {
    return spring;
  }
  return keyframes;
}

// ../../node_modules/framesync/dist/es/on-next-frame.js
var defaultTimestep = 1 / 60 * 1e3;
var getCurrentTime = typeof performance !== "undefined" ? function() {
  return performance.now();
} : function() {
  return Date.now();
};
var onNextFrame = typeof window !== "undefined" ? function(callback) {
  return window.requestAnimationFrame(callback);
} : function(callback) {
  return setTimeout(function() {
    return callback(getCurrentTime());
  }, defaultTimestep);
};

// ../../node_modules/framesync/dist/es/create-render-step.js
function createRenderStep(runNextFrame2) {
  var toRun = [];
  var toRunNextFrame = [];
  var numToRun = 0;
  var isProcessing2 = false;
  var toKeepAlive = new WeakSet();
  var step = {
    schedule: function(callback, keepAlive, immediate) {
      if (keepAlive === void 0) {
        keepAlive = false;
      }
      if (immediate === void 0) {
        immediate = false;
      }
      var addToCurrentFrame = immediate && isProcessing2;
      var buffer = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (buffer.indexOf(callback) === -1) {
        buffer.push(callback);
        if (addToCurrentFrame && isProcessing2)
          numToRun = toRun.length;
      }
      return callback;
    },
    cancel: function(callback) {
      var index = toRunNextFrame.indexOf(callback);
      if (index !== -1)
        toRunNextFrame.splice(index, 1);
      toKeepAlive.delete(callback);
    },
    process: function(frameData) {
      var _a;
      isProcessing2 = true;
      _a = [toRunNextFrame, toRun], toRun = _a[0], toRunNextFrame = _a[1];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (var i = 0; i < numToRun; i++) {
          var callback = toRun[i];
          callback(frameData);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame2();
          }
        }
      }
      isProcessing2 = false;
    }
  };
  return step;
}

// ../../node_modules/framesync/dist/es/index.js
var maxElapsed = 40;
var useDefaultElapsed = true;
var runNextFrame = false;
var isProcessing = false;
var frame = {
  delta: 0,
  timestamp: 0
};
var stepsOrder = ["read", "update", "preRender", "render", "postRender"];
var steps = /* @__PURE__ */ stepsOrder.reduce(function(acc, key6) {
  acc[key6] = createRenderStep(function() {
    return runNextFrame = true;
  });
  return acc;
}, {});
var sync = /* @__PURE__ */ stepsOrder.reduce(function(acc, key6) {
  var step = steps[key6];
  acc[key6] = function(process3, keepAlive, immediate) {
    if (keepAlive === void 0) {
      keepAlive = false;
    }
    if (immediate === void 0) {
      immediate = false;
    }
    if (!runNextFrame)
      startLoop();
    return step.schedule(process3, keepAlive, immediate);
  };
  return acc;
}, {});
var cancelSync = /* @__PURE__ */ stepsOrder.reduce(function(acc, key6) {
  acc[key6] = steps[key6].cancel;
  return acc;
}, {});
var flushSync = /* @__PURE__ */ stepsOrder.reduce(function(acc, key6) {
  acc[key6] = function() {
    return steps[key6].process(frame);
  };
  return acc;
}, {});
var processStep = function(stepId) {
  return steps[stepId].process(frame);
};
var processFrame = function(timestamp) {
  runNextFrame = false;
  frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
  frame.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;
  if (runNextFrame) {
    useDefaultElapsed = false;
    onNextFrame(processFrame);
  }
};
var startLoop = function() {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing)
    onNextFrame(processFrame);
};
var getFrameData = function() {
  return frame;
};
var es_default = sync;

// ../../node_modules/popmotion/dist/es/animations/utils/elapsed.js
function loopElapsed(elapsed, duration, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return elapsed - duration - delay;
}
function reverseElapsed(elapsed, duration, delay, isForwardPlayback) {
  if (delay === void 0) {
    delay = 0;
  }
  if (isForwardPlayback === void 0) {
    isForwardPlayback = true;
  }
  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay) : duration - (elapsed - duration) + delay;
}
function hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {
  return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;
}

// ../../node_modules/popmotion/dist/es/animations/index.js
var framesync = function(update) {
  var passTimestamp = function(_a) {
    var delta2 = _a.delta;
    return update(delta2);
  };
  return {
    start: function() {
      return es_default.update(passTimestamp, true);
    },
    stop: function() {
      return cancelSync.update(passTimestamp);
    }
  };
};
function animate(_a) {
  var _b, _c;
  var from = _a.from, _d = _a.autoplay, autoplay = _d === void 0 ? true : _d, _e = _a.driver, driver = _e === void 0 ? framesync : _e, _f = _a.elapsed, elapsed = _f === void 0 ? 0 : _f, _g = _a.repeat, repeatMax = _g === void 0 ? 0 : _g, _h = _a.repeatType, repeatType = _h === void 0 ? "loop" : _h, _j = _a.repeatDelay, repeatDelay = _j === void 0 ? 0 : _j, onPlay = _a.onPlay, onStop = _a.onStop, onComplete = _a.onComplete, onRepeat = _a.onRepeat, onUpdate = _a.onUpdate, options = __rest(_a, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]);
  var to = options.to;
  var driverControls;
  var repeatCount = 0;
  var computedDuration = options.duration;
  var latest;
  var isComplete = false;
  var isForwardPlayback = true;
  var interpolateFromNumber;
  var animator = detectAnimationFromOptions(options);
  if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {
    interpolateFromNumber = interpolate([0, 100], [from, to], {
      clamp: false
    });
    from = 0;
    to = 100;
  }
  var animation = animator(__assign(__assign({}, options), { from, to }));
  function repeat() {
    repeatCount++;
    if (repeatType === "reverse") {
      isForwardPlayback = repeatCount % 2 === 0;
      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);
    } else {
      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);
      if (repeatType === "mirror")
        animation.flipTarget();
    }
    isComplete = false;
    onRepeat && onRepeat();
  }
  function complete() {
    driverControls.stop();
    onComplete && onComplete();
  }
  function update(delta2) {
    if (!isForwardPlayback)
      delta2 = -delta2;
    elapsed += delta2;
    if (!isComplete) {
      var state = animation.next(Math.max(0, elapsed));
      latest = state.value;
      if (interpolateFromNumber)
        latest = interpolateFromNumber(latest);
      isComplete = isForwardPlayback ? state.done : elapsed <= 0;
    }
    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);
    if (isComplete) {
      if (repeatCount === 0)
        computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;
      if (repeatCount < repeatMax) {
        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();
      } else {
        complete();
      }
    }
  }
  function play() {
    onPlay === null || onPlay === void 0 ? void 0 : onPlay();
    driverControls = driver(update);
    driverControls.start();
  }
  autoplay && play();
  return {
    stop: function() {
      onStop === null || onStop === void 0 ? void 0 : onStop();
      driverControls.stop();
    }
  };
}

// ../../node_modules/popmotion/dist/es/utils/velocity-per-second.js
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}

// ../../node_modules/popmotion/dist/es/animations/inertia.js
function inertia(_a) {
  var _b = _a.from, from = _b === void 0 ? 0 : _b, _c = _a.velocity, velocity = _c === void 0 ? 0 : _c, min = _a.min, max = _a.max, _d = _a.power, power = _d === void 0 ? 0.8 : _d, _e = _a.timeConstant, timeConstant2 = _e === void 0 ? 750 : _e, _f = _a.bounceStiffness, bounceStiffness = _f === void 0 ? 500 : _f, _g = _a.bounceDamping, bounceDamping = _g === void 0 ? 10 : _g, _h = _a.restDelta, restDelta = _h === void 0 ? 1 : _h, modifyTarget = _a.modifyTarget, driver = _a.driver, onUpdate = _a.onUpdate, onComplete = _a.onComplete, onStop = _a.onStop;
  var currentAnimation;
  function isOutOfBounds(v) {
    return min !== void 0 && v < min || max !== void 0 && v > max;
  }
  function boundaryNearest(v) {
    if (min === void 0)
      return max;
    if (max === void 0)
      return min;
    return Math.abs(min - v) < Math.abs(max - v) ? min : max;
  }
  function startAnimation3(options) {
    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();
    currentAnimation = animate(__assign(__assign({}, options), {
      driver,
      onUpdate: function(v) {
        var _a2;
        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);
        (_a2 = options.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(options, v);
      },
      onComplete,
      onStop
    }));
  }
  function startSpring(options) {
    startAnimation3(__assign({ type: "spring", stiffness: bounceStiffness, damping: bounceDamping, restDelta }, options));
  }
  if (isOutOfBounds(from)) {
    startSpring({ from, velocity, to: boundaryNearest(from) });
  } else {
    var target = power * velocity + from;
    if (typeof modifyTarget !== "undefined")
      target = modifyTarget(target);
    var boundary_1 = boundaryNearest(target);
    var heading_1 = boundary_1 === min ? -1 : 1;
    var prev_1;
    var current_1;
    var checkBoundary = function(v) {
      prev_1 = current_1;
      current_1 = v;
      velocity = velocityPerSecond(v - prev_1, getFrameData().delta);
      if (heading_1 === 1 && v > boundary_1 || heading_1 === -1 && v < boundary_1) {
        startSpring({ from: v, to: boundary_1, velocity });
      }
    };
    startAnimation3({
      type: "decay",
      from,
      velocity,
      timeConstant: timeConstant2,
      power,
      restDelta,
      modifyTarget,
      onUpdate: isOutOfBounds(target) ? checkBoundary : void 0
    });
  }
  return {
    stop: function() {
      return currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();
    }
  };
}

// ../../node_modules/popmotion/dist/es/utils/is-point.js
var isPoint = function(point) {
  return point.hasOwnProperty("x") && point.hasOwnProperty("y");
};

// ../../node_modules/popmotion/dist/es/utils/is-point-3d.js
var isPoint3D = function(point) {
  return isPoint(point) && point.hasOwnProperty("z");
};

// ../../node_modules/popmotion/dist/es/utils/distance.js
var distance1D = function(a2, b2) {
  return Math.abs(a2 - b2);
};
function distance(a2, b2) {
  if (isNum(a2) && isNum(b2)) {
    return distance1D(a2, b2);
  } else if (isPoint(a2) && isPoint(b2)) {
    var xDelta = distance1D(a2.x, b2.x);
    var yDelta = distance1D(a2.y, b2.y);
    var zDelta = isPoint3D(a2) && isPoint3D(b2) ? distance1D(a2.z, b2.z) : 0;
    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));
  }
}

// ../../node_modules/popmotion/dist/es/utils/wrap.js
var wrap = function(min, max, v) {
  var rangeSize = max - min;
  return ((v - min) % rangeSize + rangeSize) % rangeSize + min;
};

// ../../node_modules/popmotion/dist/es/easing/cubic-bezier.js
var a = function(a1, a2) {
  return 1 - 3 * a2 + 3 * a1;
};
var b = function(a1, a2) {
  return 3 * a2 - 6 * a1;
};
var c = function(a1) {
  return 3 * a1;
};
var calcBezier = function(t, a1, a2) {
  return ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;
};
var getSlope = function(t, a1, a2) {
  return 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);
};
var subdivisionPrecision = 1e-7;
var subdivisionMaxIterations = 10;
function binarySubdivide(aX, aA, aB, mX1, mX2) {
  var currentX;
  var currentT;
  var i = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
  return currentT;
}
var newtonIterations = 8;
var newtonMinSlope = 1e-3;
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
  for (var i = 0; i < newtonIterations; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0) {
      return aGuessT;
    }
    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
}
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return linear;
  var sampleValues = new Float32Array(kSplineTableSize);
  for (var i = 0; i < kSplineTableSize; ++i) {
    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
  }
  function getTForX(aX) {
    var intervalStart = 0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;
    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    var guessForT = intervalStart + dist * kSampleStepSize;
    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= newtonMinSlope) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }
  return function(t) {
    return t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
  };
}

// ../../node_modules/framer-motion/dist/es/gestures/use-tap-gesture.js
function useTapGesture(_a) {
  var onTap = _a.onTap, onTapStart = _a.onTapStart, onTapCancel = _a.onTapCancel, whileTap = _a.whileTap, visualElement2 = _a.visualElement;
  var hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;
  var isPressing = useRef3(false);
  var cancelPointerEndListeners = useRef3(null);
  function removePointerEndListener() {
    var _a2;
    (_a2 = cancelPointerEndListeners.current) === null || _a2 === void 0 ? void 0 : _a2.call(cancelPointerEndListeners);
    cancelPointerEndListeners.current = null;
  }
  function checkPointerEnd() {
    var _a2;
    removePointerEndListener();
    isPressing.current = false;
    (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Tap, false);
    return !isDragActive();
  }
  function onPointerUp(event, info) {
    if (!checkPointerEnd())
      return;
    !isNodeOrChild(visualElement2.getInstance(), event.target) ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info) : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);
  }
  function onPointerCancel(event, info) {
    if (!checkPointerEnd())
      return;
    onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);
  }
  function onPointerDown(event, info) {
    var _a2;
    removePointerEndListener();
    if (isPressing.current)
      return;
    isPressing.current = true;
    cancelPointerEndListeners.current = pipe(addPointerEvent(window, "pointerup", onPointerUp), addPointerEvent(window, "pointercancel", onPointerCancel));
    onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);
    (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Tap, true);
  }
  usePointerEvent(visualElement2, "pointerdown", hasPressListeners ? onPointerDown : void 0);
  useUnmountEffect(removePointerEndListener);
}

// ../../node_modules/framer-motion/dist/es/motion/utils/make-renderless-component.js
var makeRenderlessComponent = function(hook) {
  return function(props) {
    hook(props);
    return null;
  };
};

// ../../node_modules/framer-motion/dist/es/motion/features/gestures.js
var gestureAnimations = {
  tap: makeRenderlessComponent(useTapGesture),
  focus: makeRenderlessComponent(useFocusGesture),
  hover: makeRenderlessComponent(useHoverGesture)
};

// ../../node_modules/framer-motion/dist/es/motion/features/animations.js
import { useEffect as useEffect6, useContext as useContext8 } from "react";

// ../../node_modules/framer-motion/dist/es/utils/shallow-compare.js
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return false;
  var prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (var i = 0; i < prevLength; i++) {
    if (prev[i] !== next[i])
      return false;
  }
  return true;
}

// ../../node_modules/framer-motion/dist/es/utils/time-conversion.js
var secondsToMilliseconds = function(seconds) {
  return seconds * 1e3;
};

// ../../node_modules/framer-motion/dist/es/animation/utils/easing.js
var easingLookup = {
  linear,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate,
  bounceIn,
  bounceInOut,
  bounceOut
};
var easingDefinitionToFunction = function(definition) {
  if (Array.isArray(definition)) {
    invariant(definition.length === 4, "Cubic bezier arrays must contain four numerical values.");
    var _a = __read(definition, 4), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    invariant(easingLookup[definition] !== void 0, "Invalid easing type '" + definition + "'");
    return easingLookup[definition];
  }
  return definition;
};
var isEasingArray = function(ease) {
  return Array.isArray(ease) && typeof ease[0] !== "number";
};

// ../../node_modules/framer-motion/dist/es/animation/utils/is-animatable.js
var isAnimatable = function(key6, value) {
  if (key6 === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && complex.test(value) && !value.startsWith("url(")) {
    return true;
  }
  return false;
};

// ../../node_modules/framer-motion/dist/es/animation/utils/default-transitions.js
var underDampedSpring = function() {
  return {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restDelta: 0.5,
    restSpeed: 10
  };
};
var criticallyDampedSpring = function(to) {
  return {
    type: "spring",
    stiffness: 550,
    damping: to === 0 ? 2 * Math.sqrt(550) : 30,
    restDelta: 0.01,
    restSpeed: 10
  };
};
var linearTween = function() {
  return {
    type: "keyframes",
    ease: "linear",
    duration: 0.3
  };
};
var keyframes2 = function(values) {
  return {
    type: "keyframes",
    duration: 0.8,
    values
  };
};
var defaultTransitions = {
  x: underDampedSpring,
  y: underDampedSpring,
  z: underDampedSpring,
  rotate: underDampedSpring,
  rotateX: underDampedSpring,
  rotateY: underDampedSpring,
  rotateZ: underDampedSpring,
  scaleX: criticallyDampedSpring,
  scaleY: criticallyDampedSpring,
  scale: criticallyDampedSpring,
  opacity: linearTween,
  backgroundColor: linearTween,
  color: linearTween,
  default: criticallyDampedSpring
};
var getDefaultTransition = function(valueKey, to) {
  var transitionFactory;
  if (isKeyframesTarget(to)) {
    transitionFactory = keyframes2;
  } else {
    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;
  }
  return __assign({ to }, transitionFactory(to));
};

// ../../node_modules/framer-motion/dist/es/render/dom/value-types/defaults.js
var defaultValueTypes = __assign(__assign({}, numberValueTypes), {
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
});
var getDefaultValueType = function(key6) {
  return defaultValueTypes[key6];
};

// ../../node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.js
function getAnimatableNone2(key6, value) {
  var _a;
  var defaultValueType = getDefaultValueType(key6);
  if (defaultValueType !== filter)
    defaultValueType = complex;
  return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);
}

// ../../node_modules/framer-motion/dist/es/animation/utils/transitions.js
function isTransitionDefined(_a) {
  _a.when;
  _a.delay;
  _a.delayChildren;
  _a.staggerChildren;
  _a.staggerDirection;
  _a.repeat;
  _a.repeatType;
  _a.repeatDelay;
  _a.from;
  var transition = __rest(_a, ["when", "delay", "delayChildren", "staggerChildren", "staggerDirection", "repeat", "repeatType", "repeatDelay", "from"]);
  return !!Object.keys(transition).length;
}
var legacyRepeatWarning = false;
function convertTransitionToAnimationOptions(_a) {
  var ease = _a.ease, times = _a.times, yoyo = _a.yoyo, flip = _a.flip, loop = _a.loop, transition = __rest(_a, ["ease", "times", "yoyo", "flip", "loop"]);
  var options = __assign({}, transition);
  if (times)
    options["offset"] = times;
  if (transition.duration)
    options["duration"] = secondsToMilliseconds(transition.duration);
  if (transition.repeatDelay)
    options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);
  if (ease) {
    options["ease"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);
  }
  if (transition.type === "tween")
    options.type = "keyframes";
  if (yoyo || loop || flip) {
    warning(!legacyRepeatWarning, "yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.");
    legacyRepeatWarning = true;
    if (yoyo) {
      options.repeatType = "reverse";
    } else if (loop) {
      options.repeatType = "loop";
    } else if (flip) {
      options.repeatType = "mirror";
    }
    options.repeat = loop || yoyo || flip || transition.repeat;
  }
  if (transition.type !== "spring")
    options.type = "keyframes";
  return options;
}
function getDelayFromTransition(transition, key6) {
  var _a;
  var valueTransition = getValueTransition(transition, key6) || {};
  return (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : 0;
}
function hydrateKeyframes(options) {
  if (Array.isArray(options.to) && options.to[0] === null) {
    options.to = __spreadArray([], __read(options.to));
    options.to[0] = options.from;
  }
  return options;
}
function getPopmotionAnimationOptions(transition, options, key6) {
  var _a;
  if (Array.isArray(options.to)) {
    (_a = transition.duration) !== null && _a !== void 0 ? _a : transition.duration = 0.8;
  }
  hydrateKeyframes(options);
  if (!isTransitionDefined(transition)) {
    transition = __assign(__assign({}, transition), getDefaultTransition(key6, options.to));
  }
  return __assign(__assign({}, options), convertTransitionToAnimationOptions(transition));
}
function getAnimation(key6, value, target, transition, onComplete) {
  var _a;
  var valueTransition = getValueTransition(transition, key6);
  var origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();
  var isTargetAnimatable = isAnimatable(key6, target);
  if (origin === "none" && isTargetAnimatable && typeof target === "string") {
    origin = getAnimatableNone2(key6, target);
  } else if (isZero(origin) && typeof target === "string") {
    origin = getZeroUnit(target);
  } else if (!Array.isArray(target) && isZero(target) && typeof origin === "string") {
    target = getZeroUnit(origin);
  }
  var isOriginAnimatable = isAnimatable(key6, origin);
  warning(isOriginAnimatable === isTargetAnimatable, "You are trying to animate " + key6 + ' from "' + origin + '" to "' + target + '". ' + origin + " is not an animatable value - to enable this animation set " + origin + " to a value animatable to " + target + " via the `style` property.");
  function start() {
    var options = {
      from: origin,
      to: target,
      velocity: value.getVelocity(),
      onComplete,
      onUpdate: function(v) {
        return value.set(v);
      }
    };
    return valueTransition.type === "inertia" || valueTransition.type === "decay" ? inertia(__assign(__assign({}, options), valueTransition)) : animate(__assign(__assign({}, getPopmotionAnimationOptions(valueTransition, options, key6)), { onUpdate: function(v) {
      var _a2;
      options.onUpdate(v);
      (_a2 = valueTransition.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(valueTransition, v);
    }, onComplete: function() {
      var _a2;
      options.onComplete();
      (_a2 = valueTransition.onComplete) === null || _a2 === void 0 ? void 0 : _a2.call(valueTransition);
    } }));
  }
  function set() {
    var _a2;
    value.set(target);
    onComplete();
    (_a2 = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _a2 === void 0 ? void 0 : _a2.call(valueTransition);
    return { stop: function() {
    } };
  }
  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start;
}
function isZero(value) {
  return value === 0 || typeof value === "string" && parseFloat(value) === 0 && value.indexOf(" ") === -1;
}
function getZeroUnit(potentialUnitType) {
  return typeof potentialUnitType === "number" ? 0 : getAnimatableNone2("", potentialUnitType);
}
function getValueTransition(transition, key6) {
  return transition[key6] || transition["default"] || transition;
}
function startAnimation(key6, value, target, transition) {
  if (transition === void 0) {
    transition = {};
  }
  return value.start(function(onComplete) {
    var delayTimer;
    var controls;
    var animation = getAnimation(key6, value, target, transition, onComplete);
    var delay = getDelayFromTransition(transition, key6);
    var start = function() {
      return controls = animation();
    };
    if (delay) {
      delayTimer = setTimeout(start, secondsToMilliseconds(delay));
    } else {
      start();
    }
    return function() {
      clearTimeout(delayTimer);
      controls === null || controls === void 0 ? void 0 : controls.stop();
    };
  });
}

// ../../node_modules/framer-motion/dist/es/utils/is-numerical-string.js
var isNumericalString = function(v) {
  return /^\-?\d*\.?\d+$/.test(v);
};

// ../../node_modules/framer-motion/dist/es/utils/array.js
function addUniqueItem(arr, item) {
  arr.indexOf(item) === -1 && arr.push(item);
}
function removeItem(arr, item) {
  var index = arr.indexOf(item);
  index > -1 && arr.splice(index, 1);
}

// ../../node_modules/framer-motion/dist/es/utils/subscription-manager.js
var SubscriptionManager = function() {
  function SubscriptionManager2() {
    this.subscriptions = [];
  }
  SubscriptionManager2.prototype.add = function(handler) {
    var _this = this;
    addUniqueItem(this.subscriptions, handler);
    return function() {
      return removeItem(_this.subscriptions, handler);
    };
  };
  SubscriptionManager2.prototype.notify = function(a2, b2, c2) {
    var numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a2, b2, c2);
    } else {
      for (var i = 0; i < numSubscriptions; i++) {
        var handler = this.subscriptions[i];
        handler && handler(a2, b2, c2);
      }
    }
  };
  SubscriptionManager2.prototype.getSize = function() {
    return this.subscriptions.length;
  };
  SubscriptionManager2.prototype.clear = function() {
    this.subscriptions.length = 0;
  };
  return SubscriptionManager2;
}();

// ../../node_modules/framer-motion/dist/es/value/index.js
var isFloat = function(value) {
  return !isNaN(parseFloat(value));
};
var MotionValue = function() {
  function MotionValue10(init) {
    var _this = this;
    this.timeDelta = 0;
    this.lastUpdated = 0;
    this.updateSubscribers = new SubscriptionManager();
    this.velocityUpdateSubscribers = new SubscriptionManager();
    this.renderSubscribers = new SubscriptionManager();
    this.canTrackVelocity = false;
    this.updateAndNotify = function(v, render) {
      if (render === void 0) {
        render = true;
      }
      _this.prev = _this.current;
      _this.current = v;
      var _a = getFrameData(), delta2 = _a.delta, timestamp = _a.timestamp;
      if (_this.lastUpdated !== timestamp) {
        _this.timeDelta = delta2;
        _this.lastUpdated = timestamp;
        es_default.postRender(_this.scheduleVelocityCheck);
      }
      if (_this.prev !== _this.current) {
        _this.updateSubscribers.notify(_this.current);
      }
      if (_this.velocityUpdateSubscribers.getSize()) {
        _this.velocityUpdateSubscribers.notify(_this.getVelocity());
      }
      if (render) {
        _this.renderSubscribers.notify(_this.current);
      }
    };
    this.scheduleVelocityCheck = function() {
      return es_default.postRender(_this.velocityCheck);
    };
    this.velocityCheck = function(_a) {
      var timestamp = _a.timestamp;
      if (timestamp !== _this.lastUpdated) {
        _this.prev = _this.current;
        _this.velocityUpdateSubscribers.notify(_this.getVelocity());
      }
    };
    this.hasAnimated = false;
    this.prev = this.current = init;
    this.canTrackVelocity = isFloat(this.current);
  }
  MotionValue10.prototype.onChange = function(subscription) {
    return this.updateSubscribers.add(subscription);
  };
  MotionValue10.prototype.clearListeners = function() {
    this.updateSubscribers.clear();
  };
  MotionValue10.prototype.onRenderRequest = function(subscription) {
    subscription(this.get());
    return this.renderSubscribers.add(subscription);
  };
  MotionValue10.prototype.attach = function(passiveEffect) {
    this.passiveEffect = passiveEffect;
  };
  MotionValue10.prototype.set = function(v, render) {
    if (render === void 0) {
      render = true;
    }
    if (!render || !this.passiveEffect) {
      this.updateAndNotify(v, render);
    } else {
      this.passiveEffect(v, this.updateAndNotify);
    }
  };
  MotionValue10.prototype.get = function() {
    return this.current;
  };
  MotionValue10.prototype.getPrevious = function() {
    return this.prev;
  };
  MotionValue10.prototype.getVelocity = function() {
    return this.canTrackVelocity ? velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;
  };
  MotionValue10.prototype.start = function(animation) {
    var _this = this;
    this.stop();
    return new Promise(function(resolve) {
      _this.hasAnimated = true;
      _this.stopAnimation = animation(resolve);
    }).then(function() {
      return _this.clearAnimation();
    });
  };
  MotionValue10.prototype.stop = function() {
    if (this.stopAnimation)
      this.stopAnimation();
    this.clearAnimation();
  };
  MotionValue10.prototype.isAnimating = function() {
    return !!this.stopAnimation;
  };
  MotionValue10.prototype.clearAnimation = function() {
    this.stopAnimation = null;
  };
  MotionValue10.prototype.destroy = function() {
    this.updateSubscribers.clear();
    this.renderSubscribers.clear();
    this.stop();
  };
  return MotionValue10;
}();
function motionValue(init) {
  return new MotionValue(init);
}

// ../../node_modules/framer-motion/dist/es/render/dom/value-types/test.js
var testValueType = function(v) {
  return function(type) {
    return type.test(v);
  };
};

// ../../node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.js
var auto = {
  test: function(v) {
    return v === "auto";
  },
  parse: function(v) {
    return v;
  }
};

// ../../node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.js
var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
var findDimensionValueType = function(v) {
  return dimensionValueTypes.find(testValueType(v));
};

// ../../node_modules/framer-motion/dist/es/render/dom/value-types/find.js
var valueTypes = __spreadArray(__spreadArray([], __read(dimensionValueTypes)), [color, complex]);
var findValueType = function(v) {
  return valueTypes.find(testValueType(v));
};

// ../../node_modules/framer-motion/dist/es/render/utils/setters.js
function setMotionValue(visualElement2, key6, value) {
  if (visualElement2.hasValue(key6)) {
    visualElement2.getValue(key6).set(value);
  } else {
    visualElement2.addValue(key6, motionValue(value));
  }
}
function setTarget(visualElement2, definition) {
  var resolved = resolveVariant(visualElement2, definition);
  var _a = resolved ? visualElement2.makeTargetAnimatable(resolved, false) : {}, _b = _a.transitionEnd, transitionEnd = _b === void 0 ? {} : _b;
  _a.transition;
  var target = __rest(_a, ["transitionEnd", "transition"]);
  target = __assign(__assign({}, target), transitionEnd);
  for (var key6 in target) {
    var value = resolveFinalValueInKeyframes(target[key6]);
    setMotionValue(visualElement2, key6, value);
  }
}
function setVariants(visualElement2, variantLabels) {
  var reversedLabels = __spreadArray([], __read(variantLabels)).reverse();
  reversedLabels.forEach(function(key6) {
    var _a;
    var variant = visualElement2.getVariant(key6);
    variant && setTarget(visualElement2, variant);
    (_a = visualElement2.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function(child) {
      setVariants(child, variantLabels);
    });
  });
}
function setValues(visualElement2, definition) {
  if (Array.isArray(definition)) {
    return setVariants(visualElement2, definition);
  } else if (typeof definition === "string") {
    return setVariants(visualElement2, [definition]);
  } else {
    setTarget(visualElement2, definition);
  }
}
function checkTargetForNewValues(visualElement2, target, origin) {
  var _a, _b, _c;
  var _d;
  var newValueKeys = Object.keys(target).filter(function(key7) {
    return !visualElement2.hasValue(key7);
  });
  var numNewValues = newValueKeys.length;
  if (!numNewValues)
    return;
  for (var i = 0; i < numNewValues; i++) {
    var key6 = newValueKeys[i];
    var targetValue = target[key6];
    var value = null;
    if (Array.isArray(targetValue)) {
      value = targetValue[0];
    }
    if (value === null) {
      value = (_b = (_a = origin[key6]) !== null && _a !== void 0 ? _a : visualElement2.readValue(key6)) !== null && _b !== void 0 ? _b : target[key6];
    }
    if (value === void 0 || value === null)
      continue;
    if (typeof value === "string" && (isNumericalString(value) || value.startsWith("0"))) {
      value = parseFloat(value);
    } else if (!findValueType(value) && complex.test(targetValue)) {
      value = getAnimatableNone2(key6, targetValue);
    }
    visualElement2.addValue(key6, motionValue(value));
    (_c = (_d = origin)[key6]) !== null && _c !== void 0 ? _c : _d[key6] = value;
    visualElement2.setBaseTarget(key6, value);
  }
}
function getOriginFromTransition(key6, transition) {
  if (!transition)
    return;
  var valueTransition = transition[key6] || transition["default"] || transition;
  return valueTransition.from;
}
function getOrigin(target, transition, visualElement2) {
  var _a, _b;
  var origin = {};
  for (var key6 in target) {
    origin[key6] = (_a = getOriginFromTransition(key6, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement2.getValue(key6)) === null || _b === void 0 ? void 0 : _b.get();
  }
  return origin;
}

// ../../node_modules/framer-motion/dist/es/render/utils/animation.js
function animateVisualElement(visualElement2, definition, options) {
  if (options === void 0) {
    options = {};
  }
  visualElement2.notifyAnimationStart();
  var animation;
  if (Array.isArray(definition)) {
    var animations2 = definition.map(function(variant) {
      return animateVariant(visualElement2, variant, options);
    });
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement2, definition, options);
  } else {
    var resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement2, definition, options.custom) : definition;
    animation = animateTarget(visualElement2, resolvedDefinition, options);
  }
  return animation.then(function() {
    return visualElement2.notifyAnimationComplete(definition);
  });
}
function animateVariant(visualElement2, variant, options) {
  var _a;
  if (options === void 0) {
    options = {};
  }
  var resolved = resolveVariant(visualElement2, variant, options.custom);
  var _b = (resolved || {}).transition, transition = _b === void 0 ? visualElement2.getDefaultTransition() || {} : _b;
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  var getAnimation2 = resolved ? function() {
    return animateTarget(visualElement2, resolved, options);
  } : function() {
    return Promise.resolve();
  };
  var getChildAnimations = ((_a = visualElement2.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? function(forwardDelay) {
    if (forwardDelay === void 0) {
      forwardDelay = 0;
    }
    var _a2 = transition.delayChildren, delayChildren = _a2 === void 0 ? 0 : _a2, staggerChildren = transition.staggerChildren, staggerDirection = transition.staggerDirection;
    return animateChildren(visualElement2, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : function() {
    return Promise.resolve();
  };
  var when = transition.when;
  if (when) {
    var _c = __read(when === "beforeChildren" ? [getAnimation2, getChildAnimations] : [getChildAnimations, getAnimation2], 2), first = _c[0], last = _c[1];
    return first().then(last);
  } else {
    return Promise.all([getAnimation2(), getChildAnimations(options.delay)]);
  }
}
function animateTarget(visualElement2, definition, _a) {
  var _b;
  var _c = _a === void 0 ? {} : _a, _d = _c.delay, delay = _d === void 0 ? 0 : _d, transitionOverride = _c.transitionOverride, type = _c.type;
  var _e = visualElement2.makeTargetAnimatable(definition), _f = _e.transition, transition = _f === void 0 ? visualElement2.getDefaultTransition() : _f, transitionEnd = _e.transitionEnd, target = __rest(_e, ["transition", "transitionEnd"]);
  if (transitionOverride)
    transition = transitionOverride;
  var animations2 = [];
  var animationTypeState = type && ((_b = visualElement2.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);
  for (var key6 in target) {
    var value = visualElement2.getValue(key6);
    var valueTarget = target[key6];
    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key6)) {
      continue;
    }
    var animation = startAnimation(key6, value, valueTarget, __assign({ delay }, transition));
    animations2.push(animation);
  }
  return Promise.all(animations2).then(function() {
    transitionEnd && setTarget(visualElement2, transitionEnd);
  });
}
function animateChildren(visualElement2, variant, delayChildren, staggerChildren, staggerDirection, options) {
  if (delayChildren === void 0) {
    delayChildren = 0;
  }
  if (staggerChildren === void 0) {
    staggerChildren = 0;
  }
  if (staggerDirection === void 0) {
    staggerDirection = 1;
  }
  var animations2 = [];
  var maxStaggerDuration = (visualElement2.variantChildren.size - 1) * staggerChildren;
  var generateStaggerDuration = staggerDirection === 1 ? function(i) {
    if (i === void 0) {
      i = 0;
    }
    return i * staggerChildren;
  } : function(i) {
    if (i === void 0) {
      i = 0;
    }
    return maxStaggerDuration - i * staggerChildren;
  };
  Array.from(visualElement2.variantChildren).sort(sortByTreeOrder).forEach(function(child, i) {
    animations2.push(animateVariant(child, variant, __assign(__assign({}, options), { delay: delayChildren + generateStaggerDuration(i) })).then(function() {
      return child.notifyAnimationComplete(variant);
    }));
  });
  return Promise.all(animations2);
}
function stopAnimation(visualElement2) {
  visualElement2.forEachValue(function(value) {
    return value.stop();
  });
}
function sortByTreeOrder(a2, b2) {
  return a2.sortNodePosition(b2);
}
function shouldBlockAnimation(_a, key6) {
  var protectedKeys = _a.protectedKeys, needsAnimating = _a.needsAnimating;
  var shouldBlock = protectedKeys.hasOwnProperty(key6) && needsAnimating[key6] !== true;
  needsAnimating[key6] = false;
  return shouldBlock;
}

// ../../node_modules/framer-motion/dist/es/render/utils/animation-state.js
var variantPriorityOrder = [
  AnimationType.Animate,
  AnimationType.Hover,
  AnimationType.Tap,
  AnimationType.Drag,
  AnimationType.Focus,
  AnimationType.Exit
];
var reversePriorityOrder = __spreadArray([], __read(variantPriorityOrder)).reverse();
var numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement2) {
  return function(animations2) {
    return Promise.all(animations2.map(function(_a) {
      var animation = _a.animation, options = _a.options;
      return animateVisualElement(visualElement2, animation, options);
    }));
  };
}
function createAnimationState(visualElement2) {
  var animate4 = animateList(visualElement2);
  var state = createState();
  var allAnimatedKeys = {};
  var isInitialRender = true;
  var buildResolvedTypeValues = function(acc, definition) {
    var resolved = resolveVariant(visualElement2, definition);
    if (resolved) {
      resolved.transition;
      var transitionEnd = resolved.transitionEnd, target = __rest(resolved, ["transition", "transitionEnd"]);
      acc = __assign(__assign(__assign({}, acc), target), transitionEnd);
    }
    return acc;
  };
  function isAnimated(key6) {
    return allAnimatedKeys[key6] !== void 0;
  }
  function setAnimateFunction(makeAnimator) {
    animate4 = makeAnimator(visualElement2);
  }
  function animateChanges(options, changedActiveType) {
    var _a;
    var props = visualElement2.getProps();
    var context = visualElement2.getVariantContext(true) || {};
    var animations2 = [];
    var removedKeys = new Set();
    var encounteredKeys = {};
    var removedVariantIndex = Infinity;
    var _loop_1 = function(i2) {
      var type = reversePriorityOrder[i2];
      var typeState = state[type];
      var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];
      var propIsVariant = isVariantLabel(prop);
      var activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i2;
      var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement2.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = __assign({}, encounteredKeys);
      if (!typeState.isActive && activeDelta === null || !prop && !typeState.prevProp || isAnimationControls(prop) || typeof prop === "boolean") {
        return "continue";
      }
      var shouldAnimateType = variantsHaveChanged(typeState.prevProp, prop) || type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || i2 > removedVariantIndex && propIsVariant;
      var definitionList = Array.isArray(prop) ? prop : [prop];
      var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
      if (activeDelta === false)
        resolvedValues = {};
      var _b = typeState.prevResolvedValues, prevResolvedValues = _b === void 0 ? {} : _b;
      var allKeys = __assign(__assign({}, prevResolvedValues), resolvedValues);
      var markToAnimate = function(key7) {
        shouldAnimateType = true;
        removedKeys.delete(key7);
        typeState.needsAnimating[key7] = true;
      };
      for (var key6 in allKeys) {
        var next = resolvedValues[key6];
        var prev = prevResolvedValues[key6];
        if (encounteredKeys.hasOwnProperty(key6))
          continue;
        if (next !== prev) {
          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
            if (!shallowCompare(next, prev)) {
              markToAnimate(key6);
            } else {
              typeState.protectedKeys[key6] = true;
            }
          } else if (next !== void 0) {
            markToAnimate(key6);
          } else {
            removedKeys.add(key6);
          }
        } else if (next !== void 0 && removedKeys.has(key6)) {
          markToAnimate(key6);
        } else {
          typeState.protectedKeys[key6] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = __assign(__assign({}, encounteredKeys), resolvedValues);
      }
      if (isInitialRender && visualElement2.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      if (shouldAnimateType && !isInherited) {
        animations2.push.apply(animations2, __spreadArray([], __read(definitionList.map(function(animation) {
          return {
            animation,
            options: __assign({ type }, options)
          };
        }))));
      }
    };
    for (var i = 0; i < numAnimationTypes; i++) {
      _loop_1(i);
    }
    allAnimatedKeys = __assign({}, encounteredKeys);
    if (removedKeys.size) {
      var fallbackAnimation_1 = {};
      removedKeys.forEach(function(key6) {
        var fallbackTarget = visualElement2.getBaseTarget(key6);
        if (fallbackTarget !== void 0) {
          fallbackAnimation_1[key6] = fallbackTarget;
        }
      });
      animations2.push({ animation: fallbackAnimation_1 });
    }
    var shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && props.initial === false && !visualElement2.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate4(animations2) : Promise.resolve();
  }
  function setActive(type, isActive, options) {
    var _a;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a = visualElement2.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function(child) {
      var _a2;
      return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);
    });
    state[type].isActive = isActive;
    return animateChanges(options, type);
  }
  return {
    isAnimated,
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: function() {
      return state;
    }
  };
}
function variantsHaveChanged(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (isVariantLabels(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
function createTypeState(isActive) {
  if (isActive === void 0) {
    isActive = false;
  }
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  var _a;
  return _a = {}, _a[AnimationType.Animate] = createTypeState(true), _a[AnimationType.Hover] = createTypeState(), _a[AnimationType.Tap] = createTypeState(), _a[AnimationType.Drag] = createTypeState(), _a[AnimationType.Focus] = createTypeState(), _a[AnimationType.Exit] = createTypeState(), _a;
}

// ../../node_modules/framer-motion/dist/es/motion/features/animations.js
var animations = {
  animation: makeRenderlessComponent(function(_a) {
    var visualElement2 = _a.visualElement, animate4 = _a.animate;
    visualElement2.animationState || (visualElement2.animationState = createAnimationState(visualElement2));
    if (isAnimationControls(animate4)) {
      useEffect6(function() {
        return animate4.subscribe(visualElement2);
      }, [animate4]);
    }
  }),
  exit: makeRenderlessComponent(function(props) {
    var custom = props.custom, visualElement2 = props.visualElement;
    var _a = __read(usePresence(), 2), isPresent2 = _a[0], onExitComplete = _a[1];
    var presenceContext = useContext8(PresenceContext);
    useEffect6(function() {
      var _a2, _b;
      var animation = (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Exit, !isPresent2, { custom: (_b = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== null && _b !== void 0 ? _b : custom });
      !isPresent2 && (animation === null || animation === void 0 ? void 0 : animation.then(onExitComplete));
    }, [isPresent2]);
  })
};

// ../../node_modules/framer-motion/dist/es/gestures/drag/use-drag.js
import { useContext as useContext9, useEffect as useEffect7 } from "react";

// ../../node_modules/framer-motion/dist/es/gestures/PanSession.js
var PanSession = function() {
  function PanSession2(event, handlers, _a) {
    var _this = this;
    var _b = _a === void 0 ? {} : _a, transformPagePoint = _b.transformPagePoint;
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.updatePoint = function() {
      if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))
        return;
      var info2 = getPanInfo(_this.lastMoveEventInfo, _this.history);
      var isPanStarted = _this.startEvent !== null;
      var isDistancePastThreshold = distance(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      var point2 = info2.point;
      var timestamp2 = getFrameData().timestamp;
      _this.history.push(__assign(__assign({}, point2), { timestamp: timestamp2 }));
      var _a2 = _this.handlers, onStart = _a2.onStart, onMove = _a2.onMove;
      if (!isPanStarted) {
        onStart && onStart(_this.lastMoveEvent, info2);
        _this.startEvent = _this.lastMoveEvent;
      }
      onMove && onMove(_this.lastMoveEvent, info2);
    };
    this.handlePointerMove = function(event2, info2) {
      _this.lastMoveEvent = event2;
      _this.lastMoveEventInfo = transformPoint(info2, _this.transformPagePoint);
      if (isMouseEvent(event2) && event2.buttons === 0) {
        _this.handlePointerUp(event2, info2);
        return;
      }
      es_default.update(_this.updatePoint, true);
    };
    this.handlePointerUp = function(event2, info2) {
      _this.end();
      var onEnd = _this.handlers.onEnd;
      if (!onEnd || !_this.startEvent)
        return;
      var panInfo = getPanInfo(transformPoint(info2, _this.transformPagePoint), _this.history);
      onEnd && onEnd(event2, panInfo);
    };
    if (isTouchEvent(event) && event.touches.length > 1)
      return;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    var info = extractEventInfo(event);
    var initialInfo = transformPoint(info, this.transformPagePoint);
    var point = initialInfo.point;
    var timestamp = getFrameData().timestamp;
    this.history = [__assign(__assign({}, point), { timestamp })];
    var onSessionStart = handlers.onSessionStart;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));
  }
  PanSession2.prototype.updateHandlers = function(handlers) {
    this.handlers = handlers;
  };
  PanSession2.prototype.end = function() {
    this.removeListeners && this.removeListeners();
    cancelSync.update(this.updatePoint);
  };
  return PanSession2;
}();
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a2, b2) {
  return { x: a2.x - b2.x, y: a2.y - b2.y };
}
function getPanInfo(_a, history) {
  var point = _a.point;
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity2(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity2(history, timeDelta2) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  var i = history.length - 1;
  var timestampedPoint = null;
  var lastPoint = lastDevicePoint(history);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta2)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  var time3 = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;
  if (time3 === 0) {
    return { x: 0, y: 0 };
  }
  var currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time3,
    y: (lastPoint.y - timestampedPoint.y) / time3
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}

// ../../node_modules/framer-motion/dist/es/utils/noop.js
function noop(any) {
  return any;
}

// ../../node_modules/framer-motion/dist/es/utils/geometry/index.js
function convertBoundingBoxToAxisBox(_a) {
  var top = _a.top, left = _a.left, right = _a.right, bottom = _a.bottom;
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertAxisBoxToBoundingBox(_a) {
  var x = _a.x, y = _a.y;
  return {
    top: y.min,
    bottom: y.max,
    left: x.min,
    right: x.max
  };
}
function transformBoundingBox(_a, transformPoint2) {
  var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;
  if (transformPoint2 === void 0) {
    transformPoint2 = noop;
  }
  var topLeft = transformPoint2({ x: left, y: top });
  var bottomRight = transformPoint2({ x: right, y: bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function axisBox() {
  return { x: { min: 0, max: 1 }, y: { min: 0, max: 1 } };
}
function copyAxisBox(box) {
  return {
    x: __assign({}, box.x),
    y: __assign({}, box.y)
  };
}
var zeroDelta = {
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
};
function delta() {
  return {
    x: __assign({}, zeroDelta),
    y: __assign({}, zeroDelta)
  };
}

// ../../node_modules/framer-motion/dist/es/utils/each-axis.js
function eachAxis(handler) {
  return [handler("x"), handler("y")];
}

// ../../node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.js
function applyConstraints(point, _a, elastic) {
  var min = _a.min, max = _a.max;
  if (min !== void 0 && point < min) {
    point = elastic ? mix(min, point, elastic.min) : Math.max(point, min);
  } else if (max !== void 0 && point > max) {
    point = elastic ? mix(max, point, elastic.max) : Math.min(point, max);
  }
  return point;
}
function calcConstrainedMinPoint(point, length, progress2, constraints, elastic) {
  var min = point - length * progress2;
  return constraints ? applyConstraints(min, constraints, elastic) : min;
}
function calcRelativeAxisConstraints(axis, min, max) {
  return {
    min: min !== void 0 ? axis.min + min : void 0,
    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, _a) {
  var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  var _a;
  var min = constraintsAxis.min - layoutAxis.min;
  var max = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    _a = __read([max, min], 2), min = _a[0], max = _a[1];
  }
  return {
    min: layoutAxis.min + min,
    max: layoutAxis.min + max
  };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcPositionFromProgress(axis, constraints, progress2) {
  var axisLength = axis.max - axis.min;
  var min = mix(constraints.min, constraints.max - axisLength, progress2);
  return { min, max: min + axisLength };
}
function rebaseAxisConstraints(layout, constraints) {
  var relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout.min;
  }
  return relativeConstraints;
}
var defaultElastic = 0.35;
function resolveDragElastic(dragElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  var _a;
  return typeof dragElastic === "number" ? dragElastic : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;
}

// ../../node_modules/framer-motion/dist/es/render/dom/projection/measure.js
function getBoundingBox(element, transformPagePoint) {
  var box = element.getBoundingClientRect();
  return convertBoundingBoxToAxisBox(transformBoundingBox(box, transformPagePoint));
}

// ../../node_modules/framer-motion/dist/es/utils/geometry/delta-calc.js
var clampProgress = function(v) {
  return clamp2(0, 1, v);
};
function isNear(value, target, maxDistance) {
  if (target === void 0) {
    target = 0;
  }
  if (maxDistance === void 0) {
    maxDistance = 0.01;
  }
  return distance(value, target) < maxDistance;
}
function calcLength(axis) {
  return axis.max - axis.min;
}
function calcOrigin2(source, target) {
  var origin = 0.5;
  var sourceLength = calcLength(source);
  var targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target.min);
  }
  return clampProgress(origin);
}
function updateAxisDelta(delta2, source, target, origin) {
  if (origin === void 0) {
    origin = 0.5;
  }
  delta2.origin = origin;
  delta2.originPoint = mix(source.min, source.max, delta2.origin);
  delta2.scale = calcLength(target) / calcLength(source);
  if (isNear(delta2.scale, 1, 1e-4))
    delta2.scale = 1;
  delta2.translate = mix(target.min, target.max, delta2.origin) - delta2.originPoint;
  if (isNear(delta2.translate))
    delta2.translate = 0;
}
function updateBoxDelta(delta2, source, target, origin) {
  updateAxisDelta(delta2.x, source.x, target.x, defaultOrigin(origin.originX));
  updateAxisDelta(delta2.y, source.y, target.y, defaultOrigin(origin.originY));
}
function defaultOrigin(origin) {
  return typeof origin === "number" ? origin : 0.5;
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(projection, parentProjection) {
  calcRelativeAxis(projection.target.x, projection.relativeTarget.x, parentProjection.target.x);
  calcRelativeAxis(projection.target.y, projection.relativeTarget.y, parentProjection.target.y);
}

// ../../node_modules/framer-motion/dist/es/render/utils/compare-by-depth.js
var compareByDepth = function(a2, b2) {
  return a2.depth - b2.depth;
};

// ../../node_modules/framer-motion/dist/es/render/dom/projection/utils.js
function updateTreeLayoutMeasurements(visualElement2, isRelativeDrag) {
  withoutTreeTransform(visualElement2, function() {
    var allChildren = collectProjectingChildren(visualElement2);
    batchResetAndMeasure(allChildren);
    updateLayoutMeasurement(visualElement2);
  });
  !isRelativeDrag && visualElement2.rebaseProjectionTarget(true, visualElement2.measureViewportBox(false));
}
function collectProjectingChildren(visualElement2) {
  var children = [];
  var addChild = function(child) {
    if (child.projection.isEnabled || child.shouldResetTransform()) {
      children.push(child);
    }
    child.children.forEach(addChild);
  };
  visualElement2.children.forEach(addChild);
  return children.sort(compareByDepth);
}
function withoutTreeTransform(visualElement2, callback) {
  var parent = visualElement2.parent;
  var isEnabled = visualElement2.projection.isEnabled;
  var shouldReset = isEnabled || visualElement2.shouldResetTransform();
  shouldReset && visualElement2.resetTransform();
  parent ? withoutTreeTransform(parent, callback) : callback();
  shouldReset && visualElement2.restoreTransform();
}
function updateLayoutMeasurement(visualElement2) {
  if (visualElement2.shouldResetTransform())
    return;
  var layoutState = visualElement2.getLayoutState();
  visualElement2.notifyBeforeLayoutMeasure(layoutState.layout);
  layoutState.isHydrated = true;
  layoutState.layout = visualElement2.measureViewportBox();
  layoutState.layoutCorrected = copyAxisBox(layoutState.layout);
  visualElement2.notifyLayoutMeasure(layoutState.layout, visualElement2.prevViewportBox || layoutState.layout);
  es_default.update(function() {
    return visualElement2.rebaseProjectionTarget();
  });
}
function snapshotViewportBox(visualElement2) {
  if (visualElement2.shouldResetTransform())
    return;
  visualElement2.prevViewportBox = visualElement2.measureViewportBox(false);
  visualElement2.rebaseProjectionTarget(false, visualElement2.prevViewportBox);
}
function batchResetAndMeasure(order2) {
  order2.forEach(function(child) {
    return child.resetTransform();
  });
  order2.forEach(updateLayoutMeasurement);
}

// ../../node_modules/framer-motion/dist/es/motion/features/layout/utils.js
function tweenAxis(target, prev, next, p) {
  target.min = mix(prev.min, next.min, p);
  target.max = mix(prev.max, next.max, p);
}
function calcRelativeOffsetAxis(parent, child) {
  return {
    min: child.min - parent.min,
    max: child.max - parent.min
  };
}
function calcRelativeOffset(parent, child) {
  return {
    x: calcRelativeOffsetAxis(parent.x, child.x),
    y: calcRelativeOffsetAxis(parent.y, child.y)
  };
}
function checkIfParentHasChanged(prev, next) {
  var prevId = prev.getLayoutId();
  var nextId = next.getLayoutId();
  return prevId !== nextId || nextId === void 0 && prev !== next;
}

// ../../node_modules/framer-motion/dist/es/render/utils/is-draggable.js
function isDraggable(visualElement2) {
  var _a = visualElement2.getProps(), drag2 = _a.drag, _dragX = _a._dragX;
  return drag2 && !_dragX;
}

// ../../node_modules/framer-motion/dist/es/utils/geometry/delta-apply.js
function resetAxis(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function resetBox(box, originBox) {
  resetAxis(box.x, originBox.x);
  resetAxis(box.y, originBox.y);
}
function scalePoint(point, scale2, originPoint) {
  var distanceFromOrigin = point - originPoint;
  var scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate, scale2, originPoint, boxScale) {
  if (translate === void 0) {
    translate = 0;
  }
  if (scale2 === void 0) {
    scale2 = 1;
  }
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, _a) {
  var x = _a.x, y = _a.y;
  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
}
function applyAxisTransforms(final, axis, transforms, _a) {
  var _b = __read(_a, 3), key6 = _b[0], scaleKey = _b[1], originKey = _b[2];
  final.min = axis.min;
  final.max = axis.max;
  var axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;
  var originPoint = mix(axis.min, axis.max, axisOrigin);
  applyAxisDelta(final, transforms[key6], transforms[scaleKey], originPoint, transforms.scale);
}
var xKeys = ["x", "scaleX", "originX"];
var yKeys = ["y", "scaleY", "originY"];
function applyBoxTransforms(finalBox, box, transforms) {
  applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);
  applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);
}
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(axis, translate, scale2, origin, boxScale) {
  if (translate === void 0) {
    translate = 0;
  }
  if (scale2 === void 0) {
    scale2 = 1;
  }
  if (origin === void 0) {
    origin = 0.5;
  }
  var originPoint = mix(axis.min, axis.max, origin) - translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, _a) {
  var _b = __read(_a, 3), key6 = _b[0], scaleKey = _b[1], originKey = _b[2];
  removeAxisDelta(axis, transforms[key6], transforms[scaleKey], transforms[originKey], transforms.scale);
}
function removeBoxTransforms(box, transforms) {
  removeAxisTransforms(box.x, transforms, xKeys);
  removeAxisTransforms(box.y, transforms, yKeys);
}
function applyTreeDeltas(box, treeScale, treePath) {
  var treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  var node;
  var delta2;
  for (var i = 0; i < treeLength; i++) {
    node = treePath[i];
    delta2 = node.getLayoutState().delta;
    treeScale.x *= delta2.x.scale;
    treeScale.y *= delta2.y.scale;
    applyBoxDelta(box, delta2);
    if (isDraggable(node)) {
      applyBoxTransforms(box, box, node.getLatestValues());
    }
  }
}

// ../../node_modules/framer-motion/dist/es/render/dom/projection/convert-to-relative.js
function convertToRelativeProjection(visualElement2, isLayoutDrag) {
  if (isLayoutDrag === void 0) {
    isLayoutDrag = true;
  }
  var projectionParent = visualElement2.getProjectionParent();
  if (!projectionParent)
    return false;
  var offset;
  if (isLayoutDrag) {
    offset = calcRelativeOffset(projectionParent.projection.target, visualElement2.projection.target);
    removeBoxTransforms(offset, projectionParent.getLatestValues());
  } else {
    offset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement2.getLayoutState().layout);
  }
  eachAxis(function(axis) {
    return visualElement2.setProjectionTargetAxis(axis, offset[axis].min, offset[axis].max, true);
  });
  return true;
}

// ../../node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.js
var elementDragControls = new WeakMap();
var lastPointerEvent;
var VisualElementDragControls = function() {
  function VisualElementDragControls2(_a) {
    var visualElement2 = _a.visualElement;
    this.isDragging = false;
    this.currentDirection = null;
    this.constraints = false;
    this.elastic = axisBox();
    this.props = {};
    this.hasMutatedConstraints = false;
    this.cursorProgress = {
      x: 0.5,
      y: 0.5
    };
    this.originPoint = {};
    this.openGlobalLock = null;
    this.panSession = null;
    this.visualElement = visualElement2;
    this.visualElement.enableLayoutProjection();
    elementDragControls.set(visualElement2, this);
  }
  VisualElementDragControls2.prototype.start = function(originEvent, _a) {
    var _this = this;
    var _b = _a === void 0 ? {} : _a, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c, cursorProgress = _b.cursorProgress;
    var onSessionStart = function(event) {
      _this.stopMotion();
      _this.updateLayoutMeasurements();
      snapToCursor && _this.snapToCursor(originEvent);
      _this.isLayoutDrag() && _this.visualElement.lockProjectionTarget();
      var point = getViewportPointFromEvent(event).point;
      eachAxis(function(axis) {
        var _a2 = _this.visualElement.projection.target[axis], min = _a2.min, max = _a2.max;
        _this.cursorProgress[axis] = cursorProgress ? cursorProgress[axis] : progress(min, max, point[axis]);
        var axisValue = _this.getAxisMotionValue(axis);
        if (axisValue) {
          _this.originPoint[axis] = axisValue.get();
        }
      });
    };
    var onStart = function(event, info) {
      var _a2, _b2, _c2;
      var _d = _this.props, drag2 = _d.drag, dragPropagation = _d.dragPropagation;
      if (drag2 && !dragPropagation) {
        if (_this.openGlobalLock)
          _this.openGlobalLock();
        _this.openGlobalLock = getGlobalLock(drag2);
        if (!_this.openGlobalLock)
          return;
      }
      _this.resolveDragConstraints();
      _this.isDragging = true;
      _this.currentDirection = null;
      (_b2 = (_a2 = _this.props).onDragStart) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, event, info);
      (_c2 = _this.visualElement.animationState) === null || _c2 === void 0 ? void 0 : _c2.setActive(AnimationType.Drag, true);
    };
    var onMove = function(event, info) {
      var _a2, _b2, _c2, _d;
      var _e = _this.props, dragPropagation = _e.dragPropagation, dragDirectionLock = _e.dragDirectionLock;
      if (!dragPropagation && !_this.openGlobalLock)
        return;
      var offset = info.offset;
      if (dragDirectionLock && _this.currentDirection === null) {
        _this.currentDirection = getCurrentDirection(offset);
        if (_this.currentDirection !== null) {
          (_b2 = (_a2 = _this.props).onDirectionLock) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, _this.currentDirection);
        }
        return;
      }
      _this.updateAxis("x", event, offset);
      _this.updateAxis("y", event, offset);
      (_d = (_c2 = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c2, event, info);
      lastPointerEvent = event;
    };
    var onEnd = function(event, info) {
      return _this.stop(event, info);
    };
    var transformPagePoint = this.props.transformPagePoint;
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onEnd
    }, { transformPagePoint });
  };
  VisualElementDragControls2.prototype.updateLayoutMeasurements = function() {
    updateTreeLayoutMeasurements(this.visualElement, Boolean(this.getAxisMotionValue("x") && !this.isExternalDrag()));
  };
  VisualElementDragControls2.prototype.resolveDragConstraints = function() {
    var _this = this;
    var _a = this.props, dragConstraints = _a.dragConstraints, dragElastic = _a.dragElastic;
    this.visualElement.updateLayoutProjection();
    var layout = this.visualElement.getLayoutState().layoutCorrected;
    if (dragConstraints) {
      this.constraints = isRefObject(dragConstraints) ? this.resolveRefConstraints(layout, dragConstraints) : calcRelativeConstraints(layout, dragConstraints);
    } else {
      this.constraints = false;
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (this.constraints && !this.hasMutatedConstraints) {
      eachAxis(function(axis) {
        if (_this.getAxisMotionValue(axis)) {
          _this.constraints[axis] = rebaseAxisConstraints(layout[axis], _this.constraints[axis]);
        }
      });
    }
  };
  VisualElementDragControls2.prototype.resolveRefConstraints = function(layoutBox, constraints) {
    var _a = this.props, onMeasureDragConstraints = _a.onMeasureDragConstraints, transformPagePoint = _a.transformPagePoint;
    var constraintsElement = constraints.current;
    invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);
    var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);
    if (onMeasureDragConstraints) {
      var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);
      }
    }
    return measuredConstraints;
  };
  VisualElementDragControls2.prototype.cancelDrag = function() {
    var _a;
    this.isDragging = false;
    this.panSession && this.panSession.end();
    this.panSession = null;
    if (!this.props.dragPropagation && this.openGlobalLock) {
      this.openGlobalLock();
      this.openGlobalLock = null;
    }
    (_a = this.visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Drag, false);
  };
  VisualElementDragControls2.prototype.stop = function(event, info) {
    var _a, _b, _c;
    this.visualElement.unlockProjectionTarget();
    (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();
    this.panSession = null;
    var isDragging = this.isDragging;
    this.cancelDrag();
    if (!isDragging)
      return;
    var velocity = info.velocity;
    this.animateDragEnd(velocity);
    (_c = (_b = this.props).onDragEnd) === null || _c === void 0 ? void 0 : _c.call(_b, event, info);
  };
  VisualElementDragControls2.prototype.snapToCursor = function(event) {
    var _this = this;
    eachAxis(function(axis) {
      var drag2 = _this.props.drag;
      if (!shouldDrag(axis, drag2, _this.currentDirection))
        return;
      var axisValue = _this.getAxisMotionValue(axis);
      if (axisValue) {
        var point = getViewportPointFromEvent(event).point;
        var box = _this.visualElement.getLayoutState().layout;
        var length_1 = box[axis].max - box[axis].min;
        var center = box[axis].min + length_1 / 2;
        var offset = point[axis] - center;
        _this.originPoint[axis] = point[axis];
        axisValue.set(offset);
      } else {
        _this.cursorProgress[axis] = 0.5;
        _this.updateVisualElementAxis(axis, event);
      }
    });
  };
  VisualElementDragControls2.prototype.updateAxis = function(axis, event, offset) {
    var drag2 = this.props.drag;
    if (!shouldDrag(axis, drag2, this.currentDirection))
      return;
    return this.getAxisMotionValue(axis) ? this.updateAxisMotionValue(axis, offset) : this.updateVisualElementAxis(axis, event);
  };
  VisualElementDragControls2.prototype.updateAxisMotionValue = function(axis, offset) {
    var axisValue = this.getAxisMotionValue(axis);
    if (!offset || !axisValue)
      return;
    var nextValue = this.originPoint[axis] + offset[axis];
    var update = this.constraints ? applyConstraints(nextValue, this.constraints[axis], this.elastic[axis]) : nextValue;
    axisValue.set(update);
  };
  VisualElementDragControls2.prototype.updateVisualElementAxis = function(axis, event) {
    var _a;
    var axisLayout = this.visualElement.getLayoutState().layout[axis];
    var axisLength = axisLayout.max - axisLayout.min;
    var axisProgress = this.cursorProgress[axis];
    var point = getViewportPointFromEvent(event).point;
    var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], this.elastic[axis]);
    this.visualElement.setProjectionTargetAxis(axis, min, min + axisLength);
  };
  VisualElementDragControls2.prototype.setProps = function(_a) {
    var _b = _a.drag, drag2 = _b === void 0 ? false : _b, _c = _a.dragDirectionLock, dragDirectionLock = _c === void 0 ? false : _c, _d = _a.dragPropagation, dragPropagation = _d === void 0 ? false : _d, _e = _a.dragConstraints, dragConstraints = _e === void 0 ? false : _e, _f = _a.dragElastic, dragElastic = _f === void 0 ? defaultElastic : _f, _g = _a.dragMomentum, dragMomentum = _g === void 0 ? true : _g, remainingProps = __rest(_a, ["drag", "dragDirectionLock", "dragPropagation", "dragConstraints", "dragElastic", "dragMomentum"]);
    this.props = __assign({
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    }, remainingProps);
  };
  VisualElementDragControls2.prototype.getAxisMotionValue = function(axis) {
    var _a = this.props, layout = _a.layout, layoutId = _a.layoutId;
    var dragKey = "_drag" + axis.toUpperCase();
    if (this.props[dragKey]) {
      return this.props[dragKey];
    } else if (!layout && layoutId === void 0) {
      return this.visualElement.getValue(axis, 0);
    }
  };
  VisualElementDragControls2.prototype.isLayoutDrag = function() {
    return !this.getAxisMotionValue("x");
  };
  VisualElementDragControls2.prototype.isExternalDrag = function() {
    var _a = this.props, _dragX = _a._dragX, _dragY = _a._dragY;
    return _dragX || _dragY;
  };
  VisualElementDragControls2.prototype.animateDragEnd = function(velocity) {
    var _this = this;
    var _a = this.props, drag2 = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition;
    var isRelative = convertToRelativeProjection(this.visualElement, this.isLayoutDrag() && !this.isExternalDrag());
    var constraints = this.constraints || {};
    if (isRelative && Object.keys(constraints).length && this.isLayoutDrag()) {
      var projectionParent = this.visualElement.getProjectionParent();
      if (projectionParent) {
        var relativeConstraints_1 = calcRelativeOffset(projectionParent.projection.targetFinal, constraints);
        eachAxis(function(axis) {
          var _a2 = relativeConstraints_1[axis], min = _a2.min, max = _a2.max;
          constraints[axis] = {
            min: isNaN(min) ? void 0 : min,
            max: isNaN(max) ? void 0 : max
          };
        });
      }
    }
    var momentumAnimations = eachAxis(function(axis) {
      var _a2;
      if (!shouldDrag(axis, drag2, _this.currentDirection)) {
        return;
      }
      var transition = (_a2 = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a2 !== void 0 ? _a2 : {};
      var bounceStiffness = dragElastic ? 200 : 1e6;
      var bounceDamping = dragElastic ? 40 : 1e7;
      var inertia2 = __assign(__assign({
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10
      }, dragTransition), transition);
      return _this.getAxisMotionValue(axis) ? _this.startAxisValueAnimation(axis, inertia2) : _this.visualElement.startLayoutAnimation(axis, inertia2, isRelative);
    });
    return Promise.all(momentumAnimations).then(function() {
      var _a2, _b;
      (_b = (_a2 = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a2);
    });
  };
  VisualElementDragControls2.prototype.stopMotion = function() {
    var _this = this;
    eachAxis(function(axis) {
      var axisValue = _this.getAxisMotionValue(axis);
      axisValue ? axisValue.stop() : _this.visualElement.stopLayoutAnimation();
    });
  };
  VisualElementDragControls2.prototype.startAxisValueAnimation = function(axis, transition) {
    var axisValue = this.getAxisMotionValue(axis);
    if (!axisValue)
      return;
    var currentValue = axisValue.get();
    axisValue.set(currentValue);
    axisValue.set(currentValue);
    return startAnimation(axis, axisValue, 0, transition);
  };
  VisualElementDragControls2.prototype.scalePoint = function() {
    var _this = this;
    var _a = this.props, drag2 = _a.drag, dragConstraints = _a.dragConstraints;
    if (!isRefObject(dragConstraints) || !this.constraintsBox)
      return;
    this.stopMotion();
    var boxProgress = { x: 0, y: 0 };
    eachAxis(function(axis) {
      boxProgress[axis] = calcOrigin2(_this.visualElement.projection.target[axis], _this.constraintsBox[axis]);
    });
    this.updateLayoutMeasurements();
    this.resolveDragConstraints();
    eachAxis(function(axis) {
      if (!shouldDrag(axis, drag2, null))
        return;
      var _a2 = calcPositionFromProgress(_this.visualElement.projection.target[axis], _this.constraintsBox[axis], boxProgress[axis]), min = _a2.min, max = _a2.max;
      _this.visualElement.setProjectionTargetAxis(axis, min, max);
    });
  };
  VisualElementDragControls2.prototype.mount = function(visualElement2) {
    var _this = this;
    var element = visualElement2.getInstance();
    var stopPointerListener = addPointerEvent(element, "pointerdown", function(event) {
      var _a = _this.props, drag2 = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;
      drag2 && dragListener && _this.start(event);
    });
    var stopResizeListener = addDomEvent(window, "resize", function() {
      _this.scalePoint();
    });
    var stopLayoutUpdateListener = visualElement2.onLayoutUpdate(function() {
      if (_this.isDragging)
        _this.resolveDragConstraints();
    });
    var prevDragCursor = visualElement2.prevDragCursor;
    if (prevDragCursor) {
      this.start(lastPointerEvent, { cursorProgress: prevDragCursor });
    }
    return function() {
      stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();
      stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();
      stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();
      _this.cancelDrag();
    };
  };
  return VisualElementDragControls2;
}();
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset, lockThreshold) {
  if (lockThreshold === void 0) {
    lockThreshold = 10;
  }
  var direction = null;
  if (Math.abs(offset.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}

// ../../node_modules/framer-motion/dist/es/gestures/drag/use-drag.js
function useDrag(props) {
  var groupDragControls = props.dragControls, visualElement2 = props.visualElement;
  var transformPagePoint = useContext9(MotionConfigContext).transformPagePoint;
  var dragControls = useConstant(function() {
    return new VisualElementDragControls({
      visualElement: visualElement2
    });
  });
  dragControls.setProps(__assign(__assign({}, props), { transformPagePoint }));
  useEffect7(function() {
    return groupDragControls && groupDragControls.subscribe(dragControls);
  }, [dragControls]);
  useEffect7(function() {
    return dragControls.mount(visualElement2);
  }, []);
}

// ../../node_modules/framer-motion/dist/es/gestures/use-pan-gesture.js
import { useRef as useRef4, useContext as useContext10, useEffect as useEffect8 } from "react";
function usePanGesture(_a) {
  var onPan = _a.onPan, onPanStart = _a.onPanStart, onPanEnd = _a.onPanEnd, onPanSessionStart = _a.onPanSessionStart, visualElement2 = _a.visualElement;
  var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;
  var panSession = useRef4(null);
  var transformPagePoint = useContext10(MotionConfigContext).transformPagePoint;
  var handlers = {
    onSessionStart: onPanSessionStart,
    onStart: onPanStart,
    onMove: onPan,
    onEnd: function(event, info) {
      panSession.current = null;
      onPanEnd && onPanEnd(event, info);
    }
  };
  useEffect8(function() {
    if (panSession.current !== null) {
      panSession.current.updateHandlers(handlers);
    }
  });
  function onPointerDown(event) {
    panSession.current = new PanSession(event, handlers, {
      transformPagePoint
    });
  }
  usePointerEvent(visualElement2, "pointerdown", hasPanEvents && onPointerDown);
  useUnmountEffect(function() {
    return panSession.current && panSession.current.end();
  });
}

// ../../node_modules/framer-motion/dist/es/motion/features/drag.js
var drag = {
  pan: makeRenderlessComponent(usePanGesture),
  drag: makeRenderlessComponent(useDrag)
};

// ../../node_modules/framer-motion/dist/es/motion/features/layout/Animate.js
import {
  Component,
  createElement as createElement4
} from "react";

// ../../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/types.js
var Presence;
(function(Presence2) {
  Presence2[Presence2["Entering"] = 0] = "Entering";
  Presence2[Presence2["Present"] = 1] = "Present";
  Presence2[Presence2["Exiting"] = 2] = "Exiting";
})(Presence || (Presence = {}));
var VisibilityAction;
(function(VisibilityAction2) {
  VisibilityAction2[VisibilityAction2["Hide"] = 0] = "Hide";
  VisibilityAction2[VisibilityAction2["Show"] = 1] = "Show";
})(VisibilityAction || (VisibilityAction = {}));

// ../../node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.js
function isCSSVariable2(value) {
  return typeof value === "string" && value.startsWith("var(--");
}
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current) {
  var match = cssVariableRegex.exec(current);
  if (!match)
    return [,];
  var _a = __read(match, 3), token = _a[1], fallback = _a[2];
  return [token, fallback];
}
var maxDepth = 4;
function getVariableValue(current, element, depth) {
  if (depth === void 0) {
    depth = 1;
  }
  invariant(depth <= maxDepth, 'Max CSS variable fallback depth detected in property "' + current + '". This may indicate a circular fallback dependency.');
  var _a = __read(parseCSSVariable(current), 2), token = _a[0], fallback = _a[1];
  if (!token)
    return;
  var resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    return resolved.trim();
  } else if (isCSSVariable2(fallback)) {
    return getVariableValue(fallback, element, depth + 1);
  } else {
    return fallback;
  }
}
function resolveCSSVariables(visualElement2, _a, transitionEnd) {
  var _b;
  var target = __rest(_a, []);
  var element = visualElement2.getInstance();
  if (!(element instanceof HTMLElement))
    return { target, transitionEnd };
  if (transitionEnd) {
    transitionEnd = __assign({}, transitionEnd);
  }
  visualElement2.forEachValue(function(value) {
    var current2 = value.get();
    if (!isCSSVariable2(current2))
      return;
    var resolved2 = getVariableValue(current2, element);
    if (resolved2)
      value.set(resolved2);
  });
  for (var key6 in target) {
    var current = target[key6];
    if (!isCSSVariable2(current))
      continue;
    var resolved = getVariableValue(current, element);
    if (!resolved)
      continue;
    target[key6] = resolved;
    if (transitionEnd)
      (_b = transitionEnd[key6]) !== null && _b !== void 0 ? _b : transitionEnd[key6] = current;
  }
  return { target, transitionEnd };
}

// ../../node_modules/framer-motion/dist/es/render/dom/projection/default-scale-correctors.js
function pixelsToPercent(pixels, axis) {
  return pixels / (axis.max - axis.min) * 100;
}
function correctBorderRadius(latest, _layoutState, _a) {
  var target = _a.target;
  if (typeof latest === "string") {
    if (px.test(latest)) {
      latest = parseFloat(latest);
    } else {
      return latest;
    }
  }
  var x = pixelsToPercent(latest, target.x);
  var y = pixelsToPercent(latest, target.y);
  return x + "% " + y + "%";
}
var varToken = "_$css";
function correctBoxShadow(latest, _a) {
  var delta2 = _a.delta, treeScale = _a.treeScale;
  var original = latest;
  var containsCSSVariables = latest.includes("var(");
  var cssVariables = [];
  if (containsCSSVariables) {
    latest = latest.replace(cssVariableRegex, function(match) {
      cssVariables.push(match);
      return varToken;
    });
  }
  var shadow = complex.parse(latest);
  if (shadow.length > 5)
    return original;
  var template = complex.createTransformer(latest);
  var offset = typeof shadow[0] !== "number" ? 1 : 0;
  var xScale = delta2.x.scale * treeScale.x;
  var yScale = delta2.y.scale * treeScale.y;
  shadow[0 + offset] /= xScale;
  shadow[1 + offset] /= yScale;
  var averageScale = mix(xScale, yScale, 0.5);
  if (typeof shadow[2 + offset] === "number")
    shadow[2 + offset] /= averageScale;
  if (typeof shadow[3 + offset] === "number")
    shadow[3 + offset] /= averageScale;
  var output = template(shadow);
  if (containsCSSVariables) {
    var i_1 = 0;
    output = output.replace(varToken, function() {
      var cssVariable = cssVariables[i_1];
      i_1++;
      return cssVariable;
    });
  }
  return output;
}
var borderCorrectionDefinition = {
  process: correctBorderRadius
};
var defaultScaleCorrectors = {
  borderRadius: __assign(__assign({}, borderCorrectionDefinition), { applyTo: [
    "borderTopLeftRadius",
    "borderTopRightRadius",
    "borderBottomLeftRadius",
    "borderBottomRightRadius"
  ] }),
  borderTopLeftRadius: borderCorrectionDefinition,
  borderTopRightRadius: borderCorrectionDefinition,
  borderBottomLeftRadius: borderCorrectionDefinition,
  borderBottomRightRadius: borderCorrectionDefinition,
  boxShadow: {
    process: correctBoxShadow
  }
};

// ../../node_modules/framer-motion/dist/es/motion/features/layout/Animate.js
var progressTarget = 1e3;
var Animate = function(_super) {
  __extends(Animate2, _super);
  function Animate2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.frameTarget = axisBox();
    _this.currentAnimationTarget = axisBox();
    _this.isAnimating = {
      x: false,
      y: false
    };
    _this.stopAxisAnimation = {
      x: void 0,
      y: void 0
    };
    _this.isAnimatingTree = false;
    _this.animate = function(target, origin, _a) {
      if (_a === void 0) {
        _a = {};
      }
      var originBox = _a.originBox, targetBox = _a.targetBox, visibilityAction = _a.visibilityAction, shouldStackAnimate = _a.shouldStackAnimate, onComplete = _a.onComplete, prevParent = _a.prevParent, config = __rest(_a, ["originBox", "targetBox", "visibilityAction", "shouldStackAnimate", "onComplete", "prevParent"]);
      var _b = _this.props, visualElement2 = _b.visualElement, layout = _b.layout;
      if (shouldStackAnimate === false) {
        _this.isAnimatingTree = false;
        return _this.safeToRemove();
      }
      if (_this.isAnimatingTree && shouldStackAnimate !== true) {
        return;
      } else if (shouldStackAnimate) {
        _this.isAnimatingTree = true;
      }
      origin = originBox || origin;
      target = targetBox || target;
      var isRelative = false;
      var projectionParent = visualElement2.getProjectionParent();
      if (projectionParent) {
        var prevParentViewportBox = projectionParent.prevViewportBox;
        var parentLayout = projectionParent.getLayoutState().layout;
        if (prevParent) {
          if (targetBox) {
            parentLayout = prevParent.getLayoutState().layout;
          }
          if (originBox && !checkIfParentHasChanged(prevParent, projectionParent) && prevParent.prevViewportBox) {
            prevParentViewportBox = prevParent.prevViewportBox;
          }
        }
        if (prevParentViewportBox && isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox)) {
          isRelative = true;
          origin = calcRelativeOffset(prevParentViewportBox, origin);
          target = calcRelativeOffset(parentLayout, target);
        }
      }
      var boxHasMoved = hasMoved(origin, target);
      var animations2 = eachAxis(function(axis) {
        var _a2, _b2;
        if (layout === "position") {
          var targetLength = target[axis].max - target[axis].min;
          origin[axis].max = origin[axis].min + targetLength;
        }
        if (visualElement2.projection.isTargetLocked) {
          return;
        } else if (visibilityAction !== void 0) {
          visualElement2.setVisibility(visibilityAction === VisibilityAction.Show);
        } else if (boxHasMoved) {
          return _this.animateAxis(axis, target[axis], origin[axis], __assign(__assign({}, config), { isRelative }));
        } else {
          (_b2 = (_a2 = _this.stopAxisAnimation)[axis]) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
          return visualElement2.setProjectionTargetAxis(axis, target[axis].min, target[axis].max, isRelative);
        }
      });
      visualElement2.syncRender();
      return Promise.all(animations2).then(function() {
        _this.isAnimatingTree = false;
        onComplete && onComplete();
        visualElement2.notifyLayoutAnimationComplete();
      });
    };
    return _this;
  }
  Animate2.prototype.componentDidMount = function() {
    var _this = this;
    var visualElement2 = this.props.visualElement;
    visualElement2.animateMotionValue = startAnimation;
    visualElement2.enableLayoutProjection();
    this.unsubLayoutReady = visualElement2.onLayoutUpdate(this.animate);
    visualElement2.layoutSafeToRemove = function() {
      return _this.safeToRemove();
    };
    addScaleCorrection(defaultScaleCorrectors);
  };
  Animate2.prototype.componentWillUnmount = function() {
    var _this = this;
    this.unsubLayoutReady();
    eachAxis(function(axis) {
      var _a, _b;
      return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a);
    });
  };
  Animate2.prototype.animateAxis = function(axis, target, origin, _a) {
    var _this = this;
    var _b, _c;
    var _d = _a === void 0 ? {} : _a, transition = _d.transition, isRelative = _d.isRelative;
    if (this.isAnimating[axis] && axisIsEqual(target, this.currentAnimationTarget[axis])) {
      return;
    }
    (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);
    this.isAnimating[axis] = true;
    var visualElement2 = this.props.visualElement;
    var frameTarget = this.frameTarget[axis];
    var layoutProgress = visualElement2.getProjectionAnimationProgress()[axis];
    layoutProgress.clearListeners();
    layoutProgress.set(0);
    layoutProgress.set(0);
    var frame2 = function() {
      var p = layoutProgress.get() / progressTarget;
      tweenAxis(frameTarget, origin, target, p);
      visualElement2.setProjectionTargetAxis(axis, frameTarget.min, frameTarget.max, isRelative);
    };
    frame2();
    var unsubscribeProgress = layoutProgress.onChange(frame2);
    this.stopAxisAnimation[axis] = function() {
      _this.isAnimating[axis] = false;
      layoutProgress.stop();
      unsubscribeProgress();
    };
    this.currentAnimationTarget[axis] = target;
    var layoutTransition = transition || visualElement2.getDefaultTransition() || defaultLayoutTransition;
    var animation = startAnimation(axis === "x" ? "layoutX" : "layoutY", layoutProgress, progressTarget, layoutTransition && getValueTransition(layoutTransition, "layout")).then(this.stopAxisAnimation[axis]);
    return animation;
  };
  Animate2.prototype.safeToRemove = function() {
    var _a, _b;
    (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  Animate2.prototype.render = function() {
    return null;
  };
  return Animate2;
}(Component);
function AnimateLayoutContextProvider(props) {
  var _a = __read(usePresence(), 2), safeToRemove = _a[1];
  return createElement4(Animate, __assign({}, props, { safeToRemove }));
}
function hasMoved(a2, b2) {
  return !isZeroBox(a2) && !isZeroBox(b2) && (!axisIsEqual(a2.x, b2.x) || !axisIsEqual(a2.y, b2.y));
}
var zeroAxis = { min: 0, max: 0 };
function isZeroBox(a2) {
  return axisIsEqual(a2.x, zeroAxis) && axisIsEqual(a2.y, zeroAxis);
}
function axisIsEqual(a2, b2) {
  return a2.min === b2.min && a2.max === b2.max;
}
var defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
function isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox) {
  return prevParent || !prevParent && !(originBox || targetBox);
}

// ../../node_modules/framer-motion/dist/es/motion/features/layout/Measure.js
import React__default, { useContext as useContext11 } from "react";

// ../../node_modules/framer-motion/dist/es/context/SharedLayoutContext.js
import { createContext as createContext6 } from "react";

// ../../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/batcher.js
var defaultHandler = {
  layoutReady: function(child) {
    return child.notifyLayoutReady();
  }
};
function createBatcher() {
  var queue = new Set();
  return {
    add: function(child) {
      return queue.add(child);
    },
    flush: function(_a) {
      var _b = _a === void 0 ? defaultHandler : _a, layoutReady = _b.layoutReady, parent = _b.parent;
      var order2 = Array.from(queue).sort(compareByDepth);
      if (parent) {
        withoutTreeTransform(parent, function() {
          batchResetAndMeasure(order2);
        });
      } else {
        batchResetAndMeasure(order2);
      }
      order2.forEach(layoutReady);
      order2.forEach(function(child) {
        if (child.isPresent)
          child.presence = Presence.Present;
      });
      flushSync.preRender();
      flushSync.render();
      es_default.postRender(function() {
        return order2.forEach(assignProjectionToSnapshot);
      });
      queue.clear();
    }
  };
}
function assignProjectionToSnapshot(child) {
  child.prevViewportBox = child.projection.target;
}

// ../../node_modules/framer-motion/dist/es/context/SharedLayoutContext.js
var SharedLayoutContext = createContext6(createBatcher());
var FramerTreeLayoutContext = createContext6(createBatcher());
function isSharedLayout(context) {
  return !!context.forceUpdate;
}

// ../../node_modules/framer-motion/dist/es/motion/features/layout/Measure.js
var Measure = function(_super) {
  __extends(Measure2, _super);
  function Measure2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Measure2.prototype.componentDidMount = function() {
    var _a = this.props, syncLayout = _a.syncLayout, framerSyncLayout = _a.framerSyncLayout, visualElement2 = _a.visualElement;
    isSharedLayout(syncLayout) && syncLayout.register(visualElement2);
    isSharedLayout(framerSyncLayout) && framerSyncLayout.register(visualElement2);
    visualElement2.onUnmount(function() {
      if (isSharedLayout(syncLayout)) {
        syncLayout.remove(visualElement2);
      }
      if (isSharedLayout(framerSyncLayout)) {
        framerSyncLayout.remove(visualElement2);
      }
    });
  };
  Measure2.prototype.getSnapshotBeforeUpdate = function() {
    var _a = this.props, syncLayout = _a.syncLayout, visualElement2 = _a.visualElement;
    if (isSharedLayout(syncLayout)) {
      syncLayout.syncUpdate();
    } else {
      snapshotViewportBox(visualElement2);
      syncLayout.add(visualElement2);
    }
    return null;
  };
  Measure2.prototype.componentDidUpdate = function() {
    var syncLayout = this.props.syncLayout;
    if (!isSharedLayout(syncLayout))
      syncLayout.flush();
  };
  Measure2.prototype.render = function() {
    return null;
  };
  return Measure2;
}(React__default.Component);
function MeasureContextProvider(props) {
  var syncLayout = useContext11(SharedLayoutContext);
  var framerSyncLayout = useContext11(FramerTreeLayoutContext);
  return React__default.createElement(Measure, __assign({}, props, { syncLayout, framerSyncLayout }));
}

// ../../node_modules/framer-motion/dist/es/motion/features/layout/index.js
var layoutAnimations = {
  measureLayout: MeasureContextProvider,
  layoutAnimation: AnimateLayoutContextProvider
};

// ../../node_modules/framer-motion/dist/es/render/utils/state.js
var createProjectionState = function() {
  return {
    isEnabled: false,
    isTargetLocked: false,
    target: axisBox(),
    targetFinal: axisBox()
  };
};
function createLayoutState() {
  return {
    isHydrated: false,
    layout: axisBox(),
    layoutCorrected: axisBox(),
    treeScale: { x: 1, y: 1 },
    delta: delta(),
    deltaFinal: delta(),
    deltaTransform: ""
  };
}
var zeroLayout = createLayoutState();

// ../../node_modules/framer-motion/dist/es/render/html/utils/build-projection-transform.js
function buildLayoutProjectionTransform(_a, treeScale, latestTransform) {
  var x = _a.x, y = _a.y;
  var xTranslate = x.translate / treeScale.x;
  var yTranslate = y.translate / treeScale.y;
  var transform2 = "translate3d(" + xTranslate + "px, " + yTranslate + "px, 0) ";
  if (latestTransform) {
    var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;
    if (rotate)
      transform2 += "rotate(" + rotate + ") ";
    if (rotateX)
      transform2 += "rotateX(" + rotateX + ") ";
    if (rotateY)
      transform2 += "rotateY(" + rotateY + ") ";
  }
  transform2 += "scale(" + x.scale + ", " + y.scale + ")";
  return !latestTransform && transform2 === identityProjection ? "" : transform2;
}
function buildLayoutProjectionTransformOrigin(_a) {
  var deltaFinal = _a.deltaFinal;
  return deltaFinal.x.origin * 100 + "% " + deltaFinal.y.origin * 100 + "% 0";
}
var identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, { x: 1, y: 1 });

// ../../node_modules/framer-motion/dist/es/render/utils/lifecycles.js
var names = [
  "LayoutMeasure",
  "BeforeLayoutMeasure",
  "LayoutUpdate",
  "ViewportBoxUpdate",
  "Update",
  "Render",
  "AnimationComplete",
  "LayoutAnimationComplete",
  "AnimationStart",
  "SetAxisTarget",
  "Unmount"
];
function createLifecycles() {
  var managers = names.map(function() {
    return new SubscriptionManager();
  });
  var propSubscriptions = {};
  var lifecycles = {
    clearAllListeners: function() {
      return managers.forEach(function(manager) {
        return manager.clear();
      });
    },
    updatePropListeners: function(props) {
      return names.forEach(function(name) {
        var _a;
        (_a = propSubscriptions[name]) === null || _a === void 0 ? void 0 : _a.call(propSubscriptions);
        var on = "on" + name;
        var propListener = props[on];
        if (propListener) {
          propSubscriptions[name] = lifecycles[on](propListener);
        }
      });
    }
  };
  managers.forEach(function(manager, i) {
    lifecycles["on" + names[i]] = function(handler) {
      return manager.add(handler);
    };
    lifecycles["notify" + names[i]] = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return manager.notify.apply(manager, __spreadArray([], __read(args)));
    };
  });
  return lifecycles;
}

// ../../node_modules/framer-motion/dist/es/render/utils/motion-values.js
function updateMotionValuesFromProps(element, next, prev) {
  var _a;
  for (var key6 in next) {
    var nextValue = next[key6];
    var prevValue = prev[key6];
    if (isMotionValue(nextValue)) {
      element.addValue(key6, nextValue);
    } else if (isMotionValue(prevValue)) {
      element.addValue(key6, motionValue(nextValue));
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key6)) {
        var existingValue = element.getValue(key6);
        !existingValue.hasAnimated && existingValue.set(nextValue);
      } else {
        element.addValue(key6, motionValue((_a = element.getStaticValue(key6)) !== null && _a !== void 0 ? _a : nextValue));
      }
    }
  }
  for (var key6 in prev) {
    if (next[key6] === void 0)
      element.removeValue(key6);
  }
  return next;
}

// ../../node_modules/framer-motion/dist/es/render/utils/projection.js
function updateLayoutDeltas(_a, _b, treePath, transformOrigin) {
  var delta2 = _a.delta, layout = _a.layout, layoutCorrected = _a.layoutCorrected, treeScale = _a.treeScale;
  var target = _b.target;
  resetBox(layoutCorrected, layout);
  applyTreeDeltas(layoutCorrected, treeScale, treePath);
  updateBoxDelta(delta2, layoutCorrected, target, transformOrigin);
}

// ../../node_modules/framer-motion/dist/es/render/utils/flat-tree.js
var FlatTree = function() {
  function FlatTree2() {
    this.children = [];
    this.isDirty = false;
  }
  FlatTree2.prototype.add = function(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  };
  FlatTree2.prototype.remove = function(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  };
  FlatTree2.prototype.forEach = function(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  };
  return FlatTree2;
}();

// ../../node_modules/framer-motion/dist/es/render/dom/projection/relative-set.js
function setCurrentViewportBox(visualElement2) {
  var projectionParent = visualElement2.getProjectionParent();
  if (!projectionParent) {
    visualElement2.rebaseProjectionTarget();
    return;
  }
  var relativeOffset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement2.getLayoutState().layout);
  eachAxis(function(axis) {
    visualElement2.setProjectionTargetAxis(axis, relativeOffset[axis].min, relativeOffset[axis].max, true);
  });
}

// ../../node_modules/framer-motion/dist/es/render/index.js
var visualElement = function(_a) {
  var _b = _a.treeType, treeType = _b === void 0 ? "" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, resetTransform = _a.resetTransform, restoreTransform = _a.restoreTransform, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps3 = _a.scrapeMotionValuesFromProps;
  return function(_a2, options) {
    var parent = _a2.parent, props = _a2.props, presenceId2 = _a2.presenceId, blockInitialAnimation = _a2.blockInitialAnimation, visualState = _a2.visualState;
    if (options === void 0) {
      options = {};
    }
    var latestValues = visualState.latestValues, renderState = visualState.renderState;
    var instance;
    var lifecycles = createLifecycles();
    var projection = createProjectionState();
    var projectionParent;
    var leadProjection = projection;
    var leadLatestValues = latestValues;
    var unsubscribeFromLeadVisualElement;
    var layoutState = createLayoutState();
    var crossfader;
    var hasViewportBoxUpdated = false;
    var values = new Map();
    var valueSubscriptions = new Map();
    var prevMotionValues = {};
    var projectionTargetProgress;
    var baseTarget = __assign({}, latestValues);
    var removeFromVariantTree;
    function render() {
      if (!instance)
        return;
      if (element.isProjectionReady()) {
        applyBoxTransforms(leadProjection.targetFinal, leadProjection.target, leadLatestValues);
        updateBoxDelta(layoutState.deltaFinal, layoutState.layoutCorrected, leadProjection.targetFinal, latestValues);
      }
      triggerBuild();
      renderInstance(instance, renderState);
    }
    function triggerBuild() {
      var valuesToRender = latestValues;
      if (crossfader && crossfader.isActive()) {
        var crossfadedValues = crossfader.getCrossfadeState(element);
        if (crossfadedValues)
          valuesToRender = crossfadedValues;
      }
      build(element, renderState, valuesToRender, leadProjection, layoutState, options, props);
    }
    function update() {
      lifecycles.notifyUpdate(latestValues);
    }
    function updateLayoutProjection() {
      var delta2 = layoutState.delta, treeScale = layoutState.treeScale;
      var prevTreeScaleX = treeScale.x;
      var prevTreeScaleY = treeScale.x;
      var prevDeltaTransform = layoutState.deltaTransform;
      updateLayoutDeltas(layoutState, leadProjection, element.path, latestValues);
      hasViewportBoxUpdated && element.notifyViewportBoxUpdate(leadProjection.target, delta2);
      hasViewportBoxUpdated = false;
      var deltaTransform = buildLayoutProjectionTransform(delta2, treeScale);
      if (deltaTransform !== prevDeltaTransform || prevTreeScaleX !== treeScale.x || prevTreeScaleY !== treeScale.y) {
        element.scheduleRender();
      }
      layoutState.deltaTransform = deltaTransform;
    }
    function updateTreeLayoutProjection() {
      element.layoutTree.forEach(fireUpdateLayoutProjection);
    }
    function bindToMotionValue(key7, value2) {
      var removeOnChange = value2.onChange(function(latestValue) {
        latestValues[key7] = latestValue;
        props.onUpdate && es_default.update(update, false, true);
      });
      var removeOnRenderRequest = value2.onRenderRequest(element.scheduleRender);
      valueSubscriptions.set(key7, function() {
        removeOnChange();
        removeOnRenderRequest();
      });
    }
    var initialMotionValues = scrapeMotionValuesFromProps3(props);
    for (var key6 in initialMotionValues) {
      var value = initialMotionValues[key6];
      if (latestValues[key6] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key6], false);
      }
    }
    var isControllingVariants = checkIfControllingVariants(props);
    var isVariantNode = checkIfVariantNode(props);
    var element = __assign(__assign({
      treeType,
      current: null,
      depth: parent ? parent.depth + 1 : 0,
      parent,
      children: new Set(),
      path: parent ? __spreadArray(__spreadArray([], __read(parent.path)), [parent]) : [],
      layoutTree: parent ? parent.layoutTree : new FlatTree(),
      presenceId: presenceId2,
      projection,
      variantChildren: isVariantNode ? new Set() : void 0,
      isVisible: void 0,
      manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),
      blockInitialAnimation,
      isHoverEventsEnabled: true,
      isMounted: function() {
        return Boolean(instance);
      },
      mount: function(newInstance) {
        instance = element.current = newInstance;
        element.pointTo(element);
        if (isVariantNode && parent && !isControllingVariants) {
          removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);
        }
        parent === null || parent === void 0 ? void 0 : parent.children.add(element);
      },
      unmount: function() {
        cancelSync.update(update);
        cancelSync.render(render);
        cancelSync.preRender(element.updateLayoutProjection);
        valueSubscriptions.forEach(function(remove2) {
          return remove2();
        });
        element.stopLayoutAnimation();
        element.layoutTree.remove(element);
        removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();
        parent === null || parent === void 0 ? void 0 : parent.children.delete(element);
        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();
        lifecycles.clearAllListeners();
      },
      addVariantChild: function(child) {
        var _a3;
        var closestVariantNode = element.getClosestVariantNode();
        if (closestVariantNode) {
          (_a3 = closestVariantNode.variantChildren) === null || _a3 === void 0 ? void 0 : _a3.add(child);
          return function() {
            return closestVariantNode.variantChildren.delete(child);
          };
        }
      },
      sortNodePosition: function(other) {
        if (!sortNodePosition || treeType !== other.treeType)
          return 0;
        return sortNodePosition(element.getInstance(), other.getInstance());
      },
      getClosestVariantNode: function() {
        return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();
      },
      scheduleUpdateLayoutProjection: parent ? parent.scheduleUpdateLayoutProjection : function() {
        return es_default.preRender(element.updateTreeLayoutProjection, false, true);
      },
      getLayoutId: function() {
        return props.layoutId;
      },
      getInstance: function() {
        return instance;
      },
      getStaticValue: function(key7) {
        return latestValues[key7];
      },
      setStaticValue: function(key7, value2) {
        return latestValues[key7] = value2;
      },
      getLatestValues: function() {
        return latestValues;
      },
      setVisibility: function(visibility) {
        if (element.isVisible === visibility)
          return;
        element.isVisible = visibility;
        element.scheduleRender();
      },
      makeTargetAnimatable: function(target, canMutate) {
        if (canMutate === void 0) {
          canMutate = true;
        }
        return makeTargetAnimatable(element, target, props, canMutate);
      },
      suspendHoverEvents: function() {
        element.isHoverEventsEnabled = false;
        es_default.postRender(function() {
          return setTimeout(function() {
            return element.isHoverEventsEnabled = true;
          }, 10);
        });
      },
      addValue: function(key7, value2) {
        if (element.hasValue(key7))
          element.removeValue(key7);
        values.set(key7, value2);
        latestValues[key7] = value2.get();
        bindToMotionValue(key7, value2);
      },
      removeValue: function(key7) {
        var _a3;
        values.delete(key7);
        (_a3 = valueSubscriptions.get(key7)) === null || _a3 === void 0 ? void 0 : _a3();
        valueSubscriptions.delete(key7);
        delete latestValues[key7];
        removeValueFromRenderState(key7, renderState);
      },
      hasValue: function(key7) {
        return values.has(key7);
      },
      getValue: function(key7, defaultValue) {
        var value2 = values.get(key7);
        if (value2 === void 0 && defaultValue !== void 0) {
          value2 = motionValue(defaultValue);
          element.addValue(key7, value2);
        }
        return value2;
      },
      forEachValue: function(callback) {
        return values.forEach(callback);
      },
      readValue: function(key7) {
        var _a3;
        return (_a3 = latestValues[key7]) !== null && _a3 !== void 0 ? _a3 : readValueFromInstance(instance, key7, options);
      },
      setBaseTarget: function(key7, value2) {
        baseTarget[key7] = value2;
      },
      getBaseTarget: function(key7) {
        if (getBaseTarget) {
          var target = getBaseTarget(props, key7);
          if (target !== void 0 && !isMotionValue(target))
            return target;
        }
        return baseTarget[key7];
      }
    }, lifecycles), {
      build: function() {
        triggerBuild();
        return renderState;
      },
      scheduleRender: function() {
        es_default.render(render, false, true);
      },
      syncRender: render,
      setProps: function(newProps) {
        props = newProps;
        lifecycles.updatePropListeners(newProps);
        prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps3(props), prevMotionValues);
      },
      getProps: function() {
        return props;
      },
      getVariant: function(name) {
        var _a3;
        return (_a3 = props.variants) === null || _a3 === void 0 ? void 0 : _a3[name];
      },
      getDefaultTransition: function() {
        return props.transition;
      },
      getVariantContext: function(startAtParent) {
        if (startAtParent === void 0) {
          startAtParent = false;
        }
        if (startAtParent)
          return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();
        if (!isControllingVariants) {
          var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};
          if (props.initial !== void 0) {
            context_1.initial = props.initial;
          }
          return context_1;
        }
        var context = {};
        for (var i = 0; i < numVariantProps; i++) {
          var name_1 = variantProps[i];
          var prop = props[name_1];
          if (isVariantLabel(prop) || prop === false) {
            context[name_1] = prop;
          }
        }
        return context;
      },
      enableLayoutProjection: function() {
        projection.isEnabled = true;
        element.layoutTree.add(element);
      },
      lockProjectionTarget: function() {
        projection.isTargetLocked = true;
      },
      unlockProjectionTarget: function() {
        element.stopLayoutAnimation();
        projection.isTargetLocked = false;
      },
      getLayoutState: function() {
        return layoutState;
      },
      setCrossfader: function(newCrossfader) {
        crossfader = newCrossfader;
      },
      isProjectionReady: function() {
        return projection.isEnabled && layoutState.isHydrated;
      },
      startLayoutAnimation: function(axis, transition, isRelative) {
        if (isRelative === void 0) {
          isRelative = false;
        }
        var progress2 = element.getProjectionAnimationProgress()[axis];
        var _a3 = isRelative ? projection.relativeTarget[axis] : projection.target[axis], min = _a3.min, max = _a3.max;
        var length = max - min;
        progress2.clearListeners();
        progress2.set(min);
        progress2.set(min);
        progress2.onChange(function(v) {
          element.setProjectionTargetAxis(axis, v, v + length, isRelative);
        });
        return element.animateMotionValue(axis, progress2, 0, transition);
      },
      stopLayoutAnimation: function() {
        eachAxis(function(axis) {
          return element.getProjectionAnimationProgress()[axis].stop();
        });
      },
      measureViewportBox: function(withTransform) {
        if (withTransform === void 0) {
          withTransform = true;
        }
        var viewportBox = measureViewportBox(instance, options);
        if (!withTransform)
          removeBoxTransforms(viewportBox, latestValues);
        return viewportBox;
      },
      getProjectionAnimationProgress: function() {
        projectionTargetProgress || (projectionTargetProgress = {
          x: motionValue(0),
          y: motionValue(0)
        });
        return projectionTargetProgress;
      },
      setProjectionTargetAxis: function(axis, min, max, isRelative) {
        if (isRelative === void 0) {
          isRelative = false;
        }
        var target;
        if (isRelative) {
          if (!projection.relativeTarget) {
            projection.relativeTarget = axisBox();
          }
          target = projection.relativeTarget[axis];
        } else {
          projection.relativeTarget = void 0;
          target = projection.target[axis];
        }
        target.min = min;
        target.max = max;
        hasViewportBoxUpdated = true;
        lifecycles.notifySetAxisTarget();
      },
      rebaseProjectionTarget: function(force, box) {
        if (box === void 0) {
          box = layoutState.layout;
        }
        var _a3 = element.getProjectionAnimationProgress(), x = _a3.x, y = _a3.y;
        var shouldRebase = !projection.relativeTarget && !projection.isTargetLocked && !x.isAnimating() && !y.isAnimating();
        if (force || shouldRebase) {
          eachAxis(function(axis) {
            var _a4 = box[axis], min = _a4.min, max = _a4.max;
            element.setProjectionTargetAxis(axis, min, max);
          });
        }
      },
      notifyLayoutReady: function(config) {
        setCurrentViewportBox(element);
        element.notifyLayoutUpdate(layoutState.layout, element.prevViewportBox || layoutState.layout, config);
      },
      resetTransform: function() {
        return resetTransform(element, instance, props);
      },
      restoreTransform: function() {
        return restoreTransform(instance, renderState);
      },
      updateLayoutProjection,
      updateTreeLayoutProjection: function() {
        element.layoutTree.forEach(fireResolveRelativeTargetBox);
        es_default.preRender(updateTreeLayoutProjection, false, true);
      },
      getProjectionParent: function() {
        if (projectionParent === void 0) {
          var foundParent = false;
          for (var i = element.path.length - 1; i >= 0; i--) {
            var ancestor = element.path[i];
            if (ancestor.projection.isEnabled) {
              foundParent = ancestor;
              break;
            }
          }
          projectionParent = foundParent;
        }
        return projectionParent;
      },
      resolveRelativeTargetBox: function() {
        var relativeParent = element.getProjectionParent();
        if (!projection.relativeTarget || !relativeParent)
          return;
        calcRelativeBox(projection, relativeParent.projection);
        if (isDraggable(relativeParent)) {
          var target = projection.target;
          applyBoxTransforms(target, target, relativeParent.getLatestValues());
        }
      },
      shouldResetTransform: function() {
        return Boolean(props._layoutResetTransform);
      },
      pointTo: function(newLead) {
        leadProjection = newLead.projection;
        leadLatestValues = newLead.getLatestValues();
        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();
        unsubscribeFromLeadVisualElement = pipe(newLead.onSetAxisTarget(element.scheduleUpdateLayoutProjection), newLead.onLayoutAnimationComplete(function() {
          var _a3;
          if (element.isPresent) {
            element.presence = Presence.Present;
          } else {
            (_a3 = element.layoutSafeToRemove) === null || _a3 === void 0 ? void 0 : _a3.call(element);
          }
        }));
      },
      isPresent: true,
      presence: Presence.Entering
    });
    return element;
  };
};
function fireResolveRelativeTargetBox(child) {
  child.resolveRelativeTargetBox();
}
function fireUpdateLayoutProjection(child) {
  child.updateLayoutProjection();
}
var variantProps = __spreadArray(["initial"], __read(variantPriorityOrder));
var numVariantProps = variantProps.length;

// ../../node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.js
var positionalKeys = new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y"
]);
var isPositionalKey = function(key6) {
  return positionalKeys.has(key6);
};
var hasPositionalKey = function(target) {
  return Object.keys(target).some(isPositionalKey);
};
var setAndResetVelocity = function(value, to) {
  value.set(to, false);
  value.set(to);
};
var isNumOrPxType = function(v) {
  return v === number || v === px;
};
var BoundingBoxDimension;
(function(BoundingBoxDimension2) {
  BoundingBoxDimension2["width"] = "width";
  BoundingBoxDimension2["height"] = "height";
  BoundingBoxDimension2["left"] = "left";
  BoundingBoxDimension2["right"] = "right";
  BoundingBoxDimension2["top"] = "top";
  BoundingBoxDimension2["bottom"] = "bottom";
})(BoundingBoxDimension || (BoundingBoxDimension = {}));
var getPosFromMatrix = function(matrix, pos) {
  return parseFloat(matrix.split(", ")[pos]);
};
var getTranslateFromMatrix = function(pos2, pos3) {
  return function(_bbox, _a) {
    var transform2 = _a.transform;
    if (transform2 === "none" || !transform2)
      return 0;
    var matrix3d = transform2.match(/^matrix3d\((.+)\)$/);
    if (matrix3d) {
      return getPosFromMatrix(matrix3d[1], pos3);
    } else {
      var matrix = transform2.match(/^matrix\((.+)\)$/);
      if (matrix) {
        return getPosFromMatrix(matrix[1], pos2);
      } else {
        return 0;
      }
    }
  };
};
var transformKeys = new Set(["x", "y", "z"]);
var nonTranslationalTransformKeys = transformProps.filter(function(key6) {
  return !transformKeys.has(key6);
});
function removeNonTranslationalTransform(visualElement2) {
  var removedTransforms = [];
  nonTranslationalTransformKeys.forEach(function(key6) {
    var value = visualElement2.getValue(key6);
    if (value !== void 0) {
      removedTransforms.push([key6, value.get()]);
      value.set(key6.startsWith("scale") ? 1 : 0);
    }
  });
  if (removedTransforms.length)
    visualElement2.syncRender();
  return removedTransforms;
}
var positionalValues = {
  width: function(_a) {
    var x = _a.x;
    return x.max - x.min;
  },
  height: function(_a) {
    var y = _a.y;
    return y.max - y.min;
  },
  top: function(_bbox, _a) {
    var top = _a.top;
    return parseFloat(top);
  },
  left: function(_bbox, _a) {
    var left = _a.left;
    return parseFloat(left);
  },
  bottom: function(_a, _b) {
    var y = _a.y;
    var top = _b.top;
    return parseFloat(top) + (y.max - y.min);
  },
  right: function(_a, _b) {
    var x = _a.x;
    var left = _b.left;
    return parseFloat(left) + (x.max - x.min);
  },
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
var convertChangedValueTypes = function(target, visualElement2, changedKeys) {
  var originBbox = visualElement2.measureViewportBox();
  var element = visualElement2.getInstance();
  var elementComputedStyle = getComputedStyle(element);
  var display = elementComputedStyle.display, top = elementComputedStyle.top, left = elementComputedStyle.left, bottom = elementComputedStyle.bottom, right = elementComputedStyle.right, transform2 = elementComputedStyle.transform;
  var originComputedStyle = { top, left, bottom, right, transform: transform2 };
  if (display === "none") {
    visualElement2.setStaticValue("display", target.display || "block");
  }
  visualElement2.syncRender();
  var targetBbox = visualElement2.measureViewportBox();
  changedKeys.forEach(function(key6) {
    var value = visualElement2.getValue(key6);
    setAndResetVelocity(value, positionalValues[key6](originBbox, originComputedStyle));
    target[key6] = positionalValues[key6](targetBbox, elementComputedStyle);
  });
  return target;
};
var checkAndConvertChangedValueTypes = function(visualElement2, target, origin, transitionEnd) {
  if (origin === void 0) {
    origin = {};
  }
  if (transitionEnd === void 0) {
    transitionEnd = {};
  }
  target = __assign({}, target);
  transitionEnd = __assign({}, transitionEnd);
  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
  var removedTransformValues = [];
  var hasAttemptedToRemoveTransformValues = false;
  var changedValueTypeKeys = [];
  targetPositionalKeys.forEach(function(key6) {
    var value = visualElement2.getValue(key6);
    if (!visualElement2.hasValue(key6))
      return;
    var from = origin[key6];
    var to = target[key6];
    var fromType = findDimensionValueType(from);
    var toType;
    if (isKeyframesTarget(to)) {
      var numKeyframes = to.length;
      for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {
        if (!toType) {
          toType = findDimensionValueType(to[i]);
          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), "Keyframes must be of the same dimension as the current value");
        } else {
          invariant(findDimensionValueType(to[i]) === toType, "All keyframes must be of the same type");
        }
      }
    } else {
      toType = findDimensionValueType(to);
    }
    if (fromType !== toType) {
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        var current = value.get();
        if (typeof current === "string") {
          value.set(parseFloat(current));
        }
        if (typeof to === "string") {
          target[key6] = parseFloat(to);
        } else if (Array.isArray(to) && toType === px) {
          target[key6] = to.map(parseFloat);
        }
      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {
        if (from === 0) {
          value.set(toType.transform(from));
        } else {
          target[key6] = fromType.transform(to);
        }
      } else {
        if (!hasAttemptedToRemoveTransformValues) {
          removedTransformValues = removeNonTranslationalTransform(visualElement2);
          hasAttemptedToRemoveTransformValues = true;
        }
        changedValueTypeKeys.push(key6);
        transitionEnd[key6] = transitionEnd[key6] !== void 0 ? transitionEnd[key6] : target[key6];
        setAndResetVelocity(value, to);
      }
    }
  });
  if (changedValueTypeKeys.length) {
    var convertedTarget = convertChangedValueTypes(target, visualElement2, changedValueTypeKeys);
    if (removedTransformValues.length) {
      removedTransformValues.forEach(function(_a) {
        var _b = __read(_a, 2), key6 = _b[0], value = _b[1];
        visualElement2.getValue(key6).set(value);
      });
    }
    visualElement2.syncRender();
    return { target: convertedTarget, transitionEnd };
  } else {
    return { target, transitionEnd };
  }
};
function unitConversion(visualElement2, target, origin, transitionEnd) {
  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement2, target, origin, transitionEnd) : { target, transitionEnd };
}

// ../../node_modules/framer-motion/dist/es/render/dom/utils/parse-dom-variant.js
var parseDomVariant = function(visualElement2, target, origin, transitionEnd) {
  var resolved = resolveCSSVariables(visualElement2, target, transitionEnd);
  target = resolved.target;
  transitionEnd = resolved.transitionEnd;
  return unitConversion(visualElement2, target, origin, transitionEnd);
};

// ../../node_modules/framer-motion/dist/es/render/html/visual-element.js
function getComputedStyle2(element) {
  return window.getComputedStyle(element);
}
var htmlConfig = {
  treeType: "dom",
  readValueFromInstance: function(domElement, key6) {
    var _a;
    if (isTransformProp(key6)) {
      var defaultType = getDefaultValueType(key6);
      return (_a = defaultType === null || defaultType === void 0 ? void 0 : defaultType.default) !== null && _a !== void 0 ? _a : 0;
    } else {
      var computedStyle = getComputedStyle2(domElement);
      return (isCSSVariable(key6) ? computedStyle.getPropertyValue(key6) : computedStyle[key6]) || 0;
    }
  },
  sortNodePosition: function(a2, b2) {
    return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;
  },
  getBaseTarget: function(props, key6) {
    var _a, _b;
    var defaultType = getDefaultValueType(key6);
    return (_b = (_a = props.style) === null || _a === void 0 ? void 0 : _a[key6]) !== null && _b !== void 0 ? _b : defaultType === null || defaultType === void 0 ? void 0 : defaultType.default;
  },
  measureViewportBox: function(element, _a) {
    var transformPagePoint = _a.transformPagePoint;
    return getBoundingBox(element, transformPagePoint);
  },
  resetTransform: function(element, domElement, props) {
    element.suspendHoverEvents();
    var transformTemplate2 = props.transformTemplate;
    domElement.style.transform = transformTemplate2 ? transformTemplate2({}, "") : "none";
    element.scheduleRender();
  },
  restoreTransform: function(instance, mutableState) {
    instance.style.transform = mutableState.style.transform;
  },
  removeValueFromRenderState: function(key6, _a) {
    var vars = _a.vars, style = _a.style;
    delete vars[key6];
    delete style[key6];
  },
  makeTargetAnimatable: function(element, _a, _b, isMounted) {
    var transformValues3 = _b.transformValues;
    if (isMounted === void 0) {
      isMounted = true;
    }
    var transition = _a.transition, transitionEnd = _a.transitionEnd, target = __rest(_a, ["transition", "transitionEnd"]);
    var origin = getOrigin(target, transition || {}, element);
    if (transformValues3) {
      if (transitionEnd)
        transitionEnd = transformValues3(transitionEnd);
      if (target)
        target = transformValues3(target);
      if (origin)
        origin = transformValues3(origin);
    }
    if (isMounted) {
      checkTargetForNewValues(element, target, origin);
      var parsed = parseDomVariant(element, target, origin, transitionEnd);
      transitionEnd = parsed.transitionEnd;
      target = parsed.target;
    }
    return __assign({
      transition,
      transitionEnd
    }, target);
  },
  scrapeMotionValuesFromProps,
  build: function(element, renderState, latestValues, projection, layoutState, options, props) {
    if (element.isVisible !== void 0) {
      renderState.style.visibility = element.isVisible ? "visible" : "hidden";
    }
    var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;
    buildHTMLStyles(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : void 0, isProjectionTranform ? buildLayoutProjectionTransformOrigin : void 0);
  },
  render: renderHTML
};
var htmlVisualElement = visualElement(htmlConfig);

// ../../node_modules/framer-motion/dist/es/render/svg/visual-element.js
var svgVisualElement = visualElement(__assign(__assign({}, htmlConfig), {
  getBaseTarget: function(props, key6) {
    return props[key6];
  },
  readValueFromInstance: function(domElement, key6) {
    var _a;
    if (isTransformProp(key6)) {
      return ((_a = getDefaultValueType(key6)) === null || _a === void 0 ? void 0 : _a.default) || 0;
    }
    key6 = !camelCaseAttributes.has(key6) ? camelToDash(key6) : key6;
    return domElement.getAttribute(key6);
  },
  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
  build: function(_element, renderState, latestValues, projection, layoutState, options, props) {
    var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;
    buildSVGAttrs(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : void 0, isProjectionTranform ? buildLayoutProjectionTransformOrigin : void 0);
  },
  render: renderSVG
}));

// ../../node_modules/framer-motion/dist/es/render/dom/create-visual-element.js
var createDomVisualElement = function(Component19, options) {
  return isSVGComponent(Component19) ? svgVisualElement(options, { enableHardwareAcceleration: false }) : htmlVisualElement(options, { enableHardwareAcceleration: true });
};

// ../../node_modules/framer-motion/dist/es/render/dom/motion.js
var featureBundle = __assign(__assign(__assign(__assign({}, animations), gestureAnimations), drag), layoutAnimations);
var motion = /* @__PURE__ */ createMotionProxy(function(Component19, config) {
  return createDomMotionConfig(Component19, config, featureBundle, createDomVisualElement);
});
function createDomMotionComponent(key6) {
  return createMotionComponent(createDomMotionConfig(key6, { forwardMotionProps: false }, featureBundle, createDomVisualElement));
}

// ../../node_modules/framer-motion/dist/es/render/dom/motion-minimal.js
var m = createMotionProxy(createDomMotionConfig);

// ../../node_modules/framer-motion/dist/es/components/AnimatePresence/index.js
import {
  Fragment as Fragment2,
  createElement as createElement6
} from "react";
import { useContext as useContext12, useRef as useRef6, cloneElement, Children, isValidElement } from "react";

// ../../node_modules/framer-motion/dist/es/utils/use-force-update.js
import { useCallback as useCallback2, useRef as useRef5, useState } from "react";
function useForceUpdate() {
  var unloadingRef = useRef5(false);
  var _a = __read(useState(0), 2), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];
  useUnmountEffect(function() {
    return unloadingRef.current = true;
  });
  return useCallback2(function() {
    !unloadingRef.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
}

// ../../node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.js
import {
  createElement as createElement5,
  useEffect as useEffect9
} from "react";
import { useMemo as useMemo4 } from "react";
var presenceId = 0;
function getPresenceId() {
  var id = presenceId;
  presenceId++;
  return id;
}
var PresenceChild = function(_a) {
  var children = _a.children, initial = _a.initial, isPresent2 = _a.isPresent, onExitComplete = _a.onExitComplete, custom = _a.custom, presenceAffectsLayout = _a.presenceAffectsLayout;
  var presenceChildren = useConstant(newChildrenMap);
  var id = useConstant(getPresenceId);
  var context = useMemo4(function() {
    return {
      id,
      initial,
      isPresent: isPresent2,
      custom,
      onExitComplete: function(childId) {
        presenceChildren.set(childId, true);
        var allComplete = true;
        presenceChildren.forEach(function(isComplete) {
          if (!isComplete)
            allComplete = false;
        });
        allComplete && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());
      },
      register: function(childId) {
        presenceChildren.set(childId, false);
        return function() {
          return presenceChildren.delete(childId);
        };
      }
    };
  }, presenceAffectsLayout ? void 0 : [isPresent2]);
  useMemo4(function() {
    presenceChildren.forEach(function(_, key6) {
      return presenceChildren.set(key6, false);
    });
  }, [isPresent2]);
  useEffect9(function() {
    !isPresent2 && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());
  }, [isPresent2]);
  return createElement5(PresenceContext.Provider, { value: context }, children);
};
function newChildrenMap() {
  return new Map();
}

// ../../node_modules/framer-motion/dist/es/components/AnimatePresence/index.js
function getChildKey(child) {
  return child.key || "";
}
function updateChildLookup(children, allChildren) {
  var seenChildren = true ? new Set() : null;
  children.forEach(function(child) {
    var key6 = getChildKey(child);
    if (seenChildren) {
      if (seenChildren.has(key6)) {
        console.warn('Children of AnimatePresence require unique keys. "' + key6 + '" is a duplicate.');
      }
      seenChildren.add(key6);
    }
    allChildren.set(key6, child);
  });
}
function onlyElements(children) {
  var filtered = [];
  Children.forEach(children, function(child) {
    if (isValidElement(child))
      filtered.push(child);
  });
  return filtered;
}
var AnimatePresence = function(_a) {
  var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter, _c = _a.presenceAffectsLayout, presenceAffectsLayout = _c === void 0 ? true : _c;
  var forceRender = useForceUpdate();
  var layoutContext = useContext12(SharedLayoutContext);
  if (isSharedLayout(layoutContext)) {
    forceRender = layoutContext.forceUpdate;
  }
  var isInitialRender = useRef6(true);
  var filteredChildren = onlyElements(children);
  var presentChildren = useRef6(filteredChildren);
  var allChildren = useRef6(new Map()).current;
  var exiting = useRef6(new Set()).current;
  updateChildLookup(filteredChildren, allChildren);
  if (isInitialRender.current) {
    isInitialRender.current = false;
    return createElement6(Fragment2, null, filteredChildren.map(function(child) {
      return createElement6(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? void 0 : false, presenceAffectsLayout }, child);
    }));
  }
  var childrenToRender = __spreadArray([], __read(filteredChildren));
  var presentKeys = presentChildren.current.map(getChildKey);
  var targetKeys = filteredChildren.map(getChildKey);
  var numPresent = presentKeys.length;
  for (var i = 0; i < numPresent; i++) {
    var key6 = presentKeys[i];
    if (targetKeys.indexOf(key6) === -1) {
      exiting.add(key6);
    } else {
      exiting.delete(key6);
    }
  }
  if (exitBeforeEnter && exiting.size) {
    childrenToRender = [];
  }
  exiting.forEach(function(key7) {
    if (targetKeys.indexOf(key7) !== -1)
      return;
    var child = allChildren.get(key7);
    if (!child)
      return;
    var insertionIndex = presentKeys.indexOf(key7);
    var onExit = function() {
      allChildren.delete(key7);
      exiting.delete(key7);
      var removeIndex = presentChildren.current.findIndex(function(presentChild) {
        return presentChild.key === key7;
      });
      presentChildren.current.splice(removeIndex, 1);
      if (!exiting.size) {
        presentChildren.current = filteredChildren;
        forceRender();
        onExitComplete && onExitComplete();
      }
    };
    childrenToRender.splice(insertionIndex, 0, createElement6(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom, presenceAffectsLayout }, child));
  });
  childrenToRender = childrenToRender.map(function(child) {
    var key7 = child.key;
    return exiting.has(key7) ? child : createElement6(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout }, child);
  });
  presentChildren.current = childrenToRender;
  if (exitBeforeEnter && childrenToRender.length > 1) {
    console.warn("You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.");
  }
  return createElement6(Fragment2, null, exiting.size ? childrenToRender : childrenToRender.map(function(child) {
    return cloneElement(child);
  }));
};

// ../../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/index.js
import {
  Component as Component2,
  createElement as createElement7
} from "react";

// ../../node_modules/framer-motion/dist/es/animation/animate.js
function animate2(from, to, transition) {
  if (transition === void 0) {
    transition = {};
  }
  var value = isMotionValue(from) ? from : motionValue(from);
  startAnimation("", value, to, transition);
  return {
    stop: function() {
      return value.stop();
    }
  };
}

// ../../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/crossfader.js
function createCrossfader() {
  var progress2 = motionValue(1);
  var options = {
    lead: void 0,
    follow: void 0,
    crossfadeOpacity: false,
    preserveFollowOpacity: false
  };
  var prevOptions = __assign({}, options);
  var leadState = {};
  var followState = {};
  var isActive = false;
  var finalCrossfadeFrame = null;
  var prevUpdate = 0;
  function startCrossfadeAnimation(target, transition) {
    var lead = options.lead, follow = options.follow;
    isActive = true;
    finalCrossfadeFrame = null;
    var hasUpdated = false;
    var onUpdate = function() {
      hasUpdated = true;
      lead && lead.scheduleRender();
      follow && follow.scheduleRender();
    };
    var onComplete = function() {
      isActive = false;
      finalCrossfadeFrame = getFrameData().timestamp;
    };
    transition = transition && getValueTransition(transition, "crossfade");
    return animate2(progress2, target, __assign(__assign({}, transition), { onUpdate, onComplete: function() {
      if (!hasUpdated) {
        progress2.set(target);
        es_default.read(onComplete);
      } else {
        onComplete();
      }
      onUpdate();
    } }));
  }
  function updateCrossfade() {
    var _a, _b;
    var timestamp = getFrameData().timestamp;
    var lead = options.lead, follow = options.follow;
    if (timestamp === prevUpdate || !lead)
      return;
    prevUpdate = timestamp;
    var latestLeadValues = lead.getLatestValues();
    Object.assign(leadState, latestLeadValues);
    var latestFollowValues = follow ? follow.getLatestValues() : options.prevValues;
    Object.assign(followState, latestFollowValues);
    var p = progress2.get();
    var leadTargetOpacity = (_a = latestLeadValues.opacity) !== null && _a !== void 0 ? _a : 1;
    var followTargetOpacity = (_b = latestFollowValues === null || latestFollowValues === void 0 ? void 0 : latestFollowValues.opacity) !== null && _b !== void 0 ? _b : 1;
    if (options.crossfadeOpacity && follow) {
      leadState.opacity = mix(follow.isVisible !== false ? 0 : followTargetOpacity, leadTargetOpacity, easeCrossfadeIn(p));
      followState.opacity = options.preserveFollowOpacity ? followTargetOpacity : mix(followTargetOpacity, 0, easeCrossfadeOut(p));
    } else if (!follow) {
      leadState.opacity = mix(followTargetOpacity, leadTargetOpacity, p);
    }
    mixValues(leadState, followState, latestLeadValues, latestFollowValues || {}, Boolean(follow), p);
  }
  return {
    isActive: function() {
      return leadState && (isActive || getFrameData().timestamp === finalCrossfadeFrame);
    },
    fromLead: function(transition) {
      return startCrossfadeAnimation(0, transition);
    },
    toLead: function(transition) {
      var initialProgress = 0;
      if (!options.prevValues && !options.follow) {
        initialProgress = 1;
      } else if (prevOptions.lead === options.follow && prevOptions.follow === options.lead) {
        initialProgress = 1 - progress2.get();
      }
      progress2.set(initialProgress);
      return startCrossfadeAnimation(1, transition);
    },
    reset: function() {
      return progress2.set(1);
    },
    stop: function() {
      return progress2.stop();
    },
    getCrossfadeState: function(element) {
      updateCrossfade();
      if (element === options.lead) {
        return leadState;
      } else if (element === options.follow) {
        return followState;
      }
    },
    setOptions: function(newOptions) {
      prevOptions = options;
      options = newOptions;
      leadState = {};
      followState = {};
    },
    getLatestValues: function() {
      return leadState;
    }
  };
}
var easeCrossfadeIn = compress(0, 0.5, circOut);
var easeCrossfadeOut = compress(0.5, 0.95, linear);
function compress(min, max, easing) {
  return function(p) {
    if (p < min)
      return 0;
    if (p > max)
      return 1;
    return easing(progress(min, max, p));
  };
}
var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
var numBorders = borders.length;
function mixValues(leadState, followState, latestLeadValues, latestFollowValues, hasFollowElement, p) {
  for (var i = 0; i < numBorders; i++) {
    var borderLabel = "border" + borders[i] + "Radius";
    var followRadius = getRadius(latestFollowValues, borderLabel);
    var leadRadius = getRadius(latestLeadValues, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    if (typeof followRadius === "number" && typeof leadRadius === "number") {
      var radius = Math.max(mix(followRadius, leadRadius, p), 0);
      leadState[borderLabel] = followState[borderLabel] = radius;
    }
  }
  if (latestFollowValues.rotate || latestLeadValues.rotate) {
    var rotate = mix(latestFollowValues.rotate || 0, latestLeadValues.rotate || 0, p);
    leadState.rotate = followState.rotate = rotate;
  }
  if (!hasFollowElement && latestLeadValues.backgroundColor && latestFollowValues.backgroundColor) {
    leadState.backgroundColor = followState.backgroundColor = mixColor(latestFollowValues.backgroundColor, latestLeadValues.backgroundColor)(p);
  }
}
function getRadius(values, radiusName) {
  var _a;
  return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;
}

// ../../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/stack.js
function layoutStack() {
  var stack = new Set();
  var state = { leadIsExiting: false };
  var prevState = __assign({}, state);
  var prevValues;
  var prevViewportBox;
  var prevDragCursor;
  var crossfader = createCrossfader();
  var needsCrossfadeAnimation = false;
  function getFollowViewportBox() {
    return state.follow ? state.follow.prevViewportBox : prevViewportBox;
  }
  function getFollowLayout() {
    var _a;
    return (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getLayoutState().layout;
  }
  return {
    add: function(element) {
      element.setCrossfader(crossfader);
      stack.add(element);
      if (prevDragCursor)
        element.prevDragCursor = prevDragCursor;
      if (!state.lead)
        state.lead = element;
    },
    remove: function(element) {
      stack.delete(element);
    },
    getLead: function() {
      return state.lead;
    },
    updateSnapshot: function() {
      if (!state.lead)
        return;
      prevValues = crossfader.isActive() ? crossfader.getLatestValues() : state.lead.getLatestValues();
      prevViewportBox = state.lead.prevViewportBox;
      var dragControls = elementDragControls.get(state.lead);
      if (dragControls && dragControls.isDragging) {
        prevDragCursor = dragControls.cursorProgress;
      }
    },
    clearSnapshot: function() {
      prevDragCursor = prevViewportBox = void 0;
    },
    updateLeadAndFollow: function() {
      var _a;
      prevState = __assign({}, state);
      var lead;
      var follow;
      var order2 = Array.from(stack);
      for (var i = order2.length; i--; i >= 0) {
        var element = order2[i];
        if (lead)
          follow !== null && follow !== void 0 ? follow : follow = element;
        lead !== null && lead !== void 0 ? lead : lead = element;
        if (lead && follow)
          break;
      }
      state.lead = lead;
      state.follow = follow;
      state.leadIsExiting = ((_a = state.lead) === null || _a === void 0 ? void 0 : _a.presence) === Presence.Exiting;
      crossfader.setOptions({
        lead,
        follow,
        prevValues,
        crossfadeOpacity: (follow === null || follow === void 0 ? void 0 : follow.isPresenceRoot) || (lead === null || lead === void 0 ? void 0 : lead.isPresenceRoot)
      });
      if (state.lead !== prevState.follow && (prevState.lead !== state.lead || prevState.leadIsExiting !== state.leadIsExiting)) {
        needsCrossfadeAnimation = true;
      }
    },
    animate: function(child, shouldCrossfade) {
      var _a;
      if (shouldCrossfade === void 0) {
        shouldCrossfade = false;
      }
      if (child === state.lead) {
        if (shouldCrossfade) {
          child.pointTo(state.lead);
        } else {
          child.setVisibility(true);
        }
        var config = {};
        var prevParent = (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getProjectionParent();
        if (prevParent) {
          config.prevParent = prevParent;
        }
        if (child.presence === Presence.Entering) {
          config.originBox = getFollowViewportBox();
        } else if (child.presence === Presence.Exiting) {
          config.targetBox = getFollowLayout();
        }
        if (needsCrossfadeAnimation) {
          needsCrossfadeAnimation = false;
          var transition = child.getDefaultTransition();
          child.presence === Presence.Entering ? crossfader.toLead(transition) : crossfader.fromLead(transition);
        }
        child.notifyLayoutReady(config);
      } else {
        if (shouldCrossfade) {
          state.lead && child.pointTo(state.lead);
        } else {
          child.setVisibility(false);
        }
      }
    }
  };
}

// ../../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/rotate.js
function resetRotate(child) {
  var hasRotate = false;
  var resetValues = {};
  for (var i = 0; i < transformAxes.length; i++) {
    var axis = transformAxes[i];
    var key6 = "rotate" + axis;
    if (!child.hasValue(key6) || child.getStaticValue(key6) === 0)
      continue;
    hasRotate = true;
    resetValues[key6] = child.getStaticValue(key6);
    child.setStaticValue(key6, 0);
  }
  if (!hasRotate)
    return;
  child.syncRender();
  for (var key6 in resetValues) {
    child.setStaticValue(key6, resetValues[key6]);
  }
  child.scheduleRender();
}

// ../../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/index.js
var AnimateSharedLayout = function(_super) {
  __extends(AnimateSharedLayout2, _super);
  function AnimateSharedLayout2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.children = new Set();
    _this.stacks = new Map();
    _this.hasMounted = false;
    _this.updateScheduled = false;
    _this.renderScheduled = false;
    _this.syncContext = __assign(__assign({}, createBatcher()), { syncUpdate: function(force) {
      return _this.scheduleUpdate(force);
    }, forceUpdate: function() {
      _this.syncContext = __assign({}, _this.syncContext);
      _this.scheduleUpdate(true);
    }, register: function(child) {
      return _this.addChild(child);
    }, remove: function(child) {
      return _this.removeChild(child);
    } });
    return _this;
  }
  AnimateSharedLayout2.prototype.componentDidMount = function() {
    this.hasMounted = true;
  };
  AnimateSharedLayout2.prototype.componentDidUpdate = function() {
    this.startLayoutAnimation();
  };
  AnimateSharedLayout2.prototype.shouldComponentUpdate = function() {
    this.renderScheduled = true;
    return true;
  };
  AnimateSharedLayout2.prototype.startLayoutAnimation = function() {
    var _this = this;
    this.renderScheduled = this.updateScheduled = false;
    var type = this.props.type;
    this.children.forEach(function(child) {
      if (!child.isPresent) {
        child.presence = Presence.Exiting;
      } else if (child.presence !== Presence.Entering) {
        child.presence = child.presence === Presence.Exiting ? Presence.Entering : Presence.Present;
      }
    });
    this.updateStacks();
    var handler = {
      layoutReady: function(child) {
        if (child.getLayoutId() !== void 0) {
          var stack = _this.getStack(child);
          stack.animate(child, type === "crossfade");
        } else {
          child.notifyLayoutReady();
        }
      },
      parent: this.context.visualElement
    };
    this.children.forEach(function(child) {
      return _this.syncContext.add(child);
    });
    this.syncContext.flush(handler);
    this.stacks.forEach(function(stack) {
      return stack.clearSnapshot();
    });
  };
  AnimateSharedLayout2.prototype.updateStacks = function() {
    this.stacks.forEach(function(stack) {
      return stack.updateLeadAndFollow();
    });
  };
  AnimateSharedLayout2.prototype.scheduleUpdate = function(force) {
    if (force === void 0) {
      force = false;
    }
    if (!(force || !this.updateScheduled))
      return;
    this.updateScheduled = true;
    this.children.forEach(function(child) {
      resetRotate(child);
      if (child.shouldResetTransform())
        child.resetTransform();
    });
    this.children.forEach(snapshotViewportBox);
    this.stacks.forEach(function(stack) {
      return stack.updateSnapshot();
    });
    if (force || !this.renderScheduled) {
      this.renderScheduled = true;
      this.forceUpdate();
    }
  };
  AnimateSharedLayout2.prototype.addChild = function(child) {
    this.children.add(child);
    this.addToStack(child);
    child.presence = this.hasMounted ? Presence.Entering : Presence.Present;
  };
  AnimateSharedLayout2.prototype.removeChild = function(child) {
    this.scheduleUpdate();
    this.children.delete(child);
    this.removeFromStack(child);
  };
  AnimateSharedLayout2.prototype.addToStack = function(child) {
    var stack = this.getStack(child);
    stack === null || stack === void 0 ? void 0 : stack.add(child);
  };
  AnimateSharedLayout2.prototype.removeFromStack = function(child) {
    var stack = this.getStack(child);
    stack === null || stack === void 0 ? void 0 : stack.remove(child);
  };
  AnimateSharedLayout2.prototype.getStack = function(child) {
    var id = child.getLayoutId();
    if (id === void 0)
      return;
    !this.stacks.has(id) && this.stacks.set(id, layoutStack());
    return this.stacks.get(id);
  };
  AnimateSharedLayout2.prototype.render = function() {
    return createElement7(SharedLayoutContext.Provider, { value: this.syncContext }, this.props.children);
  };
  AnimateSharedLayout2.contextType = MotionContext;
  return AnimateSharedLayout2;
}(Component2);

// ../../node_modules/framer-motion/dist/es/components/MotionConfig/index.js
import {
  createElement as createElement8
} from "react";
import { useContext as useContext13, useMemo as useMemo5 } from "react";
function MotionConfig(_a) {
  var children = _a.children, config = __rest(_a, ["children"]);
  config = __assign(__assign({}, useContext13(MotionConfigContext)), config);
  config.isStatic = useConstant(function() {
    return config.isStatic;
  });
  var transitionDependency = typeof config.transition === "object" ? config.transition.toString() : "";
  var context = useMemo5(function() {
    return config;
  }, [
    transitionDependency,
    config.transformPagePoint
  ]);
  return createElement8(MotionConfigContext.Provider, { value: context }, children);
}

// ../../node_modules/framer-motion/dist/es/components/LazyMotion/index.js
import {
  createElement as createElement9
} from "react";
import { useState as useState2, useRef as useRef7, useEffect as useEffect10 } from "react";
function LazyMotion(_a) {
  var children = _a.children, features = _a.features, _b = _a.strict, strict = _b === void 0 ? false : _b;
  var _c = __read(useState2(!isLazyBundle(features)), 2), setIsLoaded = _c[1];
  var loadedRenderer = useRef7(void 0);
  if (!isLazyBundle(features)) {
    var renderer = features.renderer, loadedFeatures = __rest(features, ["renderer"]);
    loadedRenderer.current = renderer;
    loadFeatures(loadedFeatures);
  }
  useEffect10(function() {
    if (isLazyBundle(features)) {
      features().then(function(_a2) {
        var renderer2 = _a2.renderer, loadedFeatures2 = __rest(_a2, ["renderer"]);
        loadFeatures(loadedFeatures2);
        loadedRenderer.current = renderer2;
        setIsLoaded(true);
      });
    }
  }, []);
  return createElement9(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict } }, children);
}
function isLazyBundle(features) {
  return typeof features === "function";
}

// ../../node_modules/framer-motion/dist/es/render/dom/features-animation.js
var domAnimation = __assign(__assign({ renderer: createDomVisualElement }, animations), gestureAnimations);

// ../../node_modules/framer-motion/dist/es/render/dom/features-max.js
var domMax = __assign(__assign(__assign({}, domAnimation), drag), layoutAnimations);

// ../../node_modules/framer-motion/dist/es/value/use-motion-value.js
import { useContext as useContext14, useState as useState3, useEffect as useEffect11 } from "react";
function useMotionValue(initial) {
  var value = useConstant(function() {
    return motionValue(initial);
  });
  var isStatic = useContext14(MotionConfigContext).isStatic;
  if (isStatic) {
    var _a = __read(useState3(initial), 2), setLatest_1 = _a[1];
    useEffect11(function() {
      return value.onChange(setLatest_1);
    }, []);
  }
  return value;
}

// ../../node_modules/framer-motion/dist/es/value/use-on-change.js
import { useEffect as useEffect12 } from "react";
function useOnChange(value, callback) {
  useEffect12(function() {
    if (isMotionValue(value))
      return value.onChange(callback);
  }, [callback]);
}
function useMultiOnChange(values, handler) {
  useEffect12(function() {
    var subscriptions = values.map(function(value) {
      return value.onChange(handler);
    });
    return function() {
      return subscriptions.forEach(function(unsubscribe) {
        return unsubscribe();
      });
    };
  });
}

// ../../node_modules/framer-motion/dist/es/value/use-combine-values.js
function useCombineMotionValues(values, combineValues) {
  var value = useMotionValue(combineValues());
  var updateValue = function() {
    return value.set(combineValues());
  };
  updateValue();
  useMultiOnChange(values, function() {
    return es_default.update(updateValue, false, true);
  });
  return value;
}

// ../../node_modules/framer-motion/dist/es/value/use-motion-template.js
function useMotionTemplate(fragments) {
  var values = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    values[_i - 1] = arguments[_i];
  }
  var numFragments = fragments.length;
  function buildValue() {
    var output = "";
    for (var i = 0; i < numFragments; i++) {
      output += fragments[i];
      var value = values[i];
      if (value)
        output += values[i].get();
    }
    return output;
  }
  return useCombineMotionValues(values, buildValue);
}

// ../../node_modules/framer-motion/dist/es/utils/transform.js
var isCustomValueType = function(v) {
  return typeof v === "object" && v.mix;
};
var getMixer2 = function(v) {
  return isCustomValueType(v) ? v.mix : void 0;
};
function transform() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var useImmediate = !Array.isArray(args[0]);
  var argOffset = useImmediate ? 0 : -1;
  var inputValue = args[0 + argOffset];
  var inputRange = args[1 + argOffset];
  var outputRange = args[2 + argOffset];
  var options = args[3 + argOffset];
  var interpolator = interpolate(inputRange, outputRange, __assign({ mixer: getMixer2(outputRange[0]) }, options));
  return useImmediate ? interpolator(inputValue) : interpolator;
}

// ../../node_modules/framer-motion/dist/es/value/use-transform.js
function useTransform(input, inputRangeOrTransformer, outputRange, options) {
  var transformer = typeof inputRangeOrTransformer === "function" ? inputRangeOrTransformer : transform(inputRangeOrTransformer, outputRange, options);
  return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([input], function(_a) {
    var _b = __read(_a, 1), latest = _b[0];
    return transformer(latest);
  });
}
function useListTransform(values, transformer) {
  var latest = useConstant(function() {
    return [];
  });
  return useCombineMotionValues(values, function() {
    latest.length = 0;
    var numValues = values.length;
    for (var i = 0; i < numValues; i++) {
      latest[i] = values[i].get();
    }
    return transformer(latest);
  });
}

// ../../node_modules/framer-motion/dist/es/value/use-spring.js
import { useContext as useContext15, useRef as useRef8, useMemo as useMemo6 } from "react";
function useSpring(source, config) {
  if (config === void 0) {
    config = {};
  }
  var isStatic = useContext15(MotionConfigContext).isStatic;
  var activeSpringAnimation = useRef8(null);
  var value = useMotionValue(isMotionValue(source) ? source.get() : source);
  useMemo6(function() {
    return value.attach(function(v, set) {
      if (isStatic)
        return set(v);
      if (activeSpringAnimation.current) {
        activeSpringAnimation.current.stop();
      }
      activeSpringAnimation.current = animate(__assign(__assign({ from: value.get(), to: v, velocity: value.getVelocity() }, config), { onUpdate: set }));
      return value.get();
    });
  }, Object.values(config));
  useOnChange(source, function(v) {
    return value.set(parseFloat(v));
  });
  return value;
}

// ../../node_modules/framer-motion/dist/es/value/use-velocity.js
import { useEffect as useEffect13 } from "react";
function useVelocity(value) {
  var velocity = useMotionValue(value.getVelocity());
  useEffect13(function() {
    return value.velocityUpdateSubscribers.add(function(newVelocity) {
      velocity.set(newVelocity);
    });
  }, [value]);
  return velocity;
}

// ../../node_modules/framer-motion/dist/es/value/scroll/utils.js
function createScrollMotionValues() {
  return {
    scrollX: motionValue(0),
    scrollY: motionValue(0),
    scrollXProgress: motionValue(0),
    scrollYProgress: motionValue(0)
  };
}
function setProgress(offset, maxOffset, value) {
  value.set(!offset || !maxOffset ? 0 : offset / maxOffset);
}
function createScrollUpdater(values, getOffsets) {
  var update = function() {
    var _a = getOffsets(), xOffset = _a.xOffset, yOffset = _a.yOffset, xMaxOffset = _a.xMaxOffset, yMaxOffset = _a.yMaxOffset;
    values.scrollX.set(xOffset);
    values.scrollY.set(yOffset);
    setProgress(xOffset, xMaxOffset, values.scrollXProgress);
    setProgress(yOffset, yMaxOffset, values.scrollYProgress);
  };
  update();
  return update;
}

// ../../node_modules/framer-motion/dist/es/value/scroll/use-element-scroll.js
var getElementScrollOffsets = function(element) {
  return function() {
    return {
      xOffset: element.scrollLeft,
      yOffset: element.scrollTop,
      xMaxOffset: element.scrollWidth - element.offsetWidth,
      yMaxOffset: element.scrollHeight - element.offsetHeight
    };
  };
};
function useElementScroll(ref) {
  var values = useConstant(createScrollMotionValues);
  useIsomorphicLayoutEffect(function() {
    var element = ref.current;
    invariant(!!element, "ref provided to useScroll must be passed into a HTML element.");
    if (!element)
      return;
    var updateScrollValues = createScrollUpdater(values, getElementScrollOffsets(element));
    var scrollListener = addDomEvent(element, "scroll", updateScrollValues, { passive: true });
    var resizeListener = addDomEvent(element, "resize", updateScrollValues);
    return function() {
      scrollListener && scrollListener();
      resizeListener && resizeListener();
    };
  }, []);
  return values;
}

// ../../node_modules/framer-motion/dist/es/value/scroll/use-viewport-scroll.js
var viewportScrollValues;
function getViewportScrollOffsets() {
  return {
    xOffset: window.pageXOffset,
    yOffset: window.pageYOffset,
    xMaxOffset: document.body.clientWidth - window.innerWidth,
    yMaxOffset: document.body.clientHeight - window.innerHeight
  };
}
var hasListeners = false;
function addEventListeners() {
  hasListeners = true;
  if (typeof window === "undefined")
    return;
  var updateScrollValues = createScrollUpdater(viewportScrollValues, getViewportScrollOffsets);
  addDomEvent(window, "scroll", updateScrollValues, { passive: true });
  addDomEvent(window, "resize", updateScrollValues);
}
function useViewportScroll() {
  if (!viewportScrollValues) {
    viewportScrollValues = createScrollMotionValues();
  }
  useIsomorphicLayoutEffect(function() {
    !hasListeners && addEventListeners();
  }, []);
  return viewportScrollValues;
}

// ../../node_modules/framer-motion/dist/es/utils/use-reduced-motion.js
import { useState as useState4 } from "react";
var prefersReducedMotion;
function initPrefersReducedMotion() {
  prefersReducedMotion = motionValue(null);
  if (typeof window === "undefined")
    return;
  if (window.matchMedia) {
    var motionMediaQuery_1 = window.matchMedia("(prefers-reduced-motion)");
    var setReducedMotionPreferences = function() {
      return prefersReducedMotion.set(motionMediaQuery_1.matches);
    };
    motionMediaQuery_1.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.set(false);
  }
}
function useReducedMotion() {
  !prefersReducedMotion && initPrefersReducedMotion();
  var _a = __read(useState4(prefersReducedMotion.get()), 2), shouldReduceMotion = _a[0], setShouldReduceMotion = _a[1];
  useOnChange(prefersReducedMotion, setShouldReduceMotion);
  return shouldReduceMotion;
}

// ../../node_modules/framer-motion/dist/es/animation/animation-controls.js
function animationControls() {
  var hasMounted = false;
  var pendingAnimations = [];
  var subscribers = new Set();
  var controls = {
    subscribe: function(visualElement2) {
      subscribers.add(visualElement2);
      return function() {
        return void subscribers.delete(visualElement2);
      };
    },
    start: function(definition, transitionOverride) {
      if (hasMounted) {
        var animations_1 = [];
        subscribers.forEach(function(visualElement2) {
          animations_1.push(animateVisualElement(visualElement2, definition, {
            transitionOverride
          }));
        });
        return Promise.all(animations_1);
      } else {
        return new Promise(function(resolve) {
          pendingAnimations.push({
            animation: [definition, transitionOverride],
            resolve
          });
        });
      }
    },
    set: function(definition) {
      invariant(hasMounted, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.");
      return subscribers.forEach(function(visualElement2) {
        setValues(visualElement2, definition);
      });
    },
    stop: function() {
      subscribers.forEach(function(visualElement2) {
        stopAnimation(visualElement2);
      });
    },
    mount: function() {
      hasMounted = true;
      pendingAnimations.forEach(function(_a) {
        var animation = _a.animation, resolve = _a.resolve;
        controls.start.apply(controls, __spreadArray([], __read(animation))).then(resolve);
      });
      return function() {
        hasMounted = false;
        controls.stop();
      };
    }
  };
  return controls;
}

// ../../node_modules/framer-motion/dist/es/animation/use-animation.js
import { useEffect as useEffect14 } from "react";
function useAnimation() {
  var controls = useConstant(animationControls);
  useEffect14(controls.mount, []);
  return controls;
}

// ../../node_modules/framer-motion/dist/es/utils/use-cycle.js
import { useRef as useRef9, useState as useState5 } from "react";
function useCycle() {
  var items = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    items[_i] = arguments[_i];
  }
  var index = useRef9(0);
  var _a = __read(useState5(items[index.current]), 2), item = _a[0], setItem = _a[1];
  return [
    item,
    function(next) {
      index.current = typeof next !== "number" ? wrap(0, items.length, index.current + 1) : next;
      setItem(items[index.current]);
    }
  ];
}

// ../../node_modules/framer-motion/dist/es/gestures/drag/use-drag-controls.js
var DragControls = function() {
  function DragControls2() {
    this.componentControls = new Set();
  }
  DragControls2.prototype.subscribe = function(controls) {
    var _this = this;
    this.componentControls.add(controls);
    return function() {
      return _this.componentControls.delete(controls);
    };
  };
  DragControls2.prototype.start = function(event, options) {
    this.componentControls.forEach(function(controls) {
      controls.start(event.nativeEvent || event, options);
    });
  };
  DragControls2.prototype.updateConstraints = function() {
    this.componentControls.forEach(function(controls) {
      controls.updateLayoutMeasurements();
      controls.resolveDragConstraints();
    });
  };
  return DragControls2;
}();
var createDragControls = function() {
  return new DragControls();
};
function useDragControls() {
  return useConstant(createDragControls);
}

// ../../node_modules/framer-motion/dist/es/animation/use-animated-state.js
import { useState as useState6, useEffect as useEffect15 } from "react";
var createObject = function() {
  return {};
};
var stateVisualElement = visualElement({
  build: function() {
  },
  measureViewportBox: axisBox,
  resetTransform: function() {
  },
  restoreTransform: function() {
  },
  removeValueFromRenderState: function() {
  },
  render: function() {
  },
  scrapeMotionValuesFromProps: createObject,
  readValueFromInstance: function(_state, key6, options) {
    return options.initialState[key6] || 0;
  },
  makeTargetAnimatable: function(element, _a) {
    var transition = _a.transition, transitionEnd = _a.transitionEnd, target = __rest(_a, ["transition", "transitionEnd"]);
    var origin = getOrigin(target, transition || {}, element);
    checkTargetForNewValues(element, target, origin);
    return __assign({ transition, transitionEnd }, target);
  }
});
var useVisualState = makeUseVisualState({
  scrapeMotionValuesFromProps: createObject,
  createRenderState: createObject
});
function useAnimatedState(initialState2) {
  var _a = __read(useState6(initialState2), 2), animationState = _a[0], setAnimationState = _a[1];
  var visualState = useVisualState({}, false);
  var element = useConstant(function() {
    return stateVisualElement({ props: {}, visualState }, { initialState: initialState2 });
  });
  useEffect15(function() {
    element.mount({});
    return element.unmount();
  }, []);
  useEffect15(function() {
    element.setProps({
      onUpdate: function(v) {
        return setAnimationState(__assign({}, v));
      }
    });
  });
  var startAnimation3 = useConstant(function() {
    return function(animationDefinition) {
      return animateVisualElement(element, animationDefinition);
    };
  });
  return [animationState, startAnimation3];
}

// ../../node_modules/framer-motion/dist/es/value/use-inverted-scale.js
var maxScale = 1e5;
var invertScale = function(scale2) {
  return scale2 > 1e-3 ? 1 / scale2 : maxScale;
};
var hasWarned = false;
function useInvertedScale(scale2) {
  var parentScaleX = useMotionValue(1);
  var parentScaleY = useMotionValue(1);
  var visualElement2 = useVisualElementContext();
  invariant(!!(scale2 || visualElement2), "If no scale values are provided, useInvertedScale must be used within a child of another motion component.");
  warning(hasWarned, "useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.");
  hasWarned = true;
  if (scale2) {
    parentScaleX = scale2.scaleX || parentScaleX;
    parentScaleY = scale2.scaleY || parentScaleY;
  } else if (visualElement2) {
    parentScaleX = visualElement2.getValue("scaleX", 1);
    parentScaleY = visualElement2.getValue("scaleY", 1);
  }
  var scaleX = useTransform(parentScaleX, invertScale);
  var scaleY = useTransform(parentScaleY, invertScale);
  return { scaleX, scaleY };
}

// src/animation/Motion/addChildHack.ts
MotionValue.prototype.addChild = function({ transformer = (v) => v }) {
  const child = new MotionValue(transformer(this.get()));
  this.onChange((v) => child.set(transformer(v)));
  return child;
};

// src/components/Scroll/Scroll.tsx
import {
  createElement as createElement25,
  forwardRef as forwardRef6
} from "react";

// src/render/types/PropertyControls.ts
var ControlType;
(function(ControlType2) {
  ControlType2["Boolean"] = "boolean";
  ControlType2["Number"] = "number";
  ControlType2["String"] = "string";
  ControlType2["FusedNumber"] = "fusednumber";
  ControlType2["Enum"] = "enum";
  ControlType2["SegmentedEnum"] = "segmentedenum";
  ControlType2["Color"] = "color";
  ControlType2["Image"] = "image";
  ControlType2["File"] = "file";
  ControlType2["ComponentInstance"] = "componentinstance";
  ControlType2["Array"] = "array";
  ControlType2["EventHandler"] = "eventhandler";
  ControlType2["Transition"] = "transition";
  ControlType2["Object"] = "object";
})(ControlType || (ControlType = {}));

// src/utils/addPropertyControls.ts
function addPropertyControls(component, propertyControls) {
  Object.assign(component, { propertyControls });
}
function getPropertyControls(component) {
  return component.propertyControls;
}

// src/components/Scroll/EmulatedScroll.tsx
import {
  Children as Children6,
  cloneElement as cloneElement4,
  createElement as createElement23,
  forwardRef as forwardRef4,
  useCallback as useCallback6,
  useEffect as useEffect17,
  useLayoutEffect as useLayoutEffect5
} from "react";
import { useMemo as useMemo10, useRef as useRef16, useCallback as useCallback7 } from "react";

// src/render/presentation/Frame/FrameWithMotion.tsx
var import_is_prop_valid = __toModule(require_is_prop_valid_browser_cjs());
import {
  Children as Children3,
  Fragment as Fragment5,
  createElement as createElement15
} from "react";
import { forwardRef as forwardRef2, useContext as useContext20, useRef as useRef14 } from "react";

// src/utils/safeWindow.ts
var mockWindow = {
  addEventListener: () => {
  },
  removeEventListener: () => {
  },
  dispatchEvent: () => false,
  onpointerdown: false,
  onpointermove: false,
  onpointerup: false,
  ontouchstart: false,
  ontouchmove: false,
  ontouchend: false,
  onmousedown: false,
  onmousemove: false,
  onmouseup: false,
  devicePixelRatio: 1,
  scrollX: 0,
  scrollY: 0,
  location: {
    href: ""
  },
  setTimeout: () => 0,
  clearTimeout: () => {
  },
  setInterval: () => 0,
  clearInterval: () => {
  },
  webkitConvertPointFromPageToNode: (_, pt) => pt
};
var safeWindow = typeof window === "undefined" ? mockWindow : window;

// src/render/style/BorderComponent.tsx
import {
  createElement as createElement10
} from "react";
function collectBorderStyleForProps(props, style, collapseEqualBorders = true) {
  const { borderWidth, borderStyle, borderColor } = props;
  if (!borderWidth) {
    return;
  }
  let borderTop;
  let borderBottom;
  let borderLeft;
  let borderRight;
  if (typeof borderWidth === "number") {
    borderTop = borderBottom = borderLeft = borderRight = borderWidth;
  } else {
    borderTop = borderWidth.top || 0;
    borderBottom = borderWidth.bottom || 0;
    borderLeft = borderWidth.left || 0;
    borderRight = borderWidth.right || 0;
  }
  if (borderTop === 0 && borderBottom === 0 && borderLeft === 0 && borderRight === 0) {
    return;
  }
  if (collapseEqualBorders && borderTop === borderBottom && borderTop === borderLeft && borderTop === borderRight) {
    style.border = `${borderTop}px ${borderStyle} ${borderColor}`;
    return;
  }
  style.borderStyle = props.borderStyle;
  style.borderColor = props.borderColor;
  style.borderTopWidth = `${borderTop}px`;
  style.borderBottomWidth = `${borderBottom}px`;
  style.borderLeftWidth = `${borderLeft}px`;
  style.borderRightWidth = `${borderRight}px`;
}
function Border(props) {
  const layoutId = props.layoutId ? `${props.layoutId}-border` : void 0;
  if (!props.borderWidth) {
    return null;
  }
  const style = {
    position: "absolute",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    borderRadius: "inherit",
    pointerEvents: "none"
  };
  if (props.border) {
    ;
    style.border = props.border;
    return /* @__PURE__ */ createElement10(motion.div, {
      style
    });
  }
  collectBorderStyleForProps(props, style, false);
  return /* @__PURE__ */ createElement10(motion.div, {
    "data-frame-border": true,
    style,
    layoutId
  });
}

// src/render/types/BackgroundImage.ts
var key = "src";
var BackgroundImage;
(function(BackgroundImage2) {
  BackgroundImage2.isImageObject = function(image) {
    if (!image || typeof image === "string")
      return false;
    return key in image;
  };
})(BackgroundImage || (BackgroundImage = {}));

// src/animation/Animatable/Observers.ts
var Observers = class {
  constructor() {
    this.observers = new Set();
    this.transactions = {};
  }
  add(observer) {
    this.observers.add(observer);
    let isCalled = false;
    return () => {
      if (isCalled) {
        return;
      }
      isCalled = true;
      this.remove(observer);
    };
  }
  remove(observer) {
    this.observers.delete(observer);
  }
  notify(change, transaction) {
    if (transaction) {
      const accumulatedChange = this.transactions[transaction] || change;
      accumulatedChange.value = change.value;
      this.transactions[transaction] = accumulatedChange;
    } else {
      this.callObservers(change);
    }
  }
  finishTransaction(transaction) {
    const accumulatedChange = this.transactions[transaction];
    delete this.transactions[transaction];
    return this.callObservers(accumulatedChange, transaction);
  }
  callObservers(change, transaction) {
    const finishObservers = [];
    new Set(this.observers).forEach((observer) => {
      if (typeof observer === "function") {
        observer(change, transaction);
      } else {
        observer.update(change, transaction);
        finishObservers.push(observer.finish);
      }
    });
    return finishObservers;
  }
};

// ../shared/src/assert.ts
function assert(condition, ...msg2) {
  if (condition)
    return;
  const e = Error("Assertion Error" + (msg2.length > 0 ? ": " + msg2.join(" ") : ""));
  if (e.stack) {
    try {
      const lines = e.stack.split("\n");
      if (lines[1].includes("assert")) {
        lines.splice(1, 1);
        e.stack = lines.join("\n");
      } else if (lines[0].includes("assert")) {
        lines.splice(0, 1);
        e.stack = lines.join("\n");
      }
    } catch {
    }
  }
  throw e;
}

// ../shared/src/warnOnce.ts
var warningMessages = new Set();
function warnOnce(keyMessage, ...rest) {
  if (warningMessages.has(keyMessage))
    return;
  warningMessages.add(keyMessage);
  console.warn(keyMessage, ...rest);
}

// ../shared/src/deprecation.ts
function deprecationWarning(removedItem, removalVersion, replacement) {
  const replacementText = replacement ? `, use ${replacement} instead` : "";
  const warningText = `Deprecation warning: ${removedItem} will be removed in version ${removalVersion}${replacementText}.`;
  warnOnce(warningText);
}

// ../shared/src/errors.ts
var errorReporter;
function reportError({
  error: maybeError,
  tags,
  extras,
  caller
}) {
  assert(errorReporter, "Set up an error callback with setErrorReporter, or configure Sentry with initializeEnvironment");
  const error = reportableError(maybeError, caller);
  errorReporter({ error, tags: { ...error.tags, ...tags }, extras: { ...error.extras, ...extras } });
  return error;
}
function reportableError(error, caller) {
  if (error instanceof Error) {
    return error;
  }
  return new UnhandledError(error, caller);
}
var UnhandledError = class extends Error {
  constructor(error, caller) {
    const message = error ? JSON.stringify(error) : "No error message provided";
    super(message);
    this.message = message;
    if (caller && Error.captureStackTrace) {
      Error.captureStackTrace(this, caller);
    } else {
      try {
        throw new Error();
      } catch (e) {
        this.stack = e.stack;
      }
    }
  }
};

// ../shared/src/ServiceMap.ts
var cachedServiceMap;
function getServiceMap() {
  if (cachedServiceMap)
    return cachedServiceMap;
  cachedServiceMap = extractServiceMap();
  return cachedServiceMap;
}
function extractServiceMap() {
  var _a, _b, _c;
  const location = window.location;
  let services = (_a = window == null ? void 0 : window.bootstrap) == null ? void 0 : _a.services;
  if (services) {
    return services;
  }
  let topOrigin;
  try {
    const topWindow = window.top;
    topOrigin = topWindow.location.origin;
    services = (_c = (_b = window.top) == null ? void 0 : _b.bootstrap) == null ? void 0 : _c.services;
    if (services) {
      return services;
    }
  } catch (e) {
  }
  if (topOrigin && topOrigin !== location.origin) {
    throw Error(`Unexpectedly embedded by ${topOrigin} (expected ${location.origin})`);
  }
  if (location.origin.endsWith("framer.com") || location.origin.endsWith("framer.dev")) {
    throw Error("ServiceMap data was not provided in document");
  }
  try {
    const servicesJSON = new URLSearchParams(location.search).get("services") || new URLSearchParams(location.hash.substring(1)).get("services");
    if (servicesJSON) {
      services = JSON.parse(servicesJSON);
    }
  } catch (e) {
  }
  if (services && typeof services === "object" && services.api) {
    return services;
  }
  throw Error("ServiceMap requested but not available");
}

// ../shared/src/logger.ts
function jsonSafeCopy(obj, depth = 0, seen = new Set()) {
  var _a, _b;
  if (obj === null)
    return obj;
  const type = typeof obj;
  if (type === "function")
    return `[Function: ${(_a = obj.name) != null ? _a : "unknown"}]`;
  if (type !== "object")
    return obj;
  if (obj instanceof Error)
    return `[${obj.toString()}]`;
  if (seen.has(obj))
    return "[Circular]";
  if (depth > 2)
    return "...";
  seen.add(obj);
  try {
    if (typeof obj.toJSON === "function") {
      return jsonSafeCopy(obj.toJSON(), depth + 1, seen);
    } else if (Array.isArray(obj)) {
      return obj.map((v) => jsonSafeCopy(v, depth + 1, seen));
    } else if (Object.getPrototypeOf(obj) !== Object.prototype) {
      return `[Object: ${obj.__class || ((_b = obj.constructor) == null ? void 0 : _b.name)}]`;
    } else {
      const result = {};
      for (const [key6, v] of Object.entries(obj)) {
        result[key6] = jsonSafeCopy(v, depth + 1, seen);
      }
      return result;
    }
  } catch (e) {
    return `[Throws: ${e.message}]`;
  } finally {
    seen.delete(obj);
  }
}
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["Trace"] = 0] = "Trace";
  LogLevel2[LogLevel2["Debug"] = 1] = "Debug";
  LogLevel2[LogLevel2["Info"] = 2] = "Info";
  LogLevel2[LogLevel2["Warn"] = 3] = "Warn";
  LogLevel2[LogLevel2["Error"] = 4] = "Error";
  LogLevel2[LogLevel2["NotLogging"] = 5] = "NotLogging";
})(LogLevel || (LogLevel = {}));
var levelNames = ["trace", "debug", "info", "warn", "error"];
var postfixNames = [":trace", ":debug", ":info", ":warn", ":error"];
function applyLogLevelSpec(spec, all) {
  for (const s of spec.split(/[ ,]/)) {
    let match = s.trim();
    if (match.length === 0)
      continue;
    let level = 1;
    let inverted = false;
    if (match.startsWith("-")) {
      match = match.slice(1);
      level = 3;
      inverted = true;
    }
    for (let i = 0; i <= 4; i++) {
      const postfix = postfixNames[i];
      if (match.endsWith(postfix)) {
        level = i;
        if (inverted) {
          level += 1;
        }
        match = match.slice(0, match.length - postfix.length);
        if (match.length === 0) {
          match = "*";
        }
        break;
      }
    }
    const regex = new RegExp("^" + match.replace(/[*]/g, ".*") + "$");
    for (const logger of all) {
      if (logger.id.match(regex)) {
        logger.level = level;
      }
    }
  }
}
var LogEntry = class {
  constructor(logger, level, parts) {
    this.logger = logger;
    this.level = level;
    this.parts = parts;
    this.time = Date.now();
  }
  toMessage() {
    if (this.stringPrefix)
      return this.parts;
    const r = [
      new Date(this.time).toISOString().substr(-14, 14),
      levelNames[this.level] + ": [" + this.logger.id + "]"
    ];
    let i = 0;
    for (; i < this.parts.length; i++) {
      const part = this.parts[i];
      if (typeof part === "string") {
        r.push(part);
        continue;
      }
      break;
    }
    this.stringPrefix = r.join(" ");
    this.parts.splice(0, i, this.stringPrefix);
    return this.parts;
  }
  toString() {
    return this.toMessage().map((part) => {
      var _a, _b;
      const type = typeof part;
      if (type === "string")
        return part;
      if (type === "function")
        return `[Function: ${(_a = part.name) != null ? _a : "unknown"}]`;
      if (part instanceof Error)
        return (_b = part.stack) != null ? _b : part.toString();
      const json = JSON.stringify(jsonSafeCopy(part));
      if ((json == null ? void 0 : json.length) > 253) {
        return json.slice(0, 250) + "...";
      }
      return json;
    }).join(" ");
  }
};
var logLevelSpec = "app:info";
var isNode = typeof process !== "undefined" && !!process.kill;
var isCI = isNode && !!process.env.CI;
if (isCI) {
  logLevelSpec = "-:warn";
} else if (isNode) {
  logLevelSpec = "";
}
try {
  if (typeof window !== "undefined" && window.localStorage) {
    logLevelSpec = window.localStorage.logLevel || logLevelSpec;
  }
} catch {
}
try {
  if (typeof process !== "undefined") {
    logLevelSpec = process.env.DEBUG || logLevelSpec;
  }
} catch {
}
try {
  if (typeof window !== "undefined") {
    Object.assign(window, { setLogLevel });
  }
} catch {
}
try {
  if (typeof window !== "undefined" && window.postMessage && window.top === window) {
    window.addEventListener("message", (msg2) => {
      if (!msg2.data || typeof msg2.data !== "object")
        return;
      const { loggerId, level, parts, printed } = msg2.data;
      if (typeof loggerId !== "string")
        return;
      if (!Array.isArray(parts) || parts.length < 1 || typeof level !== "number")
        return;
      parts[0] = parts[0].replace("[", "*[");
      const logger = getLogger(loggerId);
      const entry = new LogEntry(logger, level, parts);
      entry.stringPrefix = parts[0];
      replayBuffer.push(entry);
      if (printed)
        return;
      if (logger.level > level)
        return;
      console == null ? void 0 : console.log(...entry.toMessage());
    });
  }
} catch {
}
var postLogEntry;
try {
  if (typeof window !== "undefined" && window.postMessage && window.top !== window) {
    postLogEntry = (entry) => {
      try {
        const parts = entry.toMessage().map((p) => jsonSafeCopy(p));
        const logger = entry.logger;
        const level = entry.level;
        const printed = logger.level <= entry.level;
        const data = { loggerId: logger.id, level, parts, printed };
        window.top.postMessage(data, getServiceMap().app);
      } catch {
      }
    };
  }
} catch {
}
var loggers = {};
var replayBuffer = [];
function createLogEntry(logger, level, parts) {
  var _a;
  const entry = new LogEntry(logger, level, parts);
  replayBuffer.push(entry);
  postLogEntry == null ? void 0 : postLogEntry(entry);
  const oldest = Date.now() - 1e3 * 60 * 60;
  while (replayBuffer.length > 1e3 || ((_a = replayBuffer[0]) == null ? void 0 : _a.time) < oldest) {
    replayBuffer.shift();
  }
  return entry;
}
function getLogReplayBuffer() {
  return replayBuffer;
}
function getLogger(id) {
  const existing = loggers[id];
  if (existing)
    return existing;
  const logger = new Logger(id);
  loggers[id] = logger;
  applyLogLevelSpec(logLevelSpec, [logger]);
  return logger;
}
function setLogLevel(spec, replay = true) {
  try {
    if (typeof window !== "undefined" && window.localStorage) {
      window.localStorage.logLevel = spec;
    }
  } catch {
  }
  const previousSpec = logLevelSpec;
  logLevelSpec = spec;
  const all = Object.values(loggers);
  for (const logger of all) {
    logger.level = 3;
  }
  applyLogLevelSpec(spec, all);
  if (replay && replayBuffer.length > 0) {
    console == null ? void 0 : console.log("--- LOG REPLAY ---");
    for (const entry of replayBuffer) {
      if (entry.logger.level > entry.level)
        continue;
      if (entry.level >= 3) {
        console == null ? void 0 : console.warn(...entry.toMessage());
      } else {
        console == null ? void 0 : console.log(...entry.toMessage());
      }
    }
    console == null ? void 0 : console.log("--- END OF LOG REPLAY ---");
  }
  return previousSpec;
}
var Logger = class {
  constructor(id) {
    this.id = id;
    this.level = 3;
    this.didLog = {};
    this.trace = (...parts) => {
      if (this.level > 0)
        return;
      const entry = new LogEntry(this, 0, parts);
      console == null ? void 0 : console.log(...entry.toMessage());
    };
    this.debug = (...parts) => {
      const entry = createLogEntry(this, 1, parts);
      if (this.level > 1)
        return;
      console == null ? void 0 : console.log(...entry.toMessage());
    };
    this.info = (...parts) => {
      const entry = createLogEntry(this, 2, parts);
      if (this.level > 2)
        return;
      console == null ? void 0 : console.info(...entry.toMessage());
    };
    this.warn = (...parts) => {
      const entry = createLogEntry(this, 3, parts);
      if (this.level > 3)
        return;
      console == null ? void 0 : console.warn(...entry.toMessage());
    };
    this.warnOncePerMinute = (firstPart, ...parts) => {
      if (this.didLog[firstPart] > Date.now())
        return;
      this.didLog[firstPart] = Date.now() + 1e3 * 60;
      parts.unshift(firstPart);
      const entry = createLogEntry(this, 3, parts);
      if (this.level > 3)
        return;
      console == null ? void 0 : console.warn(...entry.toMessage());
    };
    this.error = (...parts) => {
      const entry = createLogEntry(this, 4, parts);
      if (this.level > 4)
        return;
      console == null ? void 0 : console.error(...entry.toMessage());
    };
    this.errorOncePerMinute = (firstPart, ...parts) => {
      if (this.didLog[firstPart] > Date.now())
        return;
      this.didLog[firstPart] = Date.now() + 1e3 * 60;
      parts.unshift(firstPart);
      const entry = createLogEntry(this, 4, parts);
      if (this.level > 4)
        return;
      console == null ? void 0 : console.error(...entry.toMessage());
    };
    this.reportError = (maybeError, extras) => {
      const logs = getLogReplayBuffer().slice(-100).map((entry) => entry.toString().slice(0, 1e3)).join("\n");
      const reportedError = reportError({
        caller: this.reportError,
        error: maybeError,
        tags: {
          handler: "logger",
          where: this.id
        },
        extras: { ...extras, logs }
      });
      extras ? this.error(reportedError, extras) : this.error(reportedError);
    };
    this.reportErrorOncePerMinute = (error, extras) => {
      if (!isErrorWithMessage(error) || this.didLog[error.message] > Date.now())
        return;
      this.didLog[error.message] = Date.now() + 1e3 * 60;
      this.reportError(error, extras);
    };
  }
  extend(name) {
    const id = this.id + ":" + name;
    return getLogger(id);
  }
  getBufferedMessages() {
    return replayBuffer.filter((entry) => entry.logger === this);
  }
  setLevel(level) {
    const previous = this.level;
    this.level = level;
    return previous;
  }
  isLoggingTraceMessages() {
    return this.level >= 0;
  }
};
function isErrorWithMessage(maybeError) {
  return Object.prototype.hasOwnProperty.call(maybeError, "message");
}

// ../shared/src/moduleIdentifiers.ts
var ModuleType;
(function(ModuleType2) {
  ModuleType2["Canvas"] = "canvasComponent";
  ModuleType2["Code"] = "codeFile";
  ModuleType2["Screen"] = "screen";
})(ModuleType || (ModuleType = {}));

// ../shared/src/TaskQueues.ts
var log = getLogger("task-queue");

// src/animation/Animatable/Animatable.ts
function Animatable(value) {
  deprecationWarning("Animatable()", "2.0.0", "the new animation API (https://www.framer.com/api/animation/)");
  return isAnimatable2(value) ? value : new AnimatableValue(value);
}
(function(Animatable3) {
  function transaction(update) {
    const transactionId = Math.random();
    const updatedValues = new Set();
    const updater = (animatable, value) => {
      animatable.set(value, transactionId);
      updatedValues.add(animatable);
    };
    update(updater, transactionId);
    const finishObservers = [];
    updatedValues.forEach((value) => {
      finishObservers.push(...value.finishTransaction(transactionId));
    });
    finishObservers.forEach((finish) => {
      finish(transactionId);
    });
  }
  Animatable3.transaction = transaction;
  function getNumber2(value, defaultValue = 0) {
    return Animatable3.get(value, defaultValue);
  }
  Animatable3.getNumber = getNumber2;
  function get(value, defaultValue) {
    if (value === void 0 || value === null) {
      return defaultValue;
    }
    if (isAnimatable2(value)) {
      return value.get();
    }
    return value;
  }
  Animatable3.get = get;
  function objectToValues(object) {
    if (!object) {
      return object;
    }
    const result = {};
    for (const key6 in object) {
      const value = object[key6];
      if (isAnimatable2(value)) {
        result[key6] = value.get();
      } else {
        result[key6] = value;
      }
    }
    return result;
  }
  Animatable3.objectToValues = objectToValues;
})(Animatable || (Animatable = {}));
var onUpdateKey = "onUpdate";
var finishTransactionKey = "finishTransaction";
function isAnimatable2(value) {
  return value !== null && typeof value === "object" && onUpdateKey in value && value[onUpdateKey] instanceof Function && finishTransactionKey in value && value[finishTransactionKey] instanceof Function;
}
function animatableInterpolation(value, currentInterpolation) {
  return {
    interpolate(from, to) {
      const fromValue = from.get();
      const toValue = to.get();
      const result = Animatable(fromValue);
      return (progress2) => {
        const v = currentInterpolation.interpolate(fromValue, toValue)(progress2);
        result.set(v);
        return result;
      };
    },
    difference(from, to) {
      const v = from.get();
      return currentInterpolation.difference(v, to.get());
    }
  };
}
var AnimatableValue = class {
  constructor(value) {
    this.value = value;
    this.observers = new Observers();
  }
  static interpolationFor(value, currentInterpolation) {
    if (isAnimatable2(value)) {
      return animatableInterpolation(value, currentInterpolation);
    }
  }
  get() {
    return this.value;
  }
  set(value, transaction) {
    const oldValue = this.value;
    if (isAnimatable2(value)) {
      value = value.get();
    }
    this.value = value;
    const change = {
      value,
      oldValue
    };
    this.observers.notify(change, transaction);
  }
  finishTransaction(transaction) {
    return this.observers.finishTransaction(transaction);
  }
  onUpdate(handler) {
    return this.observers.add(handler);
  }
};

// src/utils/utils.ts
function isFunction(value) {
  return value instanceof Function;
}
function isString2(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isArray(value) {
  return value instanceof Array;
}
function isObject(value) {
  return typeof value === "object";
}

// src/render/style/backgroundImageFromProps.ts
function applyForwardOverrides(background, props) {
  const { _forwardedOverrideId, _forwardedOverrides, id } = props;
  const forwardedOverrideId = _forwardedOverrideId != null ? _forwardedOverrideId : id;
  const src = _forwardedOverrides && forwardedOverrideId ? _forwardedOverrides[forwardedOverrideId] : void 0;
  if (src && typeof src === "string") {
    background = { ...background, src };
  }
  return background;
}
function backgroundImageFromProps(props) {
  const { background, image } = props;
  if (image !== void 0 && background && !BackgroundImage.isImageObject(background)) {
    return;
  }
  let backgroundImage = null;
  if (isString2(image)) {
    backgroundImage = { src: image };
  } else {
    backgroundImage = Animatable.get(background, null);
  }
  if (!BackgroundImage.isImageObject(backgroundImage)) {
    return;
  }
  return applyForwardOverrides(backgroundImage, props);
}

// src/render/types/NewConstraints.tsx
import {
  Fragment as Fragment3,
  createContext as createContext7,
  createElement as createElement11,
  useContext as useContext16,
  useMemo as useMemo7
} from "react";

// src/render/utils/roundedNumber.ts
function roundedNumber(value, decimals) {
  const d = Math.round(Math.abs(decimals));
  const multiplier = Math.pow(10, d);
  return Math.round(value * multiplier) / multiplier;
}
function roundedNumberString(value, decimals) {
  const result = value.toFixed(decimals);
  if (decimals === 0) {
    return result;
  }
  return result.replace(/\.?0+$/, "");
}
function roundWithOffset(value, offset) {
  if (offset === 0) {
    return Math.round(value);
  }
  offset -= offset | 0;
  if (offset < 0) {
    offset = 1 - offset;
  }
  return Math.round(value - offset) + offset;
}

// src/render/types/Point.ts
function Point(x, y) {
  return { x, y };
}
(function(Point2) {
  Point2.add = (...args) => {
    return args.reduce((previousValue, currentValue) => {
      return { x: previousValue.x + currentValue.x, y: previousValue.y + currentValue.y };
    }, { x: 0, y: 0 });
  };
  Point2.subtract = (a2, b2) => {
    return { x: a2.x - b2.x, y: a2.y - b2.y };
  };
  Point2.multiply = (a2, b2) => {
    return { x: a2.x * b2, y: a2.y * b2 };
  };
  Point2.divide = (a2, b2) => {
    return { x: a2.x / b2, y: a2.y / b2 };
  };
  Point2.absolute = (point) => {
    return {
      x: Math.abs(point.x),
      y: Math.abs(point.y)
    };
  };
  Point2.reverse = (point) => {
    return {
      x: point.x * -1,
      y: point.y * -1
    };
  };
  Point2.pixelAligned = (point, offset = { x: 0, y: 0 }) => {
    return {
      x: roundWithOffset(point.x, offset.x),
      y: roundWithOffset(point.y, offset.y)
    };
  };
  Point2.distance = (a2, b2) => {
    const deltaX = Math.abs(a2.x - b2.x);
    const deltaY = Math.abs(a2.y - b2.y);
    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
  };
  Point2.angle = (a2, b2) => {
    return Math.atan2(b2.y - a2.y, b2.x - a2.x) * 180 / Math.PI - 90;
  };
  Point2.isEqual = (a2, b2) => {
    return a2.x === b2.x && a2.y === b2.y;
  };
  Point2.rotationNormalizer = () => {
    let lastValue;
    return (value) => {
      if (typeof lastValue !== "number") {
        lastValue = value;
      }
      const diff = lastValue - value;
      const maxDiff = Math.abs(diff) + 180;
      const nTimes = Math.floor(maxDiff / 360);
      if (diff < 180) {
        value -= nTimes * 360;
      }
      if (diff > 180) {
        value += nTimes * 360;
      }
      lastValue = value;
      return value;
    };
  };
  function center(a2, b2) {
    return {
      x: (a2.x + b2.x) / 2,
      y: (a2.y + b2.y) / 2
    };
  }
  Point2.center = center;
})(Point || (Point = {}));

// src/render/types/Rect.ts
var Rect;
(function(Rect2) {
  function equals(rect, other) {
    if (rect === other)
      return true;
    if (!rect || !other)
      return false;
    return rect.x === other.x && rect.y === other.y && rect.width === other.width && rect.height === other.height;
  }
  Rect2.equals = equals;
  Rect2.atOrigin = (size2) => {
    return { ...size2, x: 0, y: 0 };
  };
  Rect2.fromTwoPoints = (a2, b2) => {
    return {
      x: Math.min(a2.x, b2.x),
      y: Math.min(a2.y, b2.y),
      width: Math.abs(a2.x - b2.x),
      height: Math.abs(a2.y - b2.y)
    };
  };
  Rect2.fromRect = (rect) => {
    return {
      x: rect.left,
      y: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };
  };
  Rect2.multiply = (rect, n) => {
    return {
      x: rect.x * n,
      y: rect.y * n,
      width: rect.width * n,
      height: rect.height * n
    };
  };
  Rect2.divide = (rect, n) => {
    return Rect2.multiply(rect, 1 / n);
  };
  Rect2.offset = (rect, delta2) => {
    const xOffset = typeof delta2.x === "number" ? delta2.x : 0;
    const yOffset = typeof delta2.y === "number" ? delta2.y : 0;
    return {
      ...rect,
      x: rect.x + xOffset,
      y: rect.y + yOffset
    };
  };
  function inflate(rect, value) {
    if (value === 0)
      return rect;
    const doubleValue = 2 * value;
    return {
      x: rect.x - value,
      y: rect.y - value,
      width: rect.width + doubleValue,
      height: rect.height + doubleValue
    };
  }
  Rect2.inflate = inflate;
  Rect2.pixelAligned = (rect) => {
    const x = Math.round(rect.x);
    const y = Math.round(rect.y);
    const rectMaxX = Math.round(rect.x + rect.width);
    const rectMaxY = Math.round(rect.y + rect.height);
    const width = Math.max(rectMaxX - x, 0);
    const height = Math.max(rectMaxY - y, 0);
    return { x, y, width, height };
  };
  Rect2.halfPixelAligned = (rect) => {
    const x = Math.round(rect.x * 2) / 2;
    const y = Math.round(rect.y * 2) / 2;
    const rectMaxX = Math.round((rect.x + rect.width) * 2) / 2;
    const rectMaxY = Math.round((rect.y + rect.height) * 2) / 2;
    const width = Math.max(rectMaxX - x, 1);
    const height = Math.max(rectMaxY - y, 1);
    return { x, y, width, height };
  };
  Rect2.round = (rect, decimals = 0) => {
    const x = roundedNumber(rect.x, decimals);
    const y = roundedNumber(rect.y, decimals);
    const width = roundedNumber(rect.width, decimals);
    const height = roundedNumber(rect.height, decimals);
    return { x, y, width, height };
  };
  Rect2.roundToOutside = (rect) => {
    const x = Math.floor(rect.x);
    const y = Math.floor(rect.y);
    const rectMaxX = Math.ceil(rect.x + rect.width);
    const rectMaxY = Math.ceil(rect.y + rect.height);
    const width = Math.max(rectMaxX - x, 0);
    const height = Math.max(rectMaxY - y, 0);
    return { x, y, width, height };
  };
  Rect2.minX = (rect) => {
    return rect.x;
  };
  Rect2.maxX = (rect) => {
    return rect.x + rect.width;
  };
  Rect2.minY = (rect) => {
    return rect.y;
  };
  Rect2.maxY = (rect) => {
    return rect.y + rect.height;
  };
  Rect2.positions = (rect) => {
    return {
      minX: rect.x,
      midX: rect.x + rect.width / 2,
      maxX: Rect2.maxX(rect),
      minY: rect.y,
      midY: rect.y + rect.height / 2,
      maxY: Rect2.maxY(rect)
    };
  };
  Rect2.center = (rect) => {
    return {
      x: rect.x + rect.width / 2,
      y: rect.y + rect.height / 2
    };
  };
  Rect2.fromPoints = (ps) => {
    const xValues = ps.map((point) => point.x);
    const yValues = ps.map((point) => point.y);
    const x = Math.min(...xValues);
    const y = Math.min(...yValues);
    const width = Math.max(...xValues) - x;
    const height = Math.max(...yValues) - y;
    return { x, y, width, height };
  };
  Rect2.merge = (...rect) => {
    const min = {
      x: Math.min(...rect.map(Rect2.minX)),
      y: Math.min(...rect.map(Rect2.minY))
    };
    const max = {
      x: Math.max(...rect.map(Rect2.maxX)),
      y: Math.max(...rect.map(Rect2.maxY))
    };
    return Rect2.fromTwoPoints(min, max);
  };
  Rect2.intersection = (rect1, rect2) => {
    const x = Math.max(rect1.x, rect2.x);
    const x2 = Math.min(rect1.x + rect1.width, rect2.x + rect2.width);
    const y = Math.max(rect1.y, rect2.y);
    const y2 = Math.min(rect1.y + rect1.height, rect2.y + rect2.height);
    return { x, y, width: x2 - x, height: y2 - y };
  };
  Rect2.points = (rect) => {
    return [
      { x: Rect2.minX(rect), y: Rect2.minY(rect) },
      { x: Rect2.minX(rect), y: Rect2.maxY(rect) },
      { x: Rect2.maxX(rect), y: Rect2.minY(rect) },
      { x: Rect2.maxX(rect), y: Rect2.maxY(rect) }
    ];
  };
  Rect2.transform = (rect, matrix) => {
    const { x: x1, y: y1 } = matrix.transformPoint({ x: rect.x, y: rect.y });
    const { x: x2, y: y2 } = matrix.transformPoint({ x: rect.x + rect.width, y: rect.y });
    const { x: x3, y: y3 } = matrix.transformPoint({ x: rect.x + rect.width, y: rect.y + rect.height });
    const { x: x4, y: y4 } = matrix.transformPoint({ x: rect.x, y: rect.y + rect.height });
    const x = Math.min(x1, x2, x3, x4);
    const width = Math.max(x1, x2, x3, x4) - x;
    const y = Math.min(y1, y2, y3, y4);
    const height = Math.max(y1, y2, y3, y4) - y;
    return { x, y, width, height };
  };
  Rect2.containsPoint = (rect, point) => {
    if (point.x < Rect2.minX(rect)) {
      return false;
    }
    if (point.x > Rect2.maxX(rect)) {
      return false;
    }
    if (point.y < Rect2.minY(rect)) {
      return false;
    }
    if (point.y > Rect2.maxY(rect)) {
      return false;
    }
    if (isNaN(rect.x)) {
      return false;
    }
    if (isNaN(rect.y)) {
      return false;
    }
    return true;
  };
  Rect2.containsRect = (rectA, rectB) => {
    for (const point of Rect2.points(rectB)) {
      if (!Rect2.containsPoint(rectA, point)) {
        return false;
      }
    }
    return true;
  };
  Rect2.toCSS = (rect) => {
    return {
      display: "block",
      transform: `translate(${rect.x}px, ${rect.y}px)`,
      width: `${rect.width}px`,
      height: `${rect.height}px`
    };
  };
  Rect2.inset = (rect, n) => {
    return {
      x: rect.x + n,
      y: rect.y + n,
      width: Math.max(0, rect.width - 2 * n),
      height: Math.max(0, rect.height - 2 * n)
    };
  };
  Rect2.intersects = (rectA, rectB) => {
    return !(rectB.x >= Rect2.maxX(rectA) || Rect2.maxX(rectB) <= rectA.x || rectB.y >= Rect2.maxY(rectA) || Rect2.maxY(rectB) <= rectA.y);
  };
  Rect2.overlapHorizontally = (rectA, rectB) => {
    const aMax = Rect2.maxX(rectA);
    const bMax = Rect2.maxX(rectB);
    return aMax > rectB.x && bMax > rectA.x;
  };
  Rect2.overlapVertically = (rectA, rectB) => {
    const aMax = Rect2.maxY(rectA);
    const bMax = Rect2.maxY(rectB);
    return aMax > rectB.y && bMax > rectA.y;
  };
  Rect2.doesNotIntersect = (rect, rects) => {
    return rects.find((comparingRect) => {
      return Rect2.intersects(comparingRect, rect);
    }) === void 0;
  };
  Rect2.isEqual = (rectA, rectB) => {
    if (rectA && rectB) {
      const { x, y, width, height } = rectA;
      return rectB.x === x && rectB.y === y && rectB.width === width && rectB.height === height;
    } else {
      return rectA === rectB;
    }
  };
  Rect2.cornerPoints = (rect) => {
    const rectMinX = rect.x;
    const rectMaxX = rect.x + rect.width;
    const rectMinY = rect.y;
    const rectMaxY = rect.y + rect.height;
    const corner1 = { x: rectMinX, y: rectMinY };
    const corner2 = { x: rectMaxX, y: rectMinY };
    const corner3 = { x: rectMaxX, y: rectMaxY };
    const corner4 = { x: rectMinX, y: rectMaxY };
    return [corner1, corner2, corner3, corner4];
  };
  Rect2.midPoints = (rect) => {
    const rectMinX = rect.x;
    const rectMidX = rect.x + rect.width / 2;
    const rectMaxX = rect.x + rect.width;
    const rectMinY = rect.y;
    const rectMidY = rect.y + rect.height / 2;
    const rectMaxY = rect.y + rect.height;
    const corner1 = { x: rectMidX, y: rectMinY };
    const corner2 = { x: rectMaxX, y: rectMidY };
    const corner3 = { x: rectMidX, y: rectMaxY };
    const corner4 = { x: rectMinX, y: rectMidY };
    return [corner1, corner2, corner3, corner4];
  };
  Rect2.pointDistance = (rect, point) => {
    let x = 0;
    let y = 0;
    if (point.x < rect.x) {
      x = rect.x - point.x;
    } else if (point.x > Rect2.maxX(rect)) {
      x = point.x - Rect2.maxX(rect);
    }
    if (point.y < rect.y) {
      y = rect.y - point.y;
    } else if (point.y > Rect2.maxY(rect)) {
      y = point.y - Rect2.maxY(rect);
    }
    return Point.distance({ x, y }, { x: 0, y: 0 });
  };
  const fromAnyDefaults = {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  Rect2.fromAny = (rect, defaults = fromAnyDefaults) => {
    return {
      x: rect.x || defaults.x,
      y: rect.y || defaults.y,
      width: rect.width || defaults.width,
      height: rect.height || defaults.height
    };
  };
})(Rect || (Rect = {}));

// src/render/utils/isFiniteNumber.ts
function isFiniteNumber(value) {
  return typeof value === "number" && isFinite(value);
}
function finiteNumber(value) {
  return isFiniteNumber(value) ? value : void 0;
}

// src/utils/type-guards.ts
function isEmpty(obj) {
  return !obj || !Object.keys(obj).length && obj.constructor === Object;
}
function isReactElement(test2) {
  return typeof test2 !== "string" && typeof test2 !== "number";
}
function isReactChild(test2) {
  return test2 !== null && typeof test2 !== "undefined" && typeof test2 !== "boolean" && !isEmpty(test2);
}

// src/render/types/Constraints.ts
var constraintDefaults = {
  left: null,
  right: null,
  top: null,
  bottom: null,
  centerX: "50%",
  centerY: "50%",
  aspectRatio: null,
  parentSize: null,
  width: 100,
  height: 100
};
var DimensionType;
(function(DimensionType2) {
  DimensionType2[DimensionType2["FixedNumber"] = 0] = "FixedNumber";
  DimensionType2[DimensionType2["Percentage"] = 1] = "Percentage";
  DimensionType2[DimensionType2["Auto"] = 2] = "Auto";
  DimensionType2[DimensionType2["FractionOfFreeSpace"] = 3] = "FractionOfFreeSpace";
})(DimensionType || (DimensionType = {}));
function isConstraintSupportingChild(child) {
  if (!isReactChild(child) || !isReactElement(child)) {
    return false;
  }
  return true;
}
var ConstraintMask;
(function(ConstraintMask2) {
  ConstraintMask2.quickfix = (constraints) => {
    if (constraints.widthType === 2 || constraints.heightType === 2) {
      constraints.aspectRatio = null;
    }
    if (isFiniteNumber(constraints.aspectRatio)) {
      if (constraints.left && constraints.right || constraints.top && constraints.bottom) {
        constraints.widthType = 0;
        constraints.heightType = 0;
      }
      if (constraints.left && constraints.right && constraints.top && constraints.bottom) {
        constraints.bottom = false;
      }
      if (constraints.widthType !== 0 && constraints.heightType !== 0) {
        constraints.heightType = 0;
      }
    }
    if (constraints.left && constraints.right) {
      if (constraints.fixedSize || constraints.widthType === 2) {
        constraints.right = false;
      }
      constraints.widthType = 0;
    }
    if (constraints.top && constraints.bottom) {
      if (constraints.fixedSize || constraints.heightType === 2) {
        constraints.bottom = false;
      }
      constraints.heightType = 0;
    }
    return constraints;
  };
})(ConstraintMask || (ConstraintMask = {}));
function valueToDimensionType(value) {
  if (typeof value === "string") {
    const trimmedValue = value.trim();
    if (trimmedValue === "auto")
      return 2;
    if (trimmedValue.endsWith("fr"))
      return 3;
    if (trimmedValue.endsWith("%"))
      return 1;
  }
  return 0;
}
var ConstraintValues;
(function(ConstraintValues2) {
  ConstraintValues2.fromProperties = (props) => {
    const { left, right, top, bottom, width, height, centerX, centerY, aspectRatio, autoSize } = props;
    const constraints = ConstraintMask.quickfix({
      left: isFiniteNumber(left) || isAnimatable2(left),
      right: isFiniteNumber(right) || isAnimatable2(right),
      top: isFiniteNumber(top) || isAnimatable2(top),
      bottom: isFiniteNumber(bottom) || isAnimatable2(bottom),
      widthType: valueToDimensionType(width),
      heightType: valueToDimensionType(height),
      aspectRatio: aspectRatio || null,
      fixedSize: autoSize === true
    });
    let widthValue = null;
    let heightValue = null;
    let widthType = 0;
    let heightType = 0;
    if (constraints.widthType !== 0 && typeof width === "string") {
      const parsedWidth = parseFloat(width);
      if (width.endsWith("fr")) {
        widthType = 3;
        widthValue = parsedWidth;
      } else if (width === "auto") {
        widthType = 2;
      } else {
        widthType = 1;
        widthValue = parsedWidth / 100;
      }
    } else if (width !== void 0 && typeof width !== "string") {
      widthValue = Animatable.getNumber(width);
    }
    if (constraints.heightType !== 0 && typeof height === "string") {
      const parsedHeight = parseFloat(height);
      if (height.endsWith("fr")) {
        heightType = 3;
        heightValue = parsedHeight;
      } else if (height === "auto") {
        heightType = 2;
      } else {
        heightType = 1;
        heightValue = parseFloat(height) / 100;
      }
    } else if (height !== void 0 && typeof height !== "string") {
      heightValue = Animatable.getNumber(height);
    }
    let centerAnchorX = 0.5;
    let centerAnchorY = 0.5;
    if (centerX) {
      centerAnchorX = parseFloat(centerX) / 100;
    }
    if (centerY) {
      centerAnchorY = parseFloat(centerY) / 100;
    }
    return {
      left: constraints.left ? Animatable.getNumber(left) : null,
      right: constraints.right ? Animatable.getNumber(right) : null,
      top: constraints.top ? Animatable.getNumber(top) : null,
      bottom: constraints.bottom ? Animatable.getNumber(bottom) : null,
      widthType,
      heightType,
      width: widthValue,
      height: heightValue,
      aspectRatio: constraints.aspectRatio || null,
      centerAnchorX,
      centerAnchorY
    };
  };
  ConstraintValues2.toMinSize = (values, parentSize, autoSize = null) => {
    let width = null;
    let height = null;
    const parentWidth = parentSize ? parentSize.width : null;
    const parentHeight = parentSize ? parentSize.height : null;
    const hOpposingPinsOffset = pinnedOffset(values.left, values.right);
    if (parentWidth && isFiniteNumber(hOpposingPinsOffset)) {
      width = parentWidth - hOpposingPinsOffset;
    } else if (autoSize && values.widthType === 2) {
      width = autoSize.width;
    } else if (isFiniteNumber(values.width)) {
      switch (values.widthType) {
        case 0:
          width = values.width;
          break;
        case 3:
          width = 0;
          break;
        case 1:
          if (parentWidth) {
            width = parentWidth * values.width;
          }
          break;
      }
    }
    const vOpposingPinsOffset = pinnedOffset(values.top, values.bottom);
    if (parentHeight && isFiniteNumber(vOpposingPinsOffset)) {
      height = parentHeight - vOpposingPinsOffset;
    } else if (autoSize && values.heightType === 2) {
      height = autoSize.height;
    } else if (isFiniteNumber(values.height)) {
      switch (values.heightType) {
        case 0:
          height = values.height;
          break;
        case 3:
          height = 0;
          break;
        case 1:
          if (parentHeight) {
            height = parentHeight * values.height;
          }
          break;
      }
    }
    return sizeAfterApplyingDefaultsAndAspectRatio(width, height, values);
  };
  ConstraintValues2.toSize = (values, parentSize, autoSize, freeSpace) => {
    let width = null;
    let height = null;
    const parentWidth = parentSize ? Animatable.getNumber(parentSize.width) : null;
    const parentHeight = parentSize ? Animatable.getNumber(parentSize.height) : null;
    const hOpposingPinsOffset = pinnedOffset(values.left, values.right);
    if (parentWidth && isFiniteNumber(hOpposingPinsOffset)) {
      width = parentWidth - hOpposingPinsOffset;
    } else if (autoSize && values.widthType === 2) {
      width = autoSize.width;
    } else if (isFiniteNumber(values.width)) {
      switch (values.widthType) {
        case 0:
          width = values.width;
          break;
        case 3:
          width = freeSpace ? freeSpace.freeSpaceInParent.width / freeSpace.freeSpaceUnitDivisor.width * values.width : 0;
          break;
        case 1:
          if (parentWidth) {
            width = parentWidth * values.width;
          }
          break;
      }
    }
    const vOpposingPinsOffset = pinnedOffset(values.top, values.bottom);
    if (parentHeight && isFiniteNumber(vOpposingPinsOffset)) {
      height = parentHeight - vOpposingPinsOffset;
    } else if (autoSize && values.heightType === 2) {
      height = autoSize.height;
    } else if (isFiniteNumber(values.height)) {
      switch (values.heightType) {
        case 0:
          height = values.height;
          break;
        case 3:
          height = freeSpace ? freeSpace.freeSpaceInParent.height / freeSpace.freeSpaceUnitDivisor.height * values.height : 0;
          break;
        case 1:
          if (parentHeight) {
            height = parentHeight * values.height;
          }
          break;
      }
    }
    return sizeAfterApplyingDefaultsAndAspectRatio(width, height, values);
  };
  ConstraintValues2.toRect = (values, parentSize, autoSize = null, pixelAlign = false, freeSpace = null) => {
    let x = values.left || 0;
    let y = values.top || 0;
    let width = null;
    let height = null;
    const parentWidth = parentSize ? Animatable.getNumber(parentSize.width) : null;
    const parentHeight = parentSize ? Animatable.getNumber(parentSize.height) : null;
    const hOpposingPinsOffset = pinnedOffset(values.left, values.right);
    if (parentWidth && isFiniteNumber(hOpposingPinsOffset)) {
      width = parentWidth - hOpposingPinsOffset;
    } else if (autoSize && values.widthType === 2) {
      width = autoSize.width;
    } else if (isFiniteNumber(values.width)) {
      switch (values.widthType) {
        case 0:
          width = values.width;
          break;
        case 3:
          width = freeSpace ? freeSpace.freeSpaceInParent.width / freeSpace.freeSpaceUnitDivisor.width * values.width : null;
          break;
        case 1:
          if (parentWidth) {
            width = parentWidth * values.width;
          }
          break;
      }
    }
    const vOpposingPinsOffset = pinnedOffset(values.top, values.bottom);
    if (parentHeight && isFiniteNumber(vOpposingPinsOffset)) {
      height = parentHeight - vOpposingPinsOffset;
    } else if (autoSize && values.heightType === 2) {
      height = autoSize.height;
    } else if (isFiniteNumber(values.height)) {
      switch (values.heightType) {
        case 0:
          height = values.height;
          break;
        case 3:
          height = freeSpace ? freeSpace.freeSpaceInParent.height / freeSpace.freeSpaceUnitDivisor.height * values.height : null;
          break;
        case 1:
          if (parentHeight) {
            height = parentHeight * values.height;
          }
          break;
      }
    }
    const sizeWithDefaults = sizeAfterApplyingDefaultsAndAspectRatio(width, height, values);
    width = sizeWithDefaults.width;
    height = sizeWithDefaults.height;
    if (values.left !== null) {
      x = values.left;
    } else if (parentWidth && values.right !== null) {
      x = parentWidth - values.right - width;
    } else if (parentWidth) {
      x = values.centerAnchorX * parentWidth - width / 2;
    }
    if (values.top !== null) {
      y = values.top;
    } else if (parentHeight && values.bottom !== null) {
      y = parentHeight - values.bottom - height;
    } else if (parentHeight) {
      y = values.centerAnchorY * parentHeight - height / 2;
    }
    const f = { x, y, width, height };
    if (pixelAlign) {
      return Rect.pixelAligned(f);
    }
    return f;
  };
})(ConstraintValues || (ConstraintValues = {}));
var defaultWidth = 200;
var defaultHeight = 200;
function sizeAfterApplyingDefaultsAndAspectRatio(width, height, values) {
  let w = isFiniteNumber(width) ? width : defaultWidth;
  let h = isFiniteNumber(height) ? height : defaultHeight;
  if (isFiniteNumber(values.aspectRatio) && values.aspectRatio > 0) {
    if (isFiniteNumber(values.left) && isFiniteNumber(values.right)) {
      h = w / values.aspectRatio;
    } else if (isFiniteNumber(values.top) && isFiniteNumber(values.bottom)) {
      w = h * values.aspectRatio;
    } else if (values.widthType !== 0) {
      h = w / values.aspectRatio;
    } else {
      w = h * values.aspectRatio;
    }
  }
  return {
    width: w,
    height: h
  };
}
function pinnedOffset(start, end) {
  if (!isFiniteNumber(start) || !isFiniteNumber(end))
    return null;
  return start + end;
}
function getMergedConstraintsProps(props, constraints) {
  const result = {};
  if (props.constraints) {
    result.constraints = { ...props.constraints, ...constraints };
  } else {
    Object.assign(result, constraints);
  }
  return result;
}

// src/render/types/NewConstraints.tsx
function isString3(t) {
  return typeof t === "string";
}
function containsInvalidStringValues(props) {
  const { left, right, top, bottom, center } = props;
  if ([right, bottom].some(isString3)) {
    return true;
  }
  if (isString3(left) && (!center || center === "y")) {
    return true;
  }
  if (isString3(top) && (!center || center === "x")) {
    return true;
  }
  return false;
}
function constraintsEnabled(props) {
  const { _constraints } = props;
  if (!_constraints) {
    return false;
  }
  if (containsInvalidStringValues(props)) {
    return false;
  }
  return _constraints.enabled;
}
function sizeFromFiniteNumberProps(props) {
  const { size: size2 } = props;
  let { width, height } = props;
  if (isFiniteNumber(size2)) {
    if (width === void 0) {
      width = size2;
    }
    if (height === void 0) {
      height = size2;
    }
  }
  if (isFiniteNumber(width) && isFiniteNumber(height)) {
    return {
      width,
      height
    };
  }
  return null;
}
function rectFromFiniteNumberProps(props) {
  const size2 = sizeFromFiniteNumberProps(props);
  if (size2 === null) {
    return null;
  }
  const { left, top } = props;
  if (isFiniteNumber(left) && isFiniteNumber(top)) {
    return {
      x: left,
      y: top,
      ...size2
    };
  }
  return null;
}
function calculateRect(props, parentSize, pixelAlign = true) {
  if (!constraintsEnabled(props) || parentSize === ParentSizeState.Disabled || parentSize === ParentSizeState.DisabledForCurrentLevel) {
    return rectFromFiniteNumberProps(props);
  }
  const constraintValues = getConstraintValues(props);
  return ConstraintValues.toRect(constraintValues, deprecatedParentSize(parentSize), null, pixelAlign);
}
function getConstraintValues(props) {
  const { left, right, top, bottom, center, _constraints, size: size2 } = props;
  let { width, height } = props;
  if (width === void 0) {
    width = size2;
  }
  if (height === void 0) {
    height = size2;
  }
  const { aspectRatio, autoSize } = _constraints;
  const constraintMask = ConstraintMask.quickfix({
    left: isFiniteNumber(left),
    right: isFiniteNumber(right),
    top: isFiniteNumber(top),
    bottom: isFiniteNumber(bottom),
    widthType: valueToDimensionType(width),
    heightType: valueToDimensionType(height),
    aspectRatio: aspectRatio || null,
    fixedSize: autoSize === true
  });
  let widthValue = null;
  let heightValue = null;
  let widthType = DimensionType.FixedNumber;
  let heightType = DimensionType.FixedNumber;
  if (constraintMask.widthType !== DimensionType.FixedNumber && typeof width === "string") {
    const parsedWidth = parseFloat(width);
    if (width.endsWith("fr")) {
      widthType = DimensionType.FractionOfFreeSpace;
      widthValue = parsedWidth;
    } else if (width === "auto") {
      widthType = DimensionType.Auto;
    } else {
      widthType = DimensionType.Percentage;
      widthValue = parsedWidth / 100;
    }
  } else if (width !== void 0 && typeof width !== "string") {
    widthValue = width;
  }
  if (constraintMask.heightType !== DimensionType.FixedNumber && typeof height === "string") {
    const parsedHeight = parseFloat(height);
    if (height.endsWith("fr")) {
      heightType = DimensionType.FractionOfFreeSpace;
      heightValue = parsedHeight;
    } else if (height === "auto") {
      heightType = DimensionType.Auto;
    } else {
      heightType = DimensionType.Percentage;
      heightValue = parseFloat(height) / 100;
    }
  } else if (height !== void 0 && typeof height !== "string") {
    heightValue = height;
  }
  let centerAnchorX = 0.5;
  let centerAnchorY = 0.5;
  if (center === true || center === "x") {
    constraintMask.left = false;
    if (typeof left === "string") {
      centerAnchorX = parseFloat(left) / 100;
    }
  }
  if (center === true || center === "y") {
    constraintMask.top = false;
    if (typeof top === "string") {
      centerAnchorY = parseFloat(top) / 100;
    }
  }
  return {
    left: constraintMask.left ? left : null,
    right: constraintMask.right ? right : null,
    top: constraintMask.top ? top : null,
    bottom: constraintMask.bottom ? bottom : null,
    widthType,
    heightType,
    width: widthValue,
    height: heightValue,
    aspectRatio: constraintMask.aspectRatio || null,
    centerAnchorX,
    centerAnchorY
  };
}
var ParentSizeState;
(function(ParentSizeState2) {
  ParentSizeState2[ParentSizeState2["Unknown"] = 0] = "Unknown";
  ParentSizeState2[ParentSizeState2["Disabled"] = 1] = "Disabled";
  ParentSizeState2[ParentSizeState2["DisabledForCurrentLevel"] = 2] = "DisabledForCurrentLevel";
})(ParentSizeState || (ParentSizeState = {}));
var ConstraintsContext = createContext7({ size: 0 });
function deprecatedParentSize(parentSize) {
  if (parentSize === 0 || parentSize === 1 || parentSize === 2) {
    return null;
  }
  return parentSize;
}
function useParentSize() {
  return useContext16(ConstraintsContext).size;
}
function isSize(o) {
  return typeof o === "object";
}
var ProvideParentSize = (props) => {
  const currentParentSize = useParentSize();
  const { parentSize, children } = props;
  const memoKey = isSize(parentSize) ? [parentSize.width, parentSize.height] : [parentSize, -1];
  const value = useMemo7(() => ({ size: parentSize }), memoKey);
  if (currentParentSize === 1) {
    return children ? /* @__PURE__ */ createElement11(Fragment3, null, children) : null;
  }
  return /* @__PURE__ */ createElement11(ConstraintsContext.Provider, {
    value
  }, children);
};
var ConsumeParentSize = ConstraintsContext.Consumer;
function useProvideParentSize(node, parentSize) {
  return /* @__PURE__ */ createElement11(ProvideParentSize, {
    parentSize
  }, node);
}
function useConstraints(props) {
  const parentSize = useParentSize();
  return calculateRect(props, parentSize);
}

// src/render/utils/setDocumentStyles.ts
var cache = new Set();
var styleElement;
function setDocumentStyles(css) {
  if (cache.has(css) || typeof document === "undefined")
    return;
  cache.add(css);
  if (!styleElement) {
    styleElement = document.createElement("style");
    styleElement.type = "text/css";
    document.head && document.head.appendChild(styleElement);
  }
  styleElement.appendChild(document.createTextNode(css));
}

// src/render/types/RenderEnvironment.ts
var RenderTarget;
(function(RenderTarget2) {
  RenderTarget2["canvas"] = "CANVAS";
  RenderTarget2["export"] = "EXPORT";
  RenderTarget2["thumbnail"] = "THUMBNAIL";
  RenderTarget2["preview"] = "PREVIEW";
})(RenderTarget || (RenderTarget = {}));
var RenderEnvironment = {
  imageBaseURL: "",
  target: RenderTarget.preview,
  zoom: 1
};
function executeInRenderEnvironment(customEnvironment, task) {
  const previousEnvironment = Object.assign({}, RenderEnvironment);
  Object.assign(RenderEnvironment, customEnvironment);
  const result = task();
  Object.assign(RenderEnvironment, previousEnvironment);
  return result;
}
function setGlobalRenderEnvironment(environment3) {
  Object.assign(RenderEnvironment, environment3);
}
function useRenderEnvironment(target, imageBaseURL, zoom) {
  let willChangeElements = false;
  if (RenderEnvironment.imageBaseURL !== imageBaseURL) {
    RenderEnvironment.imageBaseURL = imageBaseURL;
    willChangeElements = true;
  }
  if (RenderEnvironment.target !== target) {
    RenderEnvironment.target = target;
    willChangeElements = true;
  }
  if (RenderEnvironment.zoom !== zoom) {
    RenderEnvironment.zoom = zoom;
  }
  return { willChangeElements };
}
(function(RenderTarget2) {
  function current() {
    return RenderEnvironment.target;
  }
  RenderTarget2.current = current;
  function hasRestrictions() {
    const target = RenderEnvironment.target;
    if (target === RenderTarget2.canvas)
      return true;
    if (target === RenderTarget2.export)
      return true;
    return false;
  }
  RenderTarget2.hasRestrictions = hasRestrictions;
})(RenderTarget || (RenderTarget = {}));

// src/render/utils/injectComponentCSSRules.ts
var componentCSSRules = `

[data-framer-component-type] {
    position: absolute;
}
`;
var textCSSRules = `
[data-framer-component-type="Text"] {
    cursor: inherit;
}

[data-framer-component-text-autosized] * {
    white-space: pre;
}
`;
var stackCSSRules = `
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > *,
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-component-type],
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-stack-gap] > *,
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-stack-gap] > [data-framer-component-type] {
    position: relative;
}

[data-framer-stack-gap] > * {
    margin-top: calc(var(--stack-gap-y) / 2);
    margin-bottom: calc(var(--stack-gap-y) / 2);
    margin-right: calc(var(--stack-gap-x) / 2);
    margin-left: calc(var(--stack-gap-x) / 2);
}

/* This should take the language direction into account */
[data-framer-stack-direction-reverse="false"]
[data-framer-stack-gap]
> *:first-child,
[data-framer-stack-direction-reverse="true"]
[data-framer-stack-gap]
> *:last-child {
    margin-top: 0;
    margin-left: 0;
}

/* This should take the language direction into account */
[data-framer-stack-direction-reverse="false"]
[data-framer-stack-gap]
> *:last-child,
[data-framer-stack-direction-reverse="true"]
[data-framer-stack-gap]
> *:first-child {
    margin-right: 0;
    margin-bottom: 0;
}
`;
var navigationCSSRules = `
NavigationContainer
[data-framer-component-type="NavigationContainer"] > *,
[data-framer-component-type="NavigationContainer"] > [data-framer-component-type] {
    position: relative;
}
`;
var scrollCSSRules = `
[data-framer-component-type="Scroll"]::-webkit-scrollbar {
    display: none;
}
[data-framer-component-type="ScrollContentWrapper"] > * {
    position: relative;
}
`;
var nativeScrollCSSRules = `
[data-framer-component-type="NativeScroll"] {
    -webkit-overflow-scrolling: touch;
}

[data-framer-component-type="NativeScroll"] > * {
    position: relative;
}

[data-framer-component-type="NativeScroll"].direction-both {
    overflow-x: scroll;
    overflow-y: scroll;
}

[data-framer-component-type="NativeScroll"].direction-vertical {
    overflow-x: hidden;
    overflow-y: scroll;
}

[data-framer-component-type="NativeScroll"].direction-horizontal {
    overflow-x: scroll;
    overflow-y: hidden;
}

[data-framer-component-type="NativeScroll"].direction-vertical > * {
    width: 100% !important;
}

[data-framer-component-type="NativeScroll"].direction-horizontal > * {
    height: 100% !important;
}

[data-framer-component-type="NativeScroll"].scrollbar-hidden::-webkit-scrollbar {
    display: none;
}
`;
var pageContentWrapperWrapperCSSRules = `
[data-framer-component-type="PageContentWrapper"] > *,
[data-framer-component-type="PageContentWrapper"] > [data-framer-component-type] {
    position: relative;
}
`;
var presenceCSS = `
[data-is-present="false"], [data-is-present="false"] * {
    pointer-events: none !important;
}
`;
var cursorCSS = `
[data-framer-cursor="pointer"] {
    cursor: pointer;
}
[data-framer-cursor="grab"] {
    cursor: grab;
}
[data-framer-cursor="grab"]:active {
    cursor: grabbing;
}
`;
var frameCSSRules = (isPreview) => {
  return isPreview ? ` [data-framer-component-type="Frame"] * { pointer-events: auto; } ` : ``;
};
var textSelectionCSSRules = (isPreview) => {
  return isPreview ? `
        body :not(input):not(textarea):not([contenteditable="true"]) {
            user-select: none;
            -webkit-user-select: none;
        }

        [data-framer-component-type="Text"], [data-framer-component-type="Text"] * {
        pointer-events: none !important;
        user-select: none;
        -webkit-user-select: none;
    }` : ``;
};
var combineCSSRules = (isPreview) => `
${componentCSSRules}
${textCSSRules}
${stackCSSRules}
${navigationCSSRules}
${scrollCSSRules}
${nativeScrollCSSRules}
${pageContentWrapperWrapperCSSRules}
${presenceCSS}
${cursorCSS}
${frameCSSRules(isPreview)}
${textSelectionCSSRules(isPreview)}
`;
var combinedCSSRules = combineCSSRules(false);
var combinedCSSRulesForPreview = combineCSSRules(true);
var injectComponentCSSRules = () => {
  const styles = RenderTarget.current() === RenderTarget.preview ? combinedCSSRulesForPreview : combinedCSSRules;
  setDocumentStyles(styles);
};

// src/render/utils/processOverrideForwarding.ts
import {
  Children as Children2,
  cloneElement as cloneElement2,
  isValidElement as isValidElement2
} from "react";
function processOverrideForwarding(props, children) {
  if (!children) {
    children = props.children;
    if (!children)
      return { props, children };
  }
  let _forwardedOverrides = props._forwardedOverrides;
  const extractions = props._overrideForwardingDescription;
  if (extractions) {
    _forwardedOverrides = void 0;
    for (const key6 in extractions) {
      const propName = extractions[key6];
      const value = props[propName];
      if (value !== void 0) {
        if (!_forwardedOverrides) {
          _forwardedOverrides = {};
          props = { ...props };
        }
        _forwardedOverrides[key6] = props[propName];
        delete props[propName];
      }
    }
  }
  if (!_forwardedOverrides)
    return { props, children };
  children = Children2.map(children, (child) => {
    if (!isValidElement2(child))
      return child;
    return cloneElement2(child, { _forwardedOverrides });
  });
  return { props, children };
}

// src/render/types/Color/Utils.ts
function modulate(value, rangeA, rangeB, limit = false) {
  const [fromLow, fromHigh] = rangeA;
  const [toLow, toHigh] = rangeB;
  const result = toLow + (value - fromLow) / (fromHigh - fromLow) * (toHigh - toLow);
  if (limit === true) {
    if (toLow < toHigh) {
      if (result < toLow) {
        return toLow;
      }
      if (result > toHigh) {
        return toHigh;
      }
    } else {
      if (result > toLow) {
        return toLow;
      }
      if (result < toHigh) {
        return toHigh;
      }
    }
  }
  return result;
}
function isNumeric(value) {
  return !isNaN(value) && isFinite(value);
}
function percentToFraction(val) {
  const digits = numberFromString(val);
  if (digits !== void 0) {
    if (val.includes("%")) {
      return digits / 100;
    }
    return digits;
  }
  return 0;
}
function numberFromString(input) {
  const match = input.match(/\d?\.?\d+/);
  return match ? Number(match[0]) : void 0;
}

// src/render/types/Color/converters.ts
var import_hsluv = __toModule(require_hsluv());

// src/render/types/Color/types.ts
var ColorFormat;
(function(ColorFormat2) {
  ColorFormat2["RGB"] = "rgb";
  ColorFormat2["HSL"] = "hsl";
  ColorFormat2["HSV"] = "hsv";
  ColorFormat2["HEX"] = "hex";
  ColorFormat2["NAME"] = "name";
})(ColorFormat || (ColorFormat = {}));
var ColorMixModelType;
(function(ColorMixModelType2) {
  ColorMixModelType2["RGB"] = "rgb";
  ColorMixModelType2["RGBA"] = "rgba";
  ColorMixModelType2["HSL"] = "hsl";
  ColorMixModelType2["HSLA"] = "hsla";
  ColorMixModelType2["HUSL"] = "husl";
})(ColorMixModelType || (ColorMixModelType = {}));

// src/render/types/Color/CSSNames.ts
var cssNames = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};

// src/render/types/Color/converters.ts
function rgbToHsluv(r, g, b2) {
  const [h, s, l] = (0, import_hsluv.rgbToHsluv)([r / 255, g / 255, b2 / 255]);
  return { h, s, l };
}
function rgbaFromHusl(h, s, l, a2 = 1) {
  const rgb = (0, import_hsluv.hsluvToRgb)([h, s, l]);
  return {
    r: rgb[0] * 255,
    g: rgb[1] * 255,
    b: rgb[2] * 255,
    a: a2
  };
}
function hsvToStr(h, s, v, a2) {
  const _h = Math.round(h);
  const _s = Math.round(s * 100);
  const _v = Math.round(v * 100);
  return a2 === void 0 || a2 === 1 ? "hsv(" + _h + ", " + _s + "%, " + _v + "%)" : "hsva(" + _h + ", " + _s + "%, " + _v + "%, " + a2 + ")";
}
function rgbToRgb(r, g, b2) {
  return {
    r: isNumeric(r) ? bound01(r, 255) * 255 : 0,
    g: isNumeric(g) ? bound01(g, 255) * 255 : 0,
    b: isNumeric(b2) ? bound01(b2, 255) * 255 : 0
  };
}
function rgbToHex(r, g, b2, allow3Char) {
  const hex2 = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b2).toString(16))];
  if (allow3Char && hex2[0].charAt(0) === hex2[0].charAt(1) && hex2[1].charAt(0) === hex2[1].charAt(1) && hex2[2].charAt(0) === hex2[2].charAt(1)) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
  }
  return hex2.join("");
}
function rgbToHsl(r, g, b2) {
  let l;
  let s;
  const _r = bound01(r, 255);
  const _g = bound01(g, 255);
  const _b = bound01(b2, 255);
  const max = Math.max(_r, _g, _b);
  const min = Math.min(_r, _g, _b);
  let h = s = l = (max + min) / 2;
  if (max === min) {
    h = s = 0;
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case _r:
        h = (_g - _b) / d + (_g < _b ? 6 : 0);
        break;
      case _g:
        h = (_b - _r) / d + 2;
        break;
      case _b:
        h = (_r - _g) / d + 4;
        break;
    }
    h /= 6;
  }
  return { h: h * 360, s, l };
}
function hue2rgb(p, q, t) {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p + (q - p) * 6 * t;
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }
  return p;
}
function hslToRgb(h, s, l) {
  let r;
  let g;
  let b2;
  h = bound01(h, 360);
  s = bound01(s * 100, 100);
  l = bound01(l * 100, 100);
  if (s === 0) {
    r = g = b2 = l;
  } else {
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b2 = hue2rgb(p, q, h - 1 / 3);
  }
  return { r: r * 255, g: g * 255, b: b2 * 255 };
}
function rgbToHsv(r, g, b2) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b2 = bound01(b2, 255);
  const max = Math.max(r, g, b2);
  const min = Math.min(r, g, b2);
  const d = max - min;
  let h;
  const s = max === 0 ? 0 : d / max;
  const v = max;
  if (max === min) {
    h = 0;
  } else {
    switch (max) {
      case r:
        h = (g - b2) / d + (g < b2 ? 6 : 0);
        break;
      case g:
        h = (b2 - r) / d + 2;
        break;
      case b2:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return { h, s, v };
}
function hsvToRgb(h, s, v) {
  h = bound01(h, 360) * 6;
  s = bound01(s * 100, 100);
  v = bound01(v * 100, 100);
  const i = Math.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i % 6, r = [v, q, p, p, t, v][mod], g = [t, v, v, q, p, p][mod], b2 = [p, p, t, v, v, q][mod];
  return { r: r * 255, g: g * 255, b: b2 * 255 };
}
function bound01(n, max) {
  let _max;
  let _n;
  if (typeof max === "string")
    _max = parseFloat(max);
  else
    _max = max;
  if (typeof n === "string") {
    if (isOnePointZero(n)) {
      n = "100%";
    }
    const processPercent = isPercentage(n);
    _n = Math.min(_max, Math.max(0, parseFloat(n)));
    if (processPercent) {
      _n = Math.floor(_n * _max) / 100;
    }
  } else {
    _n = n;
  }
  if (Math.abs(_n - _max) < 1e-6) {
    return 1;
  }
  return _n % _max / _max;
}
function isOnePointZero(n) {
  return typeof n === "string" && n.includes(".") && parseFloat(n) === 1;
}
function isPercentage(n) {
  return typeof n === "string" && n.includes("%");
}
function pad2(char) {
  if (char.length === 1) {
    return "0" + char;
  } else {
    return "" + char;
  }
}
var matchers = function() {
  const cssInteger = "[-\\+]?\\d+%?";
  const cssNumber = "[-\\+]?\\d*\\.\\d+%?";
  const cssUnit = "(?:" + cssNumber + ")|(?:" + cssInteger + ")";
  const permissiveMatch3 = "[\\s|\\(]+(" + cssUnit + ")[,|\\s]+(" + cssUnit + ")[,|\\s]+(" + cssUnit + ")\\s*\\)?";
  const permissiveMatch4 = "[\\s|\\(]+(" + cssUnit + ")[,|\\s]+(" + cssUnit + ")[,|\\s]+(" + cssUnit + ")[,|\\s]+(" + cssUnit + ")\\s*\\)?";
  return {
    rgb: new RegExp("rgb" + permissiveMatch3),
    rgba: new RegExp("rgba" + permissiveMatch4),
    hsl: new RegExp("hsl" + permissiveMatch3),
    hsla: new RegExp("hsla" + permissiveMatch4),
    hsv: new RegExp("hsv" + permissiveMatch3),
    hsva: new RegExp("hsva" + permissiveMatch4),
    hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function stringToObject(inputColor) {
  if (inputColor.includes("gradient("))
    return false;
  if (inputColor.includes("var("))
    return false;
  const trimLeft = /^[\s,#]+/;
  const trimRight = /\s+$/;
  let color2 = inputColor.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  let named = false;
  if (cssNames[color2]) {
    color2 = cssNames[color2];
    named = true;
  }
  if (color2 === "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: ColorFormat.NAME
    };
  }
  let match;
  if (match = matchers.rgb.exec(color2)) {
    return {
      r: parseInt(match[1]),
      g: parseInt(match[2]),
      b: parseInt(match[3]),
      a: 1,
      format: ColorFormat.RGB
    };
  }
  if (match = matchers.rgba.exec(color2)) {
    return {
      r: parseInt(match[1]),
      g: parseInt(match[2]),
      b: parseInt(match[3]),
      a: parseFloat(match[4]),
      format: ColorFormat.RGB
    };
  }
  if (match = matchers.hsl.exec(color2)) {
    return {
      h: parseInt(match[1]),
      s: percentToFraction(match[2]),
      l: percentToFraction(match[3]),
      a: 1,
      format: ColorFormat.HSL
    };
  }
  if (match = matchers.hsla.exec(color2)) {
    return {
      h: parseInt(match[1]),
      s: percentToFraction(match[2]),
      l: percentToFraction(match[3]),
      a: parseFloat(match[4]),
      format: ColorFormat.HSL
    };
  }
  if (match = matchers.hsv.exec(color2)) {
    return {
      h: parseInt(match[1]),
      s: percentToFraction(match[2]),
      v: percentToFraction(match[3]),
      a: 1,
      format: ColorFormat.HSV
    };
  }
  if (match = matchers.hsva.exec(color2)) {
    return {
      h: parseInt(match[1]),
      s: percentToFraction(match[2]),
      v: percentToFraction(match[3]),
      a: parseFloat(match[4]),
      format: ColorFormat.HSV
    };
  }
  if (match = matchers.hex8.exec(color2)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? ColorFormat.NAME : ColorFormat.HEX
    };
  }
  if (match = matchers.hex6.exec(color2)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: 1,
      format: named ? ColorFormat.NAME : ColorFormat.HEX
    };
  }
  if (match = matchers.hex4.exec(color2)) {
    return {
      r: parseIntFromHex(`${match[1]}${match[1]}`),
      g: parseIntFromHex(`${match[2]}${match[2]}`),
      b: parseIntFromHex(`${match[3]}${match[3]}`),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: named ? ColorFormat.NAME : ColorFormat.HEX
    };
  }
  if (match = matchers.hex3.exec(color2)) {
    return {
      r: parseIntFromHex(`${match[1]}${match[1]}`),
      g: parseIntFromHex(`${match[2]}${match[2]}`),
      b: parseIntFromHex(`${match[3]}${match[3]}`),
      a: 1,
      format: named ? ColorFormat.NAME : ColorFormat.HEX
    };
  } else {
    return false;
  }
}
function parseIntFromHex(hex2) {
  return parseInt(hex2, 16);
}
function convertHexToDecimal(h) {
  return parseIntFromHex(h) / 255;
}

// src/render/types/Color/Color.ts
var cache2 = new Map();
function Color(color2, r, g, b2) {
  if (typeof color2 === "string") {
    let c2 = cache2.get(color2);
    if (c2)
      return c2;
    c2 = createColor(color2);
    if (c2 === void 0)
      return { ...Color("black"), isValid: false };
    cache2.set(color2, c2);
    return c2;
  }
  const created = createColor(color2, r, g, b2);
  return created !== void 0 ? created : { ...Color("black"), isValid: false };
}
function createColor(color2, r, g, b2) {
  if (color2 === "")
    return void 0;
  const colorData = getCompleteColorStrategy(color2, r, g, b2);
  if (colorData) {
    const newColor = {
      r: colorData.r,
      g: colorData.g,
      b: colorData.b,
      a: colorData.a,
      h: colorData.h,
      s: colorData.s,
      l: colorData.l,
      initialValue: typeof color2 === "string" && colorData.format !== ColorFormat.HSV ? color2 : void 0,
      roundA: Math.round(100 * colorData.a) / 100,
      format: colorData.format,
      mix: Color.mix,
      toValue: () => Color.toRgbString(newColor)
    };
    return newColor;
  } else {
    return void 0;
  }
}
(function(Color2) {
  function inspect2(color2, initialValue) {
    if (color2.format === ColorFormat.HSL) {
      return `<${color2.constructor.name} h:${color2.h} s:${color2.s} l:${color2.l} a:${color2.a}>`;
    } else if (color2.format === ColorFormat.HEX || color2.format === ColorFormat.NAME) {
      return `<${color2.constructor.name} "${initialValue}">`;
    } else {
      return `<${color2.constructor.name} r:${color2.r} g:${color2.g} b:${color2.b} a:${color2.a}>`;
    }
  }
  Color2.inspect = inspect2;
  function isColor(color2) {
    if (typeof color2 === "string") {
      return Color2.isColorString(color2);
    } else {
      return Color2.isColorObject(color2);
    }
  }
  Color2.isColor = isColor;
  function isColorString2(colorString) {
    if (typeof colorString === "string") {
      return stringToObject(colorString) !== false;
    }
    return false;
  }
  Color2.isColorString = isColorString2;
  function isColorObject(color2) {
    return color2 && typeof color2 !== "string" && typeof color2.r === "number" && typeof color2.g === "number" && typeof color2.b === "number" && typeof color2.h === "number" && typeof color2.s === "number" && typeof color2.l === "number" && typeof color2.a === "number" && typeof color2.roundA === "number" && typeof color2.format === "string";
  }
  Color2.isColorObject = isColorObject;
  function toString(color2) {
    return Color2.toRgbString(color2);
  }
  Color2.toString = toString;
  function toHex(color2, allow3Char = false) {
    return rgbToHex(color2.r, color2.g, color2.b, allow3Char);
  }
  Color2.toHex = toHex;
  function toHexString(color2, allow3Char = false) {
    return `#${Color2.toHex(color2, allow3Char)}`;
  }
  Color2.toHexString = toHexString;
  function toRgbString(color2) {
    return color2.a === 1 ? "rgb(" + Math.round(color2.r) + ", " + Math.round(color2.g) + ", " + Math.round(color2.b) + ")" : "rgba(" + Math.round(color2.r) + ", " + Math.round(color2.g) + ", " + Math.round(color2.b) + ", " + color2.roundA + ")";
  }
  Color2.toRgbString = toRgbString;
  function toHusl(color2) {
    return {
      ...rgbToHsluv(color2.r, color2.g, color2.b),
      a: color2.roundA
    };
  }
  Color2.toHusl = toHusl;
  function toHslString(color2) {
    const hsl = Color2.toHsl(color2);
    const h = Math.round(hsl.h);
    const s = Math.round(hsl.s * 100);
    const l = Math.round(hsl.l * 100);
    return color2.a === 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + color2.roundA + ")";
  }
  Color2.toHslString = toHslString;
  function toHsv(color2) {
    const hsv = rgbToHsv(color2.r, color2.g, color2.b);
    return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: color2.a };
  }
  Color2.toHsv = toHsv;
  function toHsvString(color2) {
    const hsv = rgbToHsv(color2.r, color2.g, color2.b);
    const h = Math.round(hsv.h * 360);
    const s = Math.round(hsv.s * 100);
    const v = Math.round(hsv.v * 100);
    return color2.a === 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + color2.roundA + ")";
  }
  Color2.toHsvString = toHsvString;
  function toName(color2) {
    if (color2.a === 0) {
      return "transparent";
    }
    if (color2.a < 1) {
      return false;
    }
    const hex2 = rgbToHex(color2.r, color2.g, color2.b, true);
    for (const key6 of Object.keys(cssNames)) {
      const value = cssNames[key6];
      if (value === hex2) {
        return key6;
      }
    }
    return false;
  }
  Color2.toName = toName;
  function toHsl(color2) {
    return {
      h: Math.round(color2.h),
      s: color2.s,
      l: color2.l,
      a: color2.a
    };
  }
  Color2.toHsl = toHsl;
  function toRgb(color2) {
    return {
      r: Math.round(color2.r),
      g: Math.round(color2.g),
      b: Math.round(color2.b),
      a: color2.a
    };
  }
  Color2.toRgb = toRgb;
  function brighten(color2, amount = 10) {
    const rgb = Color2.toRgb(color2);
    rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
    rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
    rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
    return Color2(rgb);
  }
  Color2.brighten = brighten;
  function lighten(color2, amount = 10) {
    const hsl = Color2.toHsl(color2);
    hsl.l += amount / 100;
    hsl.l = Math.min(1, Math.max(0, hsl.l));
    return Color2(hsl);
  }
  Color2.lighten = lighten;
  function darken(color2, amount = 10) {
    const hsl = Color2.toHsl(color2);
    hsl.l -= amount / 100;
    hsl.l = Math.min(1, Math.max(0, hsl.l));
    return Color2(hsl);
  }
  Color2.darken = darken;
  function saturate(color2, amount = 10) {
    const hsl = Color2.toHsl(color2);
    hsl.s += amount / 100;
    hsl.s = Math.min(1, Math.max(0, hsl.s));
    return Color2(hsl);
  }
  Color2.saturate = saturate;
  function desaturate(color2, amount = 10) {
    const hsl = Color2.toHsl(color2);
    hsl.s -= amount / 100;
    hsl.s = Math.min(1, Math.max(0, hsl.s));
    return Color2(hsl);
  }
  Color2.desaturate = desaturate;
  function grayscale(color2) {
    return Color2.desaturate(color2, 100);
  }
  Color2.grayscale = grayscale;
  function hueRotate(color2, angle) {
    const hsl = Color2.toHsl(color2);
    hsl.h += angle;
    hsl.h = hsl.h > 360 ? hsl.h - 360 : hsl.h;
    return Color2(hsl);
  }
  Color2.hueRotate = hueRotate;
  function alpha2(color2, a2 = 1) {
    return Color2({
      r: color2.r,
      g: color2.g,
      b: color2.b,
      a: a2
    });
  }
  Color2.alpha = alpha2;
  function transparent(color2) {
    return Color2.alpha(color2, 0);
  }
  Color2.transparent = transparent;
  function multiplyAlpha(color2, alphaValue = 1) {
    return Color2({
      r: color2.r,
      g: color2.g,
      b: color2.b,
      a: color2.a * alphaValue
    });
  }
  Color2.multiplyAlpha = multiplyAlpha;
  function interpolate2(colorA, colorB, model = ColorMixModelType.RGB) {
    if (!Color2.isColorObject(colorA) || !Color2.isColorObject(colorB)) {
      throw new TypeError("Both arguments for Color.interpolate must be Color objects");
    }
    return (progress2) => {
      const color2 = Color2.mixAsColor(colorA, colorB, progress2, false, model);
      return color2;
    };
  }
  Color2.interpolate = interpolate2;
  function mix2(from, toColor, { model = ColorMixModelType.RGB } = {}) {
    const fromColor = typeof from === "string" ? Color2(from) : from;
    const mixer = Color2.interpolate(fromColor, toColor, model);
    return (p) => Color2.toRgbString(mixer(p));
  }
  Color2.mix = mix2;
  function mixAsColor(colorA, colorB, fraction2 = 0.5, limit = false, model = ColorMixModelType.RGB) {
    let result = null;
    if (ColorMixModel.isRGB(model)) {
      result = Color2({
        r: modulate(fraction2, [0, 1], [colorA.r, colorB.r], limit),
        g: modulate(fraction2, [0, 1], [colorA.g, colorB.g], limit),
        b: modulate(fraction2, [0, 1], [colorA.b, colorB.b], limit),
        a: modulate(fraction2, [0, 1], [colorA.a, colorB.a], limit)
      });
    } else {
      let hslA, hslB;
      if (ColorMixModel.isHSL(model)) {
        hslA = Color2.toHsl(colorA);
        hslB = Color2.toHsl(colorB);
      } else {
        hslA = Color2.toHusl(colorA);
        hslB = Color2.toHusl(colorB);
      }
      if (hslA.s === 0) {
        hslA.h = hslB.h;
      } else if (hslB.s === 0) {
        hslB.h = hslA.h;
      }
      const fromH = hslA.h;
      const toH = hslB.h;
      let deltaH = toH - fromH;
      if (deltaH > 180) {
        deltaH = toH - 360 - fromH;
      } else if (deltaH < -180) {
        deltaH = toH + 360 - fromH;
      }
      const tween = {
        h: modulate(fraction2, [0, 1], [fromH, fromH + deltaH], limit),
        s: modulate(fraction2, [0, 1], [hslA.s, hslB.s], limit),
        l: modulate(fraction2, [0, 1], [hslA.l, hslB.l], limit),
        a: modulate(fraction2, [0, 1], [colorA.a, colorB.a], limit)
      };
      if (ColorMixModel.isHSL(model)) {
        result = Color2(tween);
      } else {
        result = Color2(rgbaFromHusl(tween.h, tween.s, tween.l, tween.a));
      }
    }
    return result;
  }
  Color2.mixAsColor = mixAsColor;
  function random(alphaValue = 1) {
    function gen() {
      return Math.floor(Math.random() * 255);
    }
    return Color2("rgba(" + gen() + ", " + gen() + ", " + gen() + ", " + alphaValue + ")");
  }
  Color2.random = random;
  function grey(amount = 0.5, alphaValue = 1) {
    amount = Math.floor(amount * 255);
    return Color2("rgba(" + amount + ", " + amount + ", " + amount + ", " + alphaValue + ")");
  }
  Color2.grey = grey;
  Color2.gray = Color2.grey;
  function rgbToHsl2(r, g, b2) {
    return rgbToHsl(r, g, b2);
  }
  Color2.rgbToHsl = rgbToHsl2;
  Color2.isValidColorProperty = function(name, value) {
    const isColorKey = name.toLowerCase().slice(-5) === "color" || name === "fill" || name === "stroke";
    if (isColorKey && typeof value === "string" && Color2.isColorString(value)) {
      return true;
    }
    return false;
  };
  function difference(colorA, colorB) {
    const _r = (colorA.r + colorB.r) / 2;
    const deltaR = colorA.r - colorB.r;
    const deltaG = colorA.g - colorB.g;
    const deltaB = colorA.b - colorB.b;
    const deltaR2 = Math.pow(deltaR, 2);
    const deltaG2 = Math.pow(deltaG, 2);
    const deltaB2 = Math.pow(deltaB, 2);
    return Math.sqrt(2 * deltaR2 + 4 * deltaG2 + 3 * deltaB2 + _r * (deltaR2 - deltaB2) / 256);
  }
  Color2.difference = difference;
  function equal2(colorA, colorB, tolerance = 0.1) {
    if (Math.abs(colorA.r - colorB.r) >= tolerance) {
      return false;
    }
    if (Math.abs(colorA.g - colorB.g) >= tolerance) {
      return false;
    }
    if (Math.abs(colorA.b - colorB.b) >= tolerance) {
      return false;
    }
    if (Math.abs(colorA.a - colorB.a) * 256 >= tolerance) {
      return false;
    }
    return true;
  }
  Color2.equal = equal2;
})(Color || (Color = {}));
var ColorMixModel = {
  isRGB(colorModel) {
    return colorModel === ColorMixModelType.RGB || colorModel === ColorMixModelType.RGBA;
  },
  isHSL(colorModel) {
    return colorModel === ColorMixModelType.HSL || colorModel === ColorMixModelType.HSLA;
  }
};
function getCompleteColorStrategy(colorOrR, g, b2, a2 = 1) {
  let completeColor;
  if (typeof colorOrR === "number" && !Number.isNaN(colorOrR) && typeof g === "number" && !Number.isNaN(g) && typeof b2 === "number" && !Number.isNaN(b2)) {
    const _r = colorOrR;
    const _g = g;
    const _b = b2;
    const _a = a2;
    completeColor = getCompleteColorFromRGB({ r: _r, g: _g, b: _b, a: _a });
  } else if (typeof colorOrR === "string") {
    completeColor = getCompleteColorFromString(colorOrR);
  } else if (typeof colorOrR === "object") {
    if (colorOrR.hasOwnProperty("r") && colorOrR.hasOwnProperty("g") && colorOrR.hasOwnProperty("b")) {
      completeColor = getCompleteColorFromRGB(colorOrR);
    } else {
      completeColor = getCompleteColorFromHSL(colorOrR);
    }
  }
  return completeColor;
}
function getCompleteColorFromString(color2) {
  const result = stringToObject(color2);
  if (result) {
    if (result.format === ColorFormat.HSL) {
      return getCompleteColorFromHSL(result);
    } else if (result.format === ColorFormat.HSV) {
      return getCompleteColorFromHSV(result);
    } else {
      return getCompleteColorFromRGB(result);
    }
  }
}
function getCompleteColorFromHSV(color2) {
  const rgb = hsvToRgb(color2.h, color2.s, color2.v);
  const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
  return {
    ...hsl,
    ...rgb,
    format: ColorFormat.RGB,
    a: color2.a !== void 0 ? correctAlpha(color2.a) : 1
  };
}
function getCompleteColorFromRGB(color2) {
  const rgb = rgbToRgb(color2.r, color2.g, color2.b);
  const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
  return {
    ...hsl,
    ...rgb,
    format: ColorFormat.RGB,
    a: color2.a !== void 0 ? correctAlpha(color2.a) : 1
  };
}
function getCompleteColorFromHSL(color2) {
  let h;
  let s;
  let l;
  let rgb = { r: 0, g: 0, b: 0 };
  let hsl = { h: 0, s: 0, l: 0 };
  h = isNumeric(color2.h) ? color2.h : 0;
  h = (h + 360) % 360;
  s = isNumeric(color2.s) ? color2.s : 1;
  if (typeof color2.s === "string") {
    s = numberFromString(color2.s);
  }
  l = isNumeric(color2.l) ? color2.l : 0.5;
  if (typeof color2.l === "string") {
    l = numberFromString(color2.l);
  }
  rgb = hslToRgb(h, s, l);
  hsl = {
    h,
    s,
    l
  };
  return {
    ...rgb,
    ...hsl,
    a: color2.a === void 0 ? 1 : color2.a,
    format: ColorFormat.HSL
  };
}
function correctAlpha(alphaValue) {
  alphaValue = parseFloat(alphaValue);
  if (alphaValue < 0) {
    alphaValue = 0;
  }
  if (isNaN(alphaValue) || alphaValue > 1) {
    alphaValue = 1;
  }
  return alphaValue;
}

// src/render/types/Color/ConvertColor.ts
var ConvertColor;
(function(ConvertColor2) {
  function hueRotate(color2, angle) {
    return Color.toHslString(Color.hueRotate(Color(color2), angle));
  }
  ConvertColor2.hueRotate = hueRotate;
  function setAlpha(color2, alpha2) {
    return Color.toRgbString(Color.alpha(Color(color2), alpha2));
  }
  ConvertColor2.setAlpha = setAlpha;
  function getAlpha(color2) {
    const obj = stringToObject(color2);
    return obj ? obj.a : 1;
  }
  ConvertColor2.getAlpha = getAlpha;
  function multiplyAlpha(color2, alpha2) {
    return Color.toRgbString(Color.multiplyAlpha(Color(color2), alpha2));
  }
  ConvertColor2.multiplyAlpha = multiplyAlpha;
  function toHex(color2) {
    return Color.toHexString(Color(color2)).toUpperCase();
  }
  ConvertColor2.toHex = toHex;
  function toRgb(color2) {
    return Color.toRgb(Color(color2));
  }
  ConvertColor2.toRgb = toRgb;
  function toRgbString(color2) {
    return Color.toRgbString(Color(color2));
  }
  ConvertColor2.toRgbString = toRgbString;
  function toHSV(color2) {
    return Color.toHsv(Color(color2));
  }
  ConvertColor2.toHSV = toHSV;
  function toHSL(color2) {
    return Color.toHsl(Color(color2));
  }
  ConvertColor2.toHSL = toHSL;
  function toHslString(color2) {
    return Color.toHslString(Color(color2));
  }
  ConvertColor2.toHslString = toHslString;
  function toHsvString(color2) {
    return Color.toHsvString(Color(color2));
  }
  ConvertColor2.toHsvString = toHsvString;
  function hsvToHSLString(hsv) {
    return Color.toHslString(Color(hsvToStr(hsv.h, hsv.s, hsv.v, hsv.a)));
  }
  ConvertColor2.hsvToHSLString = hsvToHSLString;
  function hsvToString(hsv) {
    return hsvToStr(hsv.h, hsv.s, hsv.v);
  }
  ConvertColor2.hsvToString = hsvToString;
  function rgbaToString(color2) {
    return Color.toRgbString(Color(color2));
  }
  ConvertColor2.rgbaToString = rgbaToString;
  function hslToString(hsl) {
    return Color.toRgbString(Color(hsl));
  }
  ConvertColor2.hslToString = hslToString;
  function toColorPickerSquare(h) {
    return Color.toRgbString(Color({ h, s: 1, l: 0.5, a: 1 }));
  }
  ConvertColor2.toColorPickerSquare = toColorPickerSquare;
  function isValid(color2) {
    return Color(color2).isValid !== false;
  }
  ConvertColor2.isValid = isValid;
  function equals(a2, b2) {
    if (typeof a2 === "string") {
      a2 = Color(a2);
    }
    if (typeof b2 === "string") {
      b2 = Color(b2);
    }
    return Color.equal(a2, b2);
  }
  ConvertColor2.equals = equals;
  function toHexOrRgbaString(input) {
    const color2 = Color(input);
    return color2.a !== 1 ? Color.toRgbString(color2) : Color.toHexString(color2);
  }
  ConvertColor2.toHexOrRgbaString = toHexOrRgbaString;
})(ConvertColor || (ConvertColor = {}));

// src/render/utils/transformCustomValues.ts
var isCustomValue2 = (v) => {
  return Boolean(v && typeof v === "object" && v.mix && v.toValue);
};
var isColorProp = (key6) => key6 === "background" || key6.endsWith("color") || key6.endsWith("Color");
var resolveSingleCustomValue = (key6, v) => {
  if (v && typeof v === "object") {
    invariant(isCustomValue2(v), "Motion styles must be numbers, strings, or an instance with a `toValue` and `mix` methods.");
    return v.toValue();
  } else if (isColorProp(key6) && typeof v === "string" && Color.isColor(v)) {
    return Color(v).toValue();
  }
  return v;
};
var resolveCustomValues = (key6, v) => {
  if (Array.isArray(v)) {
    const numValues = v.length;
    const resolved = [];
    for (let i = 0; i < numValues; i++) {
      resolved.push(resolveSingleCustomValue(key6, v[i]));
    }
    return resolved;
  } else {
    return resolveSingleCustomValue(key6, v);
  }
};
var customValueHandlers = {
  size: {
    set: (inputValues, outputValues, value) => {
      if (inputValues.height === void 0) {
        outputValues.height = value;
      }
      if (inputValues.width === void 0) {
        outputValues.width = value;
      }
    },
    type: px
  },
  radius: {
    set: (inputValues, outputValues, value) => {
      outputValues.borderRadius = value;
    },
    type: px
  },
  shadow: {
    set: (inputValues, outputValues, value) => {
      outputValues.boxShadow = value;
    },
    type: complex
  }
};
var transformValues = (values) => {
  const transformedValues = {};
  for (const key6 in values) {
    const resolved = resolveCustomValues(key6, values[key6]);
    const valueHandler = customValueHandlers[key6];
    if (valueHandler) {
      const isDefaultType = valueHandler.type && typeof values[key6] === "number";
      const value = isDefaultType ? valueHandler.type.transform(values[key6]) : values[key6];
      valueHandler.set(values, transformedValues, value);
    } else {
      transformedValues[key6] = resolved;
    }
  }
  return transformedValues;
};

// src/render/presentation/Layer.tsx
import {
  Component as Component3
} from "react";

// src/render/utils/isEqual.ts
var isArray2 = Array.isArray;
var keyList = Object.keys;
var hasProp = Object.prototype.hasOwnProperty;
function equal(a2, b2, deep) {
  if (a2 === b2)
    return true;
  if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
    const arrA = isArray2(a2);
    const arrB = isArray2(b2);
    let i, length, key6;
    if (arrA && arrB) {
      length = a2.length;
      if (length !== b2.length)
        return false;
      for (i = length; i-- !== 0; ) {
        if (!deep && a2[i] !== b2[i])
          return false;
        if (deep && !equal(a2[i], b2[i], true))
          return false;
      }
      return true;
    }
    if (arrA !== arrB)
      return false;
    const dateA = a2 instanceof Date;
    const dateB = b2 instanceof Date;
    if (dateA !== dateB)
      return false;
    if (dateA && dateB)
      return a2.getTime() === b2.getTime();
    const regexpA = a2 instanceof RegExp;
    const regexpB = b2 instanceof RegExp;
    if (regexpA !== regexpB)
      return false;
    if (regexpA && regexpB)
      return a2.toString() === b2.toString();
    if (typeof a2.equals === "function" && typeof b2.equals === "function") {
      return a2.equals(b2);
    }
    const keys2 = keyList(a2);
    length = keys2.length;
    if (length !== keyList(b2).length)
      return false;
    for (i = length; i-- !== 0; ) {
      if (!hasProp.call(b2, keys2[i]))
        return false;
    }
    for (i = length; i-- !== 0; ) {
      key6 = keys2[i];
      if (key6 === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deep && a2[key6] !== b2[key6])
        return false;
      if (deep && !equal(a2[key6], b2[key6], true))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
function isEqual(a2, b2, deep = true) {
  try {
    return equal(a2, b2, deep);
  } catch (error) {
    if (error.message && error.message.match(/stack|recursion/i) || error.number === -2146828260) {
      console.warn("Warning: isEqual does not handle circular references.", error.name, error.message);
      return false;
    }
    throw error;
  }
}

// src/render/utils/useWebkitFixes.ts
import { useRef as useRef10, useEffect as useEffect16 } from "react";
function resetSetStyle(element, key6, toValue, microtask = true) {
  if (!element) {
    return;
  }
  const value = toValue ? toValue : element.style[key6];
  const reset = () => {
    element.style[key6] = value;
  };
  element.style[key6] = null;
  if (microtask) {
    void Promise.resolve().then(reset);
  } else {
    setTimeout(reset, 0);
  }
}

// src/render/utils/optionalReactDOM.ts
function optionalReactDOM() {
  if (typeof safeWindow !== "undefined" && safeWindow["ReactDOM"]) {
    return safeWindow["ReactDOM"];
  }
  return void 0;
}

// src/render/utils/elementForComponent.ts
function elementForComponent(component) {
  const ReactDOM = optionalReactDOM();
  if (!ReactDOM) {
    return null;
  }
  const element = ReactDOM.findDOMNode(component);
  return element;
}

// src/utils/environment.ts
var environment_exports = {};
__export(environment_exports, {
  deviceFont: () => deviceFont,
  deviceOS: () => deviceOS,
  devicePixelRatio: () => devicePixelRatio2,
  deviceType: () => deviceType,
  environment: () => environment,
  isAndroid: () => isAndroid,
  isBrowser: () => isBrowser2,
  isChrome: () => isChrome,
  isDataUrl: () => isDataUrl,
  isDesktop: () => isDesktop,
  isEdge: () => isEdge,
  isFileUrl: () => isFileUrl,
  isFirefox: () => isFirefox,
  isFramerX: () => isFramerX,
  isIOS: () => isIOS,
  isJP2Supported: () => isJP2Supported,
  isLocalAssetUrl: () => isLocalAssetUrl,
  isLocalServerUrl: () => isLocalServerUrl,
  isLocalUrl: () => isLocalUrl,
  isMacOS: () => isMacOS,
  isMobile: () => isMobile,
  isPhone: () => isPhone,
  isRelativeUrl: () => isRelativeUrl,
  isSafari: () => isSafari,
  isTablet: () => isTablet,
  isTest: () => isTest,
  isTouch: () => isTouch,
  isWebKit: () => isWebKit,
  isWebPSupported: () => isWebPSupported,
  isWindows: () => isWindows,
  webkitVersion: () => webkitVersion
});
var isBrowser2 = () => typeof document === "object";
var isWebKit = () => navigator.userAgent.includes("AppleWebKit/") && !isChrome() && !isEdge();
var webkitVersion = () => {
  let version2 = -1;
  const regexp = /AppleWebKit\/([\d.]+)/;
  const result = regexp.exec(navigator.userAgent);
  if (result) {
    version2 = parseFloat(result[1]);
  }
  return version2;
};
var isChrome = () => /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor) && !isEdge();
var isSafari = () => /Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor);
var isFirefox = () => /Firefox\/\d+\.\d+$/.test(navigator.userAgent);
var isFramerX = () => /FramerX/.test(navigator.userAgent);
var isEdge = () => /Edg\//.test(navigator.userAgent);
var isAndroid = () => /(android)/i.test(navigator.userAgent);
var isIOS = () => /(iPhone|iPod|iPad)/i.test(navigator.platform);
var isMacOS = () => /Mac/.test(navigator.platform);
var isWindows = () => /Win/.test(navigator.platform);
var isTouch = () => safeWindow.ontouchstart === null && safeWindow.ontouchmove === null && safeWindow.ontouchend === null;
var isDesktop = () => deviceType() === "desktop";
var isPhone = () => deviceType() === "phone";
var isTablet = () => deviceType() === "tablet";
var isMobile = () => isPhone() || isTablet();
var isFileUrl = (url) => url.startsWith("file://");
var isDataUrl = (url) => url.startsWith("data:");
var isTest = () => false;
var isRelativeUrl = (url) => !/^([a-zA-Z]{1,8}:\/\/).*$/.test(url);
var isLocalServerUrl = (url) => /[a-zA-Z]{1,8}:\/\/127\.0\.0\.1/.test(url) || /[a-zA-Z]{1,8}:\/\/localhost/.test(url);
var isLocalUrl = (url) => {
  if (isFileUrl(url))
    return true;
  if (isLocalServerUrl(url))
    return true;
  return false;
};
var isLocalAssetUrl = (url, baseUrl) => {
  if (baseUrl === null)
    baseUrl = safeWindow.location.href;
  if (isDataUrl(url))
    return false;
  if (isLocalUrl(url))
    return true;
  if (isRelativeUrl(url) && isLocalUrl(baseUrl))
    return true;
  return false;
};
var devicePixelRatio2 = () => safeWindow.devicePixelRatio;
var isJP2Supported = function() {
  if (isFirefox())
    return false;
  return isWebKit();
};
var isWebPSupported = () => isChrome();
var deviceType = () => {
  if (/(tablet)|(iPad)|(Nexus 9)/i.test(navigator.userAgent))
    return "tablet";
  if (/(mobi)/i.test(navigator.userAgent))
    return "phone";
  return "desktop";
};
var deviceOS = () => {
  if (isMacOS())
    return "macos";
  if (isIOS())
    return "ios";
  if (isAndroid())
    return "android";
  if (isWindows())
    return "windows";
};
var deviceFont = (os) => {
  if (!os) {
    os = deviceOS();
  }
  const fonts = {
    apple: "-apple-system, BlinkMacSystemFont, SF Pro Text, SF UI Text, Helvetica Neue",
    google: "Roboto, Helvetica Neue",
    microsoft: "Segoe UI, Helvetica Neue"
  };
  if (os === "macos")
    return fonts.apple;
  if (os === "ios")
    return fonts.apple;
  if (os === "android")
    return fonts.google;
  if (os === "windows")
    return fonts.microsoft;
  return fonts.apple;
};
var environment = {
  isWebKit,
  webkitVersion,
  isChrome,
  isSafari,
  isFirefox,
  isFramerX,
  isEdge,
  isAndroid,
  isIOS,
  isMacOS,
  isWindows,
  isTouch,
  isDesktop,
  isPhone,
  isTablet,
  isMobile,
  isFileUrl,
  isDataUrl,
  isRelativeUrl,
  isLocalServerUrl,
  isLocalUrl,
  isLocalAssetUrl,
  devicePixelRatio: devicePixelRatio2,
  isJP2Supported,
  isWebPSupported,
  deviceType,
  deviceOS,
  deviceFont
};

// src/render/utils/setLayerBacked.ts
var smallValue = "0.000001px";
var translateZ = ` translateZ(${smallValue})`;
var useTranslateZHack = isFramerX() || isSafari() || isTest();
function forceLayerBackingWithMotionStyle(motionStyle) {
  motionStyle.willChange = "transform";
  const onCanvas = RenderTarget.current() === RenderTarget.canvas;
  if (useTranslateZHack && onCanvas) {
    motionStyle.translateZ = smallValue;
  }
}
function forceLayerBackingWithCSSProperties(cssProperties) {
  cssProperties.willChange = "transform";
  setTranslateZHack(cssProperties, true);
}
function setTranslateZHack(style, enabled) {
  const onCanvas = RenderTarget.current() === RenderTarget.canvas;
  if (!useTranslateZHack || !onCanvas) {
    return;
  }
  const transform2 = style.transform || "";
  if (enabled) {
    const hasTranslateZ = transform2.includes(translateZ);
    if (!hasTranslateZ) {
      style.transform = transform2 + translateZ;
    }
  } else {
    style.transform = transform2.replace(translateZ, "");
  }
}

// src/render/presentation/Layer.tsx
var Layer = class extends Component3 {
  static applyWillChange(props, style, usingMotionStyle) {
    if (props.willChangeTransform) {
      if (usingMotionStyle) {
        forceLayerBackingWithMotionStyle(style);
      } else {
        forceLayerBackingWithCSSProperties(style);
      }
    }
  }
  shouldComponentUpdate(nextProps, nextState) {
    return nextProps._needsMeasure || this.state !== nextState || !isEqual(this.props, nextProps);
  }
  componentDidUpdate(prevProps) {
    const element = elementForComponent(this);
    if (this.props["clip"] && this.props["radius"] === 0 && prevProps["radius"] !== 0) {
      resetSetStyle(element, "overflow", "hidden", false);
    }
  }
};
Layer.defaultProps = {};

// src/render/utils/extractStyleFromProps.ts
function extractStyleFromProps(props, name, styleRef, into) {
  if (into === void 0) {
    into = name;
  }
  if (props[name] !== void 0) {
    styleRef[into] = props[name];
    return;
  }
}

// src/utils/string.ts
var hash = (value) => {
  let hasher = 0, i, chr;
  if (value.length === 0)
    return hasher;
  for (i = 0; i < value.length; i++) {
    chr = value.charCodeAt(i);
    hasher = (hasher << 5) - hasher + chr;
    hasher |= 0;
  }
  return hasher;
};

// src/utils/memoize.ts
function manageCache(cache4, maxEntries) {
  const size2 = cache4.size;
  if (size2 < maxEntries)
    return;
  let i = Math.round(Math.random());
  for (const key6 of cache4.keys()) {
    if ((++i & 1) === 1)
      continue;
    cache4.delete(key6);
  }
}
function memoize(maxEntries, cache4, key6, create) {
  const r = cache4.get(key6);
  if (r)
    return r;
  manageCache(cache4, maxEntries);
  const g = create(key6);
  cache4.set(key6, g);
  return g;
}

// src/render/utils/gradientColorStops.ts
var CSSVariableRegExp = /var\(.+\)/;
var colorCache = new Map();
function cachedMultiplyAlpha(s, a2) {
  const key6 = [s, a2];
  if (CSSVariableRegExp.test(s)) {
    return s;
  }
  return memoize(1e3, colorCache, key6, () => ConvertColor.multiplyAlpha(s, a2));
}
function gradientColorStops(gradient, alpha2 = 1) {
  let stops;
  if ("stops" in gradient) {
    stops = gradient.stops;
  } else {
    stops = [
      { value: gradient.start, position: 0 },
      { value: gradient.end, position: 1 }
    ];
  }
  if (alpha2 === 1) {
    return stops;
  } else {
    return stops.map((stop) => ({ ...stop, value: cachedMultiplyAlpha(stop.value, alpha2) }));
  }
}
function gradientColorStopsHash(gradient, alpha2) {
  let result = 0;
  gradientColorStops(gradient, alpha2).forEach((stop) => {
    result ^= hash(stop.value) ^ stop.position;
  });
  return result;
}

// src/render/types/SimpleGradient.ts
var simpleGradientKeys = ["start", "end"];
function isSimpleGradient(value) {
  return value && simpleGradientKeys.every((key6) => key6 in value);
}

// src/render/types/MultiStopGradient.ts
var multiStopGradientKeys = ["stops"];
function isMultiStopGradient(value) {
  return value && multiStopGradientKeys.every((key6) => key6 in value);
}

// src/render/types/LinearGradient.ts
var linearGradientKeys = ["angle", "alpha"];
var LinearGradient;
(function(LinearGradient2) {
  function isLinearGradient(value) {
    return value && linearGradientKeys.every((key6) => key6 in value) && (isSimpleGradient(value) || isMultiStopGradient(value));
  }
  LinearGradient2.isLinearGradient = isLinearGradient;
  function hash2(linearGradient) {
    return linearGradient.angle ^ gradientColorStopsHash(linearGradient, linearGradient.alpha);
  }
  LinearGradient2.hash = hash2;
  function toCSS(linearGradient, overrideAngle) {
    const stops = gradientColorStops(linearGradient, linearGradient.alpha);
    const angle = overrideAngle !== void 0 ? overrideAngle : linearGradient.angle;
    const cssStops = stops.map((stop) => `${stop.value} ${stop.position * 100}%`);
    return `linear-gradient(${angle}deg, ${cssStops.join(", ")})`;
  }
  LinearGradient2.toCSS = toCSS;
})(LinearGradient || (LinearGradient = {}));

// src/render/types/RadialGradient.ts
var radialGradientKeys = [
  "widthFactor",
  "heightFactor",
  "centerAnchorX",
  "centerAnchorY",
  "alpha"
];
var RadialGradient;
(function(RadialGradient2) {
  function isRadialGradient(value) {
    return value && radialGradientKeys.every((key6) => key6 in value) && (isSimpleGradient(value) || isMultiStopGradient(value));
  }
  RadialGradient2.isRadialGradient = isRadialGradient;
  function hash2(radialGradient) {
    return radialGradient.centerAnchorX ^ radialGradient.centerAnchorY ^ radialGradient.widthFactor ^ radialGradient.heightFactor ^ gradientColorStopsHash(radialGradient, radialGradient.alpha);
  }
  RadialGradient2.hash = hash2;
  function toCSS(radialGradient) {
    const { alpha: alpha2, widthFactor, heightFactor, centerAnchorX, centerAnchorY } = radialGradient;
    const stops = gradientColorStops(radialGradient, alpha2);
    const cssStops = stops.map((stop) => `${stop.value} ${stop.position * 100}%`);
    return `radial-gradient(${widthFactor * 100}% ${heightFactor * 100}% at ${centerAnchorX * 100}% ${centerAnchorY * 100}%, ${cssStops.join(", ")})`;
  }
  RadialGradient2.toCSS = toCSS;
})(RadialGradient || (RadialGradient = {}));

// src/render/utils/isMotionValue.ts
var isMotionValue2 = (v) => v instanceof MotionValue;

// src/render/traits/Background.ts
function collectBackgroundFromProps({ background, backgroundColor }, style) {
  if (backgroundColor) {
    if (typeof backgroundColor === "string" || isMotionValue2(backgroundColor)) {
      style.backgroundColor = backgroundColor;
    } else if (Color.isColorObject(background)) {
      style.backgroundColor = background.initialValue || Color.toRgbString(background);
    }
  } else if (background) {
    background = Animatable.get(background, null);
    if (typeof background === "string" || isMotionValue2(background)) {
      style.background = background;
    } else if (LinearGradient.isLinearGradient(background)) {
      style.background = LinearGradient.toCSS(background);
    } else if (RadialGradient.isRadialGradient(background)) {
      style.background = RadialGradient.toCSS(background);
    } else if (Color.isColorObject(background)) {
      style.backgroundColor = background.initialValue || Color.toRgbString(background);
    }
  }
}

// src/render/presentation/Frame/getStyleForFrameProps.ts
function hasLeftAndRight(style) {
  if (!style)
    return false;
  return style.left !== void 0 && style.right !== void 0;
}
function hasTopAndBottom(style) {
  if (!style)
    return false;
  return style.top !== void 0 && style.bottom !== void 0;
}
function getStyleForFrameProps(props) {
  if (!props) {
    return {};
  }
  const style = {};
  if (props.preserve3d === true) {
    style.transformStyle = "preserve-3d";
  } else if (props.preserve3d === false) {
    style.transformStyle = "flat";
  }
  if (props.backfaceVisible === true) {
    style.backfaceVisibility = "visible";
  } else if (props.backfaceVisible === false) {
    style.backfaceVisibility = "hidden";
  }
  if (style.backfaceVisibility) {
    style.WebkitBackfaceVisibility = style.backfaceVisibility;
  }
  if (props.perspective !== void 0) {
    style.perspective = style.WebkitPerspective = props.perspective;
  }
  if (!props.__fromCanvasComponent) {
    if (props.center === true) {
      style.left = "50%";
      style.top = "50%";
    } else {
      if (props.center === "x") {
        style.left = "50%";
      } else if (props.center === "y") {
        style.top = "50%";
      }
    }
  }
  extractStyleFromProps(props, "size", style);
  extractStyleFromProps(props, "width", style);
  extractStyleFromProps(props, "height", style);
  extractStyleFromProps(props, "minWidth", style);
  extractStyleFromProps(props, "minHeight", style);
  extractStyleFromProps(props, "top", style);
  extractStyleFromProps(props, "right", style);
  extractStyleFromProps(props, "bottom", style);
  extractStyleFromProps(props, "left", style);
  extractStyleFromProps(props, "position", style);
  extractStyleFromProps(props, "overflow", style);
  extractStyleFromProps(props, "opacity", style);
  if (!props._border || !props._border.borderWidth)
    extractStyleFromProps(props, "border", style);
  extractStyleFromProps(props, "borderRadius", style);
  extractStyleFromProps(props, "radius", style, "borderRadius");
  extractStyleFromProps(props, "color", style);
  extractStyleFromProps(props, "shadow", style, "boxShadow");
  extractStyleFromProps(props, "x", style);
  extractStyleFromProps(props, "y", style);
  extractStyleFromProps(props, "z", style);
  extractStyleFromProps(props, "rotate", style);
  extractStyleFromProps(props, "rotateX", style);
  extractStyleFromProps(props, "rotateY", style);
  extractStyleFromProps(props, "rotateZ", style);
  extractStyleFromProps(props, "scale", style);
  extractStyleFromProps(props, "scaleX", style);
  extractStyleFromProps(props, "scaleY", style);
  extractStyleFromProps(props, "skew", style);
  extractStyleFromProps(props, "skewX", style);
  extractStyleFromProps(props, "skewY", style);
  extractStyleFromProps(props, "originX", style);
  extractStyleFromProps(props, "originY", style);
  extractStyleFromProps(props, "originZ", style);
  collectBackgroundFromProps(props, style);
  return style;
}

// src/render/utils/useLayoutId.ts
import { useContext as useContext18, useMemo as useMemo9 } from "react";

// src/components/AnimateLayout/LayoutIdContext.tsx
import {
  Fragment as Fragment4,
  createContext as createContext8,
  createElement as createElement12
} from "react";
import { useRef as useRef11, useCallback as useCallback3, useContext as useContext17, useMemo as useMemo8 } from "react";
var LayoutIdContext = createContext8({
  getLayoutId: (args) => null,
  persistLayoutIdCache: () => {
  },
  top: false,
  enabled: true
});
function LayoutIdProvider({ children }) {
  const context = useContext17(LayoutIdContext);
  if (context.top)
    return /* @__PURE__ */ createElement12(Fragment4, null, children);
  const cache4 = useRef11({
    byId: {},
    byName: {},
    byLastId: {},
    byPossibleId: {},
    byLastName: {},
    byLayoutId: {},
    count: {
      byId: {},
      byName: {}
    }
  });
  const screen = useRef11({
    byId: {},
    byName: {},
    byLastId: {},
    byPossibleId: {},
    byLastName: {},
    byLayoutId: {}
  });
  const usedIds = useRef11(new Set()).current;
  const getLayoutId = useCallback3(({ id, name, duplicatedFrom }) => {
    if (!id)
      return null;
    const cacheKey = name ? "byName" : "byId";
    const previousId = cache4.current[cacheKey][id];
    if (previousId)
      return previousId;
    const nodeIdentifier = name || id;
    if (!duplicatedFrom && !usedIds.has(nodeIdentifier) && (!cache4.current.byLayoutId[nodeIdentifier] || cache4.current.byLayoutId[nodeIdentifier] === nodeIdentifier)) {
      if (cache4.current.count[cacheKey][nodeIdentifier] === void 0) {
        cache4.current.count[cacheKey][nodeIdentifier] = 0;
        cache4.current.byLayoutId[nodeIdentifier] = nodeIdentifier;
        screen.current[cacheKey][id] = nodeIdentifier;
      }
      usedIds.add(nodeIdentifier);
      return nodeIdentifier;
    }
    let possibleMatch = void 0;
    if (duplicatedFrom == null ? void 0 : duplicatedFrom.length) {
      for (let index = duplicatedFrom.length - 1; index >= 0; index--) {
        const duplicatedId = duplicatedFrom[index];
        const match = cache4.current[cacheKey][duplicatedId];
        const byLastIdMatch = cache4.current.byLastId[duplicatedId];
        if (byLastIdMatch && !possibleMatch) {
          const matchedLayoutId = cache4.current.byLayoutId[byLastIdMatch];
          const shouldUseNamedLastIdMatch = !matchedLayoutId || matchedLayoutId === name;
          if (byLastIdMatch && !usedIds.has(byLastIdMatch) && (name ? shouldUseNamedLastIdMatch : true)) {
            possibleMatch = [byLastIdMatch, duplicatedId];
          }
        }
        const previousLayoutId = cache4.current.byLayoutId[match];
        const shouldUseNamedMatch = !previousLayoutId || previousLayoutId === name;
        if (match && !usedIds.has(match) && (name ? shouldUseNamedMatch : true)) {
          screen.current[cacheKey][id] = match;
          screen.current.byLastId[duplicatedId] = match;
          usedIds.add(match);
          return match;
        }
      }
    }
    const last = cache4.current.byLastId[id];
    if (last && !usedIds.has(last)) {
      usedIds.add(last);
      screen.current.byId[id] = last;
      return last;
    }
    if (possibleMatch) {
      const [match, duplicatedId] = possibleMatch;
      screen.current[cacheKey][id] = match;
      screen.current.byLastId[duplicatedId] = match;
      usedIds.add(match);
      return match;
    }
    const possible = cache4.current.byPossibleId[id];
    if (possible && !usedIds.has(possible)) {
      usedIds.add(possible);
      screen.current.byId[id] = possible;
      return possible;
    }
    const rootDuplicatedId = duplicatedFrom == null ? void 0 : duplicatedFrom[0];
    const identifier = name || rootDuplicatedId || id;
    const value = cache4.current.count[cacheKey][identifier] + 1 || 0;
    const { layoutId, value: nextValue } = nextLayoutId(identifier, value, usedIds);
    cache4.current.count[cacheKey][identifier] = nextValue;
    screen.current[cacheKey][id] = layoutId;
    if (duplicatedFrom == null ? void 0 : duplicatedFrom.length) {
      if (!name) {
        screen.current.byLastId[duplicatedFrom[duplicatedFrom.length - 1]] = layoutId;
        if (duplicatedFrom.length > 1) {
          for (let index = 0; index < duplicatedFrom.length - 1; index++) {
            const possibleId = duplicatedFrom[index];
            if (!screen.current.byPossibleId[possibleId]) {
              screen.current.byPossibleId[possibleId] = layoutId;
            }
          }
        }
      }
    }
    screen.current.byLayoutId[layoutId] = nodeIdentifier;
    usedIds.add(layoutId);
    return layoutId;
  }, []);
  const persistLayoutIdCache = useCallback3(() => {
    cache4.current = {
      byId: {
        ...cache4.current.byId,
        ...screen.current.byId
      },
      byLastId: {
        ...cache4.current.byLastId,
        ...screen.current.byLastId
      },
      byPossibleId: {
        ...cache4.current.byPossibleId,
        ...screen.current.byPossibleId
      },
      byName: {
        ...cache4.current.byName,
        ...screen.current.byName
      },
      byLastName: { ...cache4.current.byLastName, ...screen.current.byLastName },
      byLayoutId: { ...cache4.current.byLayoutId, ...screen.current.byLayoutId },
      count: {
        ...cache4.current.count,
        byName: {}
      }
    };
    screen.current = {
      byId: {},
      byName: {},
      byLastId: {},
      byPossibleId: {},
      byLastName: {},
      byLayoutId: {}
    };
    usedIds.clear();
  }, []);
  const contextValue = useRef11({
    getLayoutId,
    persistLayoutIdCache,
    top: true,
    enabled: true
  }).current;
  return /* @__PURE__ */ createElement12(LayoutIdContext.Provider, {
    value: contextValue
  }, children);
}
function nextLayoutId(identifier, initialValue, usedIds) {
  let value = initialValue;
  let layoutId = value ? `${identifier}-${value}` : identifier;
  while (usedIds.has(layoutId)) {
    value++;
    layoutId = `${identifier}-${value}`;
  }
  return { layoutId, value };
}
function AutomaticLayoutIds({ enabled = true, ...props }) {
  const context = useContext17(LayoutIdContext);
  const contextValue = useMemo8(() => {
    return {
      ...context,
      enabled
    };
  }, [enabled]);
  return /* @__PURE__ */ createElement12(LayoutIdContext.Provider, {
    ...props,
    value: contextValue
  });
}

// src/render/utils/useLayoutId.ts
function useLayoutId2(props, { specificLayoutId, postfix } = {}) {
  const { name, layoutIdKey, duplicatedFrom, __fromCodeComponentNode = false } = props;
  const { getLayoutId, enabled } = useContext18(LayoutIdContext);
  return useMemo9(() => {
    if (!enabled)
      return props.layoutId;
    const existingLayoutId = specificLayoutId || props.layoutId;
    if (!existingLayoutId) {
      if (!layoutIdKey || __fromCodeComponentNode)
        return void 0;
    }
    const layoutIdCandidate = existingLayoutId || getLayoutId({ id: layoutIdKey, name, duplicatedFrom });
    if (!layoutIdCandidate)
      return void 0;
    return postfix ? `${layoutIdCandidate}-${postfix}` : layoutIdCandidate;
  }, [enabled]);
}

// src/render/utils/transformTemplate.ts
function transformTemplate(center) {
  return (_, generated) => {
    if (center === true) {
      return `translate(-50%, -50%) ${generated}`;
    } else {
      if (center === "x") {
        return `translateX(-50%) ${generated}`;
      } else if (center === "y") {
        return `translateY(-50%) ${generated}`;
      }
    }
    return generated || "none";
  };
}

// src/render/utils/useMeasureLayout.ts
import { useLayoutEffect as useLayoutEffect3, useContext as useContext19 } from "react";

// src/utils/runtimeInjection.ts
var mockWithWarning = (message) => {
  return () => {
    warnOnce(message);
  };
};
var implementation = {
  useImageSource(image) {
    return image.src;
  },
  useImageElement(image, rect, nodeId) {
    const element = new Image();
    element.src = runtime.useImageSource(image, rect, nodeId);
    return element;
  }
};
var isRuntimeInjected = false;
var runtimeProxy = {
  get(target, key6, reciever) {
    if (Reflect.has(target, key6)) {
      return Reflect.get(target, key6, reciever);
    }
    if (isRuntimeInjected) {
      return mockWithWarning(`${String(key6)} is not available in this version of Framer.`);
    } else {
      return mockWithWarning(`${String(key6)} is only available inside of Framer. https://www.framer.com/`);
    }
  }
};
var runtime = new Proxy(implementation, runtimeProxy);
function _injectRuntime(injectedRuntime) {
  Object.assign(implementation, injectedRuntime);
  isRuntimeInjected = true;
}

// src/render/utils/nodeIdFromString.ts
function nodeIdFromString(str) {
  return str.replace(/^id_/, "").replace(/\\/g, "");
}

// src/render/presentation/ComponentContainerContext.tsx
import {
  createContext as createContext9
} from "react";
var ComponentContainerContext = createContext9(false);

// src/components/hoc/withMeasuredSize.tsx
import {
  createElement as createElement13,
  useLayoutEffect as useLayoutEffect2,
  useRef as useRef12
} from "react";

// src/modules/useForceUpdate.ts
import {
  useCallback as useCallback4,
  useState as useState7
} from "react";
function useForceUpdate2() {
  const [_, setForcedRenderCount] = useState7(0);
  return useCallback4(() => setForcedRenderCount((v) => v + 1), []);
}

// ../../node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js
var resizeObservers = [];

// ../../node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js
var hasActiveObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.activeTargets.length > 0;
  });
};

// ../../node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js
var hasSkippedObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.skippedTargets.length > 0;
  });
};

// ../../node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js
var msg = "ResizeObserver loop completed with undelivered notifications.";
var deliverResizeLoopError = function() {
  var event;
  if (typeof ErrorEvent === "function") {
    event = new ErrorEvent("error", {
      message: msg
    });
  } else {
    event = document.createEvent("Event");
    event.initEvent("error", false, false);
    event.message = msg;
  }
  window.dispatchEvent(event);
};

// ../../node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js
var ResizeObserverBoxOptions;
(function(ResizeObserverBoxOptions2) {
  ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
  ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
  ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));

// ../../node_modules/@juggle/resize-observer/lib/utils/freeze.js
var freeze = function(obj) {
  return Object.freeze(obj);
};

// ../../node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js
var ResizeObserverSize = function() {
  function ResizeObserverSize2(inlineSize, blockSize) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    freeze(this);
  }
  return ResizeObserverSize2;
}();

// ../../node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js
var DOMRectReadOnly = function() {
  function DOMRectReadOnly2(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.top = this.y;
    this.left = this.x;
    this.bottom = this.top + this.height;
    this.right = this.left + this.width;
    return freeze(this);
  }
  DOMRectReadOnly2.prototype.toJSON = function() {
    var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
    return { x, y, top, right, bottom, left, width, height };
  };
  DOMRectReadOnly2.fromRect = function(rectangle) {
    return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  };
  return DOMRectReadOnly2;
}();

// ../../node_modules/@juggle/resize-observer/lib/utils/element.js
var isSVG = function(target) {
  return target instanceof SVGElement && "getBBox" in target;
};
var isHidden = function(target) {
  if (isSVG(target)) {
    var _a = target.getBBox(), width = _a.width, height = _a.height;
    return !width && !height;
  }
  var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement = function(obj) {
  var _a, _b;
  if (obj instanceof Element) {
    return true;
  }
  var scope = (_b = (_a = obj) === null || _a === void 0 ? void 0 : _a.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView;
  return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function(target) {
  switch (target.tagName) {
    case "INPUT":
      if (target.type !== "image") {
        break;
      }
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return true;
  }
  return false;
};

// ../../node_modules/@juggle/resize-observer/lib/utils/global.js
var global2 = typeof window !== "undefined" ? window : {};

// ../../node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js
var cache3 = new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(global2.navigator && global2.navigator.userAgent);
var parseDimension = function(pixel) {
  return parseFloat(pixel || "0");
};
var size = function(inlineSize, blockSize, switchSizes) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }
  if (blockSize === void 0) {
    blockSize = 0;
  }
  if (switchSizes === void 0) {
    switchSizes = false;
  }
  return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = freeze({
  devicePixelContentBoxSize: size(),
  borderBoxSize: size(),
  contentBoxSize: size(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function(target, forceRecalculation) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }
  if (cache3.has(target) && !forceRecalculation) {
    return cache3.get(target);
  }
  if (isHidden(target)) {
    cache3.set(target, zeroBoxes);
    return zeroBoxes;
  }
  var cs = getComputedStyle(target);
  var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === "border-box";
  var switchSizes = verticalRegexp.test(cs.writingMode || "");
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
  var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
  var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
  var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
  var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft + borderRight;
  var verticalBorderArea = borderTop + borderBottom;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = freeze({
    devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  cache3.set(target, boxes);
  return boxes;
};
var calculateBoxSize = function(target, observedBox, forceRecalculation) {
  var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
};

// ../../node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js
var ResizeObserverEntry = function() {
  function ResizeObserverEntry2(target) {
    var boxes = calculateBoxSizes(target);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = freeze([boxes.borderBoxSize]);
    this.contentBoxSize = freeze([boxes.contentBoxSize]);
    this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry2;
}();

// ../../node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js
var calculateDepthForNode = function(node) {
  if (isHidden(node)) {
    return Infinity;
  }
  var depth = 0;
  var parent = node.parentNode;
  while (parent) {
    depth += 1;
    parent = parent.parentNode;
  }
  return depth;
};

// ../../node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js
var broadcastActiveObservations = function() {
  var shallowestDepth = Infinity;
  var callbacks2 = [];
  resizeObservers.forEach(function processObserver(ro) {
    if (ro.activeTargets.length === 0) {
      return;
    }
    var entries = [];
    ro.activeTargets.forEach(function processTarget(ot) {
      var entry = new ResizeObserverEntry(ot.target);
      var targetDepth = calculateDepthForNode(ot.target);
      entries.push(entry);
      ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
      if (targetDepth < shallowestDepth) {
        shallowestDepth = targetDepth;
      }
    });
    callbacks2.push(function resizeObserverCallback() {
      ro.callback.call(ro.observer, entries, ro.observer);
    });
    ro.activeTargets.splice(0, ro.activeTargets.length);
  });
  for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
    var callback = callbacks_1[_i];
    callback();
  }
  return shallowestDepth;
};

// ../../node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js
var gatherActiveObservationsAtDepth = function(depth) {
  resizeObservers.forEach(function processObserver(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length);
    ro.skippedTargets.splice(0, ro.skippedTargets.length);
    ro.observationTargets.forEach(function processTarget(ot) {
      if (ot.isActive()) {
        if (calculateDepthForNode(ot.target) > depth) {
          ro.activeTargets.push(ot);
        } else {
          ro.skippedTargets.push(ot);
        }
      }
    });
  });
};

// ../../node_modules/@juggle/resize-observer/lib/utils/process.js
var process2 = function() {
  var depth = 0;
  gatherActiveObservationsAtDepth(depth);
  while (hasActiveObservations()) {
    depth = broadcastActiveObservations();
    gatherActiveObservationsAtDepth(depth);
  }
  if (hasSkippedObservations()) {
    deliverResizeLoopError();
  }
  return depth > 0;
};

// ../../node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js
var trigger;
var callbacks = [];
var notify = function() {
  return callbacks.splice(0).forEach(function(cb2) {
    return cb2();
  });
};
var queueMicroTask = function(callback) {
  if (!trigger) {
    var toggle_1 = 0;
    var el_1 = document.createTextNode("");
    var config = { characterData: true };
    new MutationObserver(function() {
      return notify();
    }).observe(el_1, config);
    trigger = function() {
      el_1.textContent = "" + (toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback);
  trigger();
};

// ../../node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js
var queueResizeObserver = function(cb2) {
  queueMicroTask(function ResizeObserver2() {
    requestAnimationFrame(cb2);
  });
};

// ../../node_modules/@juggle/resize-observer/lib/utils/scheduler.js
var watching = 0;
var isWatching = function() {
  return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
var events = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
];
var time = function(timeout) {
  if (timeout === void 0) {
    timeout = 0;
  }
  return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = function() {
  function Scheduler2() {
    var _this = this;
    this.stopped = true;
    this.listener = function() {
      return _this.schedule();
    };
  }
  Scheduler2.prototype.run = function(timeout) {
    var _this = this;
    if (timeout === void 0) {
      timeout = CATCH_PERIOD;
    }
    if (scheduled) {
      return;
    }
    scheduled = true;
    var until = time(timeout);
    queueResizeObserver(function() {
      var elementsHaveResized = false;
      try {
        elementsHaveResized = process2();
      } finally {
        scheduled = false;
        timeout = until - time();
        if (!isWatching()) {
          return;
        }
        if (elementsHaveResized) {
          _this.run(1e3);
        } else if (timeout > 0) {
          _this.run(timeout);
        } else {
          _this.start();
        }
      }
    });
  };
  Scheduler2.prototype.schedule = function() {
    this.stop();
    this.run();
  };
  Scheduler2.prototype.observe = function() {
    var _this = this;
    var cb2 = function() {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };
    document.body ? cb2() : global2.addEventListener("DOMContentLoaded", cb2);
  };
  Scheduler2.prototype.start = function() {
    var _this = this;
    if (this.stopped) {
      this.stopped = false;
      this.observer = new MutationObserver(this.listener);
      this.observe();
      events.forEach(function(name) {
        return global2.addEventListener(name, _this.listener, true);
      });
    }
  };
  Scheduler2.prototype.stop = function() {
    var _this = this;
    if (!this.stopped) {
      this.observer && this.observer.disconnect();
      events.forEach(function(name) {
        return global2.removeEventListener(name, _this.listener, true);
      });
      this.stopped = true;
    }
  };
  return Scheduler2;
}();
var scheduler = new Scheduler();
var updateCount = function(n) {
  !watching && n > 0 && scheduler.start();
  watching += n;
  !watching && scheduler.stop();
};

// ../../node_modules/@juggle/resize-observer/lib/ResizeObservation.js
var skipNotifyOnElement = function(target) {
  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
};
var ResizeObservation = function() {
  function ResizeObservation2(target, observedBox) {
    this.target = target;
    this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
    this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  ResizeObservation2.prototype.isActive = function() {
    var size2 = calculateBoxSize(this.target, this.observedBox, true);
    if (skipNotifyOnElement(this.target)) {
      this.lastReportedSize = size2;
    }
    if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
      return true;
    }
    return false;
  };
  return ResizeObservation2;
}();

// ../../node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js
var ResizeObserverDetail = function() {
  function ResizeObserverDetail2(resizeObserver, callback) {
    this.activeTargets = [];
    this.skippedTargets = [];
    this.observationTargets = [];
    this.observer = resizeObserver;
    this.callback = callback;
  }
  return ResizeObserverDetail2;
}();

// ../../node_modules/@juggle/resize-observer/lib/ResizeObserverController.js
var observerMap = new WeakMap();
var getObservationIndex = function(observationTargets, target) {
  for (var i = 0; i < observationTargets.length; i += 1) {
    if (observationTargets[i].target === target) {
      return i;
    }
  }
  return -1;
};
var ResizeObserverController = function() {
  function ResizeObserverController2() {
  }
  ResizeObserverController2.connect = function(resizeObserver, callback) {
    var detail = new ResizeObserverDetail(resizeObserver, callback);
    observerMap.set(resizeObserver, detail);
  };
  ResizeObserverController2.observe = function(resizeObserver, target, options) {
    var detail = observerMap.get(resizeObserver);
    var firstObservation = detail.observationTargets.length === 0;
    if (getObservationIndex(detail.observationTargets, target) < 0) {
      firstObservation && resizeObservers.push(detail);
      detail.observationTargets.push(new ResizeObservation(target, options && options.box));
      updateCount(1);
      scheduler.schedule();
    }
  };
  ResizeObserverController2.unobserve = function(resizeObserver, target) {
    var detail = observerMap.get(resizeObserver);
    var index = getObservationIndex(detail.observationTargets, target);
    var lastObservation = detail.observationTargets.length === 1;
    if (index >= 0) {
      lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
      detail.observationTargets.splice(index, 1);
      updateCount(-1);
    }
  };
  ResizeObserverController2.disconnect = function(resizeObserver) {
    var _this = this;
    var detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function(ot) {
      return _this.unobserve(resizeObserver, ot.target);
    });
    detail.activeTargets.splice(0, detail.activeTargets.length);
  };
  return ResizeObserverController2;
}();

// ../../node_modules/@juggle/resize-observer/lib/ResizeObserver.js
var ResizeObserver = function() {
  function ResizeObserver2(callback) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (typeof callback !== "function") {
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    }
    ResizeObserverController.connect(this, callback);
  }
  ResizeObserver2.prototype.observe = function(target, options) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.observe(this, target, options);
  };
  ResizeObserver2.prototype.unobserve = function(target) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.unobserve(this, target);
  };
  ResizeObserver2.prototype.disconnect = function() {
    ResizeObserverController.disconnect(this);
  };
  ResizeObserver2.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  };
  return ResizeObserver2;
}();

// src/components/hoc/withMeasuredSize.tsx
var DEFAULT_SIZE = 200;
var _sharedResizeObserver, _callbacks;
var SharedObserver = class {
  constructor() {
    __privateAdd(this, _sharedResizeObserver, void 0);
    __privateAdd(this, _callbacks, new WeakMap());
    var _a;
    const ResizeObserver2 = (_a = window.ResizeObserver) != null ? _a : ResizeObserver;
    __privateSet(this, _sharedResizeObserver, new ResizeObserver2(this.updateResizedElements.bind(this)));
  }
  updateResizedElements(entries) {
    for (const entry of entries) {
      const callbackForElement = __privateGet(this, _callbacks).get(entry.target);
      if (callbackForElement)
        callbackForElement(entry.contentRect);
    }
  }
  observeElementWithCallback(element, callback) {
    __privateGet(this, _sharedResizeObserver).observe(element);
    __privateGet(this, _callbacks).set(element, callback);
  }
  unobserve(element) {
    __privateGet(this, _sharedResizeObserver).unobserve(element);
    __privateGet(this, _callbacks).delete(element);
  }
};
_sharedResizeObserver = new WeakMap();
_callbacks = new WeakMap();
var sharedResizeObserver = new SharedObserver();
function useMeasuredSize(ref) {
  const forceUpdate = useForceUpdate2();
  const size2 = useRef12(null);
  function updateSize(newSize) {
    if (newSize.width === 0 && newSize.height === 0)
      return;
    if (!size2.current || newSize.height !== size2.current.height || newSize.width !== size2.current.width) {
      size2.current = { width: newSize.width, height: newSize.height };
      forceUpdate();
    }
  }
  useLayoutEffect2(() => {
    if (!ref.current)
      return;
    const { offsetWidth, offsetHeight } = ref.current;
    updateSize({
      width: offsetWidth,
      height: offsetHeight
    });
    sharedResizeObserver.observeElementWithCallback(ref.current, updateSize);
    return () => {
      if (!ref.current)
        return;
      sharedResizeObserver.unobserve(ref.current);
    };
  }, []);
  return size2.current;
}
var SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE = "data-framer-size-compatibility-wrapper";
var withMeasuredSize = (Component19) => (props) => {
  var _a, _b, _c, _d;
  const ref = useRef12(null);
  const size2 = useMeasuredSize(ref);
  const dataProps = { [SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE]: true };
  const shouldRender = Boolean(size2);
  const fallbackWidth = (_a = props.width) != null ? _a : DEFAULT_SIZE;
  const fallbackHeight = (_b = props.height) != null ? _b : DEFAULT_SIZE;
  return /* @__PURE__ */ createElement13("div", {
    style: { width: "100%", height: "100%", pointerEvents: "none" },
    ref,
    ...dataProps
  }, shouldRender && /* @__PURE__ */ createElement13(Component19, {
    ...props,
    width: (_c = size2 == null ? void 0 : size2.width) != null ? _c : fallbackWidth,
    height: (_d = size2 == null ? void 0 : size2.height) != null ? _d : fallbackHeight
  }));
};

// src/render/utils/getMeasurableCodeComponentChildren.ts
function getMeasurableCodeComponentChildren(element) {
  const childrenCollection = element.firstElementChild && element.firstElementChild.hasAttribute(SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE) ? element.firstElementChild.children : element.children;
  return [...childrenCollection].filter(isMeasurable).map(unwrapInlinedDisplayContents);
}
function isMeasurable(element) {
  if (element instanceof HTMLBaseElement || element instanceof HTMLHeadElement || element instanceof HTMLLinkElement || element instanceof HTMLMetaElement || element instanceof HTMLScriptElement || element instanceof HTMLStyleElement || element instanceof HTMLTitleElement) {
    return false;
  }
  return element instanceof HTMLElement || element instanceof SVGElement;
}
function unwrapInlinedDisplayContents(element) {
  if (!(element instanceof HTMLElement))
    return element;
  if (element.children.length === 0)
    return element;
  if (element.style.display !== "contents")
    return element;
  const firstMeasurableChild = [...element.children].find(isMeasurable);
  if (firstMeasurableChild) {
    return unwrapInlinedDisplayContents(firstMeasurableChild);
  }
  return element;
}

// src/render/utils/useMeasureLayout.ts
function useMeasureLayout(props, ref, getChildren = () => [], options = {}) {
  const { id, visible, _needsMeasure } = props;
  const { skipHook = false } = options;
  const inCodeComponent = Boolean(useContext19(ComponentContainerContext));
  const onCanvas = RenderTarget.current() === RenderTarget.canvas;
  useLayoutEffect3(() => {
    if (!onCanvas || inCodeComponent || skipHook) {
      return;
    }
    if (!(ref.current && id && visible && _needsMeasure)) {
      return;
    }
    runtime.queueMeasureRequest(nodeIdFromString(id), ref.current, getChildren(ref.current));
  });
}
function measureClosestComponentContainer(element) {
  const container = element.closest("[data-framer-component-container]");
  if (!container)
    return;
  runtime.queueMeasureRequest(nodeIdFromString(container.id), container, getMeasurableCodeComponentChildren(container));
}

// src/render/utils/layoutHintDataPropsForCenter.ts
var isChrome2 = isChrome();
function layoutHintDataPropsForCenter(center) {
  const props = {};
  if (!isChrome2 || RenderTarget.current() !== RenderTarget.canvas) {
    return props;
  }
  if (center === true || center === "x") {
    props["data-framer-layout-hint-center-x"] = true;
  }
  if (center === true || center === "y") {
    props["data-framer-layout-hint-center-y"] = true;
  }
  return props;
}

// src/render/style/BackgroundImageComponent.tsx
import {
  createElement as createElement14,
  useLayoutEffect as useLayoutEffect4,
  useRef as useRef13
} from "react";

// src/render/utils/imageRendering.ts
function minZoomForPixelatedImageRendering(image, containerSize, devicePixelRatio3 = 1) {
  var _a, _b, _c, _d;
  let { width: frameWidth, height: frameHeight } = containerSize;
  const imageWidth = (_b = (_a = image.pixelWidth) != null ? _a : image.intrinsicWidth) != null ? _b : 0;
  const imageHeight = (_d = (_c = image.pixelHeight) != null ? _c : image.intrinsicHeight) != null ? _d : 0;
  if (frameWidth < 1 || frameHeight < 1 || imageWidth < 1 || imageHeight < 1) {
    return void 0;
  }
  frameWidth *= devicePixelRatio3;
  frameHeight *= devicePixelRatio3;
  const frameAspectRatio = frameWidth / frameHeight;
  const imageAspectRatio = imageWidth / imageHeight;
  switch (image.fit) {
    case "fill":
      if (imageAspectRatio > frameAspectRatio) {
        return imageHeight / frameHeight;
      } else {
        return imageWidth / frameWidth;
      }
    case "fit":
    case "stretch":
      return Math.max(imageWidth / frameWidth, imageHeight / frameHeight);
  }
}
function imageRenderingForZoom(zoom, minPixelatedZoom) {
  if (minPixelatedZoom && Math.max(1, zoom) > minPixelatedZoom) {
    return "pixelated";
  }
  return "auto";
}

// src/render/style/BackgroundImageComponent.tsx
var wrapperStyle = {
  position: "absolute",
  pointerEvents: "none",
  userSelect: "none",
  borderRadius: "inherit",
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
function cssObjectFit(imageFit) {
  switch (imageFit) {
    case "fit":
      return "contain";
    case "stretch":
      return "fill";
    default:
      return "cover";
  }
}
function cssImageRendering(image, containerSize) {
  if (!containerSize)
    return "auto";
  const devicePixelRatio3 = RenderTarget.current() === RenderTarget.canvas ? safeWindow.devicePixelRatio : 1;
  const minPixelatedZoom = minZoomForPixelatedImageRendering(image, containerSize, devicePixelRatio3);
  if (RenderTarget.current() === RenderTarget.canvas) {
    return imageRenderingForZoom(1, minPixelatedZoom);
  } else {
    return imageRenderingForZoom(RenderEnvironment.zoom, minPixelatedZoom);
  }
}
function getImageStyle(image, containerSize) {
  return {
    pointerEvents: "none",
    userSelect: "none",
    display: "block",
    width: "100%",
    height: "100%",
    borderRadius: "inherit",
    objectPosition: "center",
    objectFit: cssObjectFit(image.fit),
    imageRendering: cssImageRendering(image, containerSize)
  };
}
function BackgroundImageComponent({ image, containerSize, nodeId, layoutId }) {
  const wrapperRef = useRef13(null);
  const isStaticRendering = !isBrowser2() || RenderTarget.current() === RenderTarget.export;
  if (layoutId) {
    layoutId = layoutId + "-background";
  }
  const source = runtime.useImageSource(image, containerSize, nodeId);
  const imageStyle = getImageStyle(image, containerSize);
  if (!isStaticRendering) {
    const imageElement = runtime.useImageElement(image, containerSize, nodeId);
    useLayoutEffect4(() => {
      const wrapper = wrapperRef.current;
      if (wrapper === null)
        return;
      wrapper.appendChild(imageElement);
      return () => {
        wrapper.removeChild(imageElement);
      };
    }, [imageElement]);
    Object.assign(imageElement.style, imageStyle);
  }
  return /* @__PURE__ */ createElement14(motion.div, {
    ref: wrapperRef,
    style: wrapperStyle,
    layoutId
  }, isStaticRendering ? /* @__PURE__ */ createElement14("img", {
    src: source,
    style: imageStyle
  }) : null);
}

// src/render/presentation/Frame/FrameWithMotion.tsx
function hasEvents(props) {
  for (const key6 in props) {
    if (key6 === "drag" || key6.startsWith("while") || typeof props[key6] === "function" && key6.startsWith("on") && !key6.includes("Animation")) {
      return true;
    }
  }
  return false;
}
var pointerEvents = [
  "onAuxClick",
  "onClick",
  "onDoubleClick",
  "onMouse",
  "onMouseDown",
  "onMouseUp",
  "onTapDown",
  "onTap",
  "onTapUp",
  "onPointer",
  "onPointerDown",
  "onPointerUp",
  "onTouch",
  "onTouchDown",
  "onTouchUp"
];
var pointerEventsSet = new Set([
  ...pointerEvents,
  ...pointerEvents.map((event) => `${event}Capture`)
]);
function getCursorFromEvents(props) {
  if (props.drag) {
    return "grab";
  }
  for (const key6 in props) {
    if (pointerEventsSet.has(key6)) {
      return "pointer";
    }
  }
  return void 0;
}
function unwrapFrameProps(frameProps) {
  const {
    left,
    top,
    bottom,
    right,
    width,
    height,
    minWidth,
    minHeight,
    center,
    _constraints,
    size: size2,
    widthType,
    heightType
  } = frameProps;
  const constraintProps = {
    top: resolveMotionValue(top),
    left: resolveMotionValue(left),
    bottom: resolveMotionValue(bottom),
    right: resolveMotionValue(right),
    width: resolveMotionValue(width),
    height: resolveMotionValue(height),
    minWidth: resolveMotionValue(minWidth),
    minHeight: resolveMotionValue(minHeight),
    size: resolveMotionValue(size2),
    center,
    _constraints,
    widthType,
    heightType
  };
  return constraintProps;
}
var defaultFrameRect = { x: 0, y: 0, width: 200, height: 200 };
function useStyleAndRect(props) {
  injectComponentCSSRules();
  const inCodeComponent = Boolean(useContext20(ComponentContainerContext));
  const { style, _initialStyle, __fromCanvasComponent, size: size2 } = props;
  const unwrappedProps = unwrapFrameProps(props);
  const constraintsRect = useConstraints(unwrappedProps);
  const defaultStyle = {
    display: "block",
    flexShrink: 0,
    userSelect: "none"
  };
  if (!props.__fromCanvasComponent) {
    defaultStyle.backgroundColor = props.background === void 0 ? "rgba(0, 170, 255, 0.3)" : void 0;
  }
  if (!hasEvents(props)) {
    defaultStyle.pointerEvents = "none";
  }
  const addTextCentering = Children3.count(props.children) > 0 && Children3.toArray(props.children).every((child) => {
    return typeof child === "string" || typeof child === "number";
  });
  const centerTextStyle = addTextCentering && {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    textAlign: "center"
  };
  const propsStyle = getStyleForFrameProps(props);
  if (size2 === void 0 && !__fromCanvasComponent) {
    if (!hasLeftAndRight(propsStyle)) {
      defaultStyle.width = defaultFrameRect.width;
    }
    if (!hasTopAndBottom(propsStyle)) {
      defaultStyle.height = defaultFrameRect.height;
    }
  }
  if (unwrappedProps.minWidth !== void 0) {
    defaultStyle.minWidth = unwrappedProps.minWidth;
  }
  if (unwrappedProps.minHeight !== void 0) {
    defaultStyle.minHeight = unwrappedProps.minHeight;
  }
  let constraintsStyle = {};
  if (constraintsEnabled(unwrappedProps)) {
    if (constraintsRect && !isAutoSized(props)) {
      constraintsStyle = {
        left: constraintsRect.x,
        top: constraintsRect.y,
        width: constraintsRect.width,
        height: constraintsRect.height,
        right: void 0,
        bottom: void 0
      };
    }
  }
  Object.assign(defaultStyle, centerTextStyle, _initialStyle, propsStyle, constraintsStyle, style);
  Layer.applyWillChange(props, defaultStyle, true);
  let resultStyle = defaultStyle;
  if (!defaultStyle.transform) {
    resultStyle = { x: 0, y: 0, ...defaultStyle };
  }
  if (props.positionSticky) {
    const onCanvas = RenderTarget.current() === RenderTarget.canvas;
    if (!onCanvas || inCodeComponent) {
      resultStyle.position = "sticky";
      resultStyle.willChange = "transform";
      resultStyle.zIndex = 1;
      resultStyle.top = props.positionStickyTop;
      resultStyle.right = props.positionStickyRight;
      resultStyle.bottom = props.positionStickyBottom;
      resultStyle.left = props.positionStickyLeft;
    }
  }
  return [resultStyle, constraintsRect];
}
var filteredProps = new Set([
  "width",
  "height",
  "opacity",
  "overflow",
  "radius",
  "background",
  "color",
  "x",
  "y",
  "z",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "scale",
  "scaleX",
  "scaleY",
  "skew",
  "skewX",
  "skewY",
  "originX",
  "originY",
  "originZ"
]);
function getMotionProps(props) {
  const motionProps = {};
  for (const key6 in props) {
    const isValid = isValidMotionProp(key6) || (0, import_is_prop_valid.default)(key6);
    if (isValid && !filteredProps.has(key6)) {
      motionProps[key6] = props[key6];
    } else if (key6 === "positionTransition" || key6 === "layoutTransition") {
      motionProps["layout"] = true;
      if (typeof props[key6] !== "boolean" && !props.transition) {
        motionProps["transition"] = props[key6];
      }
    }
  }
  return motionProps;
}
function hasDataFramerName(props) {
  return "data-framer-name" in props;
}
var FrameWithMotion = forwardRef2(function FrameWithMotion2(props, ref) {
  if (safeWindow["perf"])
    safeWindow["perf"].nodeRender();
  const { visible = true } = props;
  if (!visible)
    return null;
  return /* @__PURE__ */ createElement15(VisibleFrame, {
    ...props,
    ref
  });
});
var VisibleFrame = forwardRef2(function VisibleFrame2(props, forwardedRef) {
  const { _border, name, center, border } = props;
  const { props: propsWithOverrides, children } = processOverrideForwarding(props);
  const motionProps = getMotionProps(propsWithOverrides);
  const layoutId = useLayoutId2(props);
  const cursor = getCursorFromEvents(props);
  const fallbackRef = useRef14(null);
  const ref = forwardedRef != null ? forwardedRef : fallbackRef;
  const dataProps = {
    "data-framer-component-type": "Frame",
    "data-framer-cursor": cursor,
    "data-framer-highlight": cursor === "pointer" ? true : void 0,
    "data-layoutid": layoutId
  };
  if (!hasDataFramerName(props) && name) {
    dataProps["data-framer-name"] = name;
  }
  const [currentStyle, rect] = useStyleAndRect(propsWithOverrides);
  const unwrappedProps = unwrapFrameProps(propsWithOverrides);
  const autoSized = isAutoSized(unwrappedProps);
  if (center && !(rect && !autoSized && constraintsEnabled(unwrappedProps))) {
    motionProps.transformTemplate = transformTemplate(center);
    Object.assign(dataProps, layoutHintDataPropsForCenter(center));
  } else {
    motionProps.transformTemplate = transformTemplate(false);
  }
  useMeasureLayout(props, ref);
  const backgroundImage = backgroundImageFromProps(props);
  const inCodeComponent = Boolean(useContext20(ComponentContainerContext));
  const parentSize = resolveParentSize(propsWithOverrides, unwrappedProps, rect, inCodeComponent);
  const wrappedContent = useProvideParentSize(/* @__PURE__ */ createElement15(Fragment5, null, backgroundImage ? /* @__PURE__ */ createElement15(BackgroundImageComponent, {
    image: backgroundImage,
    containerSize: rect != null ? rect : void 0,
    nodeId: props.id && nodeIdFromString(props.id),
    layoutId
  }) : null, children, /* @__PURE__ */ createElement15(Border, {
    ..._border,
    border,
    layoutId
  })), parentSize);
  return /* @__PURE__ */ createElement15(motion.div, {
    ...dataProps,
    ...motionProps,
    layoutId,
    style: currentStyle,
    ref,
    transformValues
  }, wrappedContent);
});
function resolveParentSize(props, unwrappedProps, rect, inCodeComponent) {
  if (inCodeComponent) {
    return rect ? { width: rect.width, height: rect.height } : ParentSizeState.Disabled;
  }
  const { _usesDOMRect } = props;
  const {
    widthType = DimensionType.FixedNumber,
    heightType = DimensionType.FixedNumber,
    width,
    height
  } = unwrappedProps;
  if (rect && !_usesDOMRect) {
    return rect;
  }
  if (widthType === DimensionType.FixedNumber && heightType === DimensionType.FixedNumber && typeof width === "number" && typeof height === "number") {
    return { width, height };
  }
  if (_usesDOMRect) {
    return ParentSizeState.DisabledForCurrentLevel;
  }
  return ParentSizeState.Unknown;
}
function isAutoSized({
  width,
  height
}) {
  return width === "auto" || width === "min-content" || height === "auto" || height === "min-content";
}

// src/components/EmptyState.tsx
import {
  Children as Children5,
  createElement as createElement22
} from "react";

// src/render/presentation/Frame/index.tsx
import {
  createElement as createElement21
} from "react";
import { forwardRef as forwardRef3 } from "react";

// src/components/hoc/WithEvents.tsx
import {
  Component as Component5,
  createElement as createElement17,
  createRef
} from "react";

// src/utils/events.ts
function pointForEvent(event, customTarget = null) {
  let target;
  if (customTarget instanceof HTMLElement) {
    target = customTarget;
  }
  if (!target && event.target instanceof HTMLElement) {
    target = event.target;
  }
  if (!target) {
    return { x: event.pageX, y: event.pageY };
  }
  if (safeWindow.webkitConvertPointFromPageToNode) {
    let webkitPoint = new WebKitPoint(event.pageX, event.pageY);
    webkitPoint = safeWindow.webkitConvertPointFromPageToNode(target, webkitPoint);
    return { x: webkitPoint.x, y: webkitPoint.y };
  }
  const rect = target.getBoundingClientRect();
  const width = parseFloat(target.style.width);
  const height = parseFloat(target.style.height);
  const scale2 = {
    x: width ? width / rect.width : 1,
    y: height ? height / rect.height : 1
  };
  const point = {
    x: scale2.x * (event.pageX - rect.left - target.clientLeft + target.scrollLeft),
    y: scale2.y * (event.pageY - rect.top - target.clientTop + target.scrollTop)
  };
  return point;
}

// src/core/Time.ts
var _raf = (f) => {
  setTimeout(f, 1 / 60);
};
var __raf = safeWindow["requestAnimationFrame"] || _raf;
var raf = (f) => __raf(f);

// src/core/EventEmitter.ts
var import_eventemitter3 = __toModule(require_eventemitter3());
var EventEmitter = class {
  constructor() {
    this._emitter = new import_eventemitter3.EventEmitter();
  }
  eventNames() {
    return this._emitter.eventNames();
  }
  eventListeners() {
    const listeners = {};
    for (const eventName of this._emitter.eventNames()) {
      listeners[eventName] = this._emitter.listeners(eventName);
    }
    return listeners;
  }
  on(eventName, fn) {
    this.addEventListener(eventName, fn, false, false, this);
  }
  off(eventName, fn) {
    this.removeEventListeners(eventName, fn);
  }
  once(eventName, fn) {
    this.addEventListener(eventName, fn, true, false, this);
  }
  unique(eventName, fn) {
    this.addEventListener(eventName, fn, false, true, this);
  }
  addEventListener(eventName, fn, once, unique, context) {
    if (unique) {
      for (const name of this._emitter.eventNames()) {
        if (fn === this._emitter.listeners(name)) {
          return;
        }
      }
    }
    if (once === true) {
      this._emitter.once(eventName, fn, context);
    } else {
      this._emitter.addListener(eventName, fn, context);
    }
  }
  removeEventListeners(eventName, fn) {
    if (eventName) {
      this._emitter.removeListener(eventName, fn);
    } else {
      this.removeAllEventListeners();
    }
  }
  removeAllEventListeners() {
    this._emitter.removeAllListeners();
  }
  countEventListeners(eventName, handler) {
    if (eventName) {
      return this._emitter.listeners(eventName).length;
    } else {
      let count = 0;
      for (const name of this._emitter.eventNames()) {
        count += this._emitter.listeners(name).length;
      }
      return count;
    }
  }
  emit(eventName, ...args) {
    this._emitter.emit(eventName, ...args);
  }
};

// src/core/Loop.ts
var LoopTimeStep = 1 / 60;
var Loop = class extends EventEmitter {
  constructor(start = false) {
    super();
    this._started = false;
    this._frame = 0;
    this._frameTasks = [];
    this.tick = () => {
      if (!this._started)
        return;
      raf(this.tick);
      this.emit("update", this._frame, LoopTimeStep);
      this.emit("render", this._frame, LoopTimeStep);
      this._processFrameTasks();
      this._frame++;
    };
    if (start) {
      this.start();
    }
  }
  addFrameTask(task) {
    this._frameTasks.push(task);
  }
  _processFrameTasks() {
    const postEventTasks = this._frameTasks;
    const length = postEventTasks.length;
    if (length === 0)
      return;
    for (let i = 0; i < length; i++) {
      postEventTasks[i]();
    }
    postEventTasks.length = 0;
  }
  static set TimeStep(value) {
    LoopTimeStep = value;
  }
  static get TimeStep() {
    return LoopTimeStep;
  }
  start() {
    if (this._started)
      return this;
    this._frame = 0;
    this._started = true;
    raf(this.tick);
    return this;
  }
  stop() {
    this._started = false;
    return this;
  }
  get frame() {
    return this._frame;
  }
  get time() {
    return this._frame * LoopTimeStep;
  }
};
var MainLoop = new Loop();

// src/utils/math.ts
var clamp3 = (value, a2, b2) => {
  const min = Math.min(a2, b2);
  const max = Math.max(a2, b2);
  if (value < min) {
    value = min;
  }
  if (value > max) {
    value = max;
  }
  return value;
};

// src/events/FramerEvent.ts
var FramerEvent = class {
  constructor(originalEvent, session) {
    this.originalEvent = originalEvent;
    this.session = session;
    this.time = Date.now();
    this.loopTime = MainLoop.time;
    const customTarget = session && session.startEvent && session.startEvent.target || originalEvent.target;
    const eventLike = FramerEvent.eventLikeFromOriginalEvent(originalEvent);
    this.point = pointForEvent(eventLike, customTarget);
    const deviceTarget = session && session.originElement ? session.originElement : document.body;
    this.devicePoint = pointForEvent(eventLike, deviceTarget);
    this.target = originalEvent.target || null;
    const lastEvent = session && session.lastEvent;
    if (originalEvent instanceof WheelEvent) {
      this.delta = { x: originalEvent.deltaX, y: originalEvent.deltaY };
    } else if (lastEvent && this.devicePoint && lastEvent.devicePoint) {
      this.delta = Point.subtract(this.devicePoint, lastEvent.devicePoint);
    } else {
      this.delta = { x: 0, y: 0 };
    }
  }
  static eventLikeFromOriginalEvent(originalEvent) {
    if ("touches" in originalEvent) {
      let touches = originalEvent.touches;
      if (!touches || !touches.length) {
        if (originalEvent.changedTouches && originalEvent.changedTouches.length) {
          touches = originalEvent.changedTouches;
        }
      }
      if (!touches || !touches.length) {
        return { pageX: 0, pageY: 0, target: null };
      }
      const firstTouch = touches[0];
      const pageX = firstTouch.clientX || firstTouch.screenX || firstTouch.pageX;
      const pageY = firstTouch.clientY || firstTouch.screenY || firstTouch.pageY;
      return {
        pageX,
        pageY,
        target: originalEvent.target
      };
    }
    return originalEvent;
  }
  velocity(t) {
    return this.session ? this.session.velocity(t) : { x: 0, y: 0 };
  }
  get offset() {
    return this.session ? this.session.offset(this) : { x: 0, y: 0 };
  }
  get isLeftMouseClick() {
    if (environment_exports.isTouch()) {
      return void 0;
    }
    if ("button" in this.originalEvent && "buttons" in this.originalEvent && "ctrlKey" in this.originalEvent) {
      return (this.originalEvent.button === 0 || this.originalEvent.buttons === 1) && !this.originalEvent.ctrlKey;
    }
    return false;
  }
};

// src/components/hoc/WithDragging.tsx
import {
  Component as Component4,
  createContext as createContext10,
  createElement as createElement16
} from "react";

// src/animation/Animators/Integrator.ts
var Integrator = class {
  constructor(accelerationFunction) {
    this.accelerationForState = accelerationFunction;
  }
  integrateState(state, dt) {
    const a2 = this.evaluateState(state);
    const b2 = this.evaluateStateWithDerivative(state, dt * 0.5, a2);
    const c2 = this.evaluateStateWithDerivative(state, dt * 0.5, b2);
    const d = this.evaluateStateWithDerivative(state, dt, c2);
    const dxdt = 1 / 6 * (a2.dx + 2 * (b2.dx + c2.dx) + d.dx);
    const dvdt = 1 / 6 * (a2.dv + 2 * (b2.dv + c2.dv) + d.dv);
    state.x = state.x + dxdt * dt;
    state.v = state.v + dvdt * dt;
    return state;
  }
  evaluateState(initialState2) {
    const dv = this.accelerationForState(initialState2);
    return { dx: initialState2.v, dv };
  }
  evaluateStateWithDerivative(initialState2, dt, derivative) {
    const state = {
      x: initialState2.x + derivative.dx * dt,
      v: initialState2.v + derivative.dv * dt
    };
    const output = {
      dx: state.v,
      dv: this.accelerationForState(state)
    };
    return output;
  }
};

// src/animation/Animators/FrictionAnimator.ts
var FrictionAnimator = class {
  constructor(options) {
    this.options = {
      velocity: 0,
      friction: 2,
      tolerance: 1 / 10
    };
    Object.assign(this.options, options);
    this.state = {
      x: 0,
      v: this.options.velocity
    };
    this.integrator = new Integrator((state) => -(this.options.friction * state.v));
  }
  setFrom(value) {
    this.state.x = value;
  }
  setTo(value) {
  }
  setVelocity(velocity) {
    this.state.v = velocity;
  }
  getState() {
    return this.state;
  }
  isReady() {
    return true;
  }
  next(delta2) {
    this.state = this.integrator.integrateState(this.state, delta2);
    return this.state.x;
  }
  isFinished() {
    return Math.abs(this.state.v) < this.options.tolerance;
  }
};

// src/animation/Animators/SpringCurveValueConverter.ts
var epsilon = 1e-3;
var minDuration2 = 0.01;
var maxDuration2 = 10;
var minDamping2 = Number.MIN_VALUE;
var maxDamping2 = 1;
function approximateRoot2(func, derivative, initialGuess, times = 12) {
  let result = initialGuess;
  for (let i = 1, end = times, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {
    result = result - func(result) / derivative(result);
  }
  return result;
}
function angularFrequency(undampedFrequency, dampingRatio) {
  return undampedFrequency * Math.sqrt(1 - Math.pow(dampingRatio, 2));
}
var SpringCurveValueConverter;
(function(SpringCurveValueConverter2) {
  function computeDampingRatio(tension, friction, mass = 1) {
    return friction / (2 * Math.sqrt(mass * tension));
  }
  SpringCurveValueConverter2.computeDampingRatio = computeDampingRatio;
  function computeDuration(tension, friction, velocity = 0, mass = 1) {
    let duration;
    const dampingRatio = computeDampingRatio(tension, friction);
    const undampedFrequency = Math.sqrt(tension / mass);
    if (dampingRatio < 1) {
      const a2 = Math.sqrt(1 - Math.pow(dampingRatio, 2));
      const b2 = velocity / (a2 * undampedFrequency);
      const c2 = dampingRatio / a2;
      const d = -((b2 - c2) / epsilon);
      if (d <= 0) {
        return null;
      }
      duration = Math.log(d) / (dampingRatio * undampedFrequency);
    } else {
      return null;
    }
    return duration;
  }
  SpringCurveValueConverter2.computeDuration = computeDuration;
  function computeDerivedCurveOptions(dampingRatio, duration, velocity = 0, mass = 1) {
    let derivative, envelope;
    dampingRatio = Math.max(Math.min(dampingRatio, maxDamping2), minDamping2);
    duration = Math.max(Math.min(duration, maxDuration2), minDuration2);
    if (dampingRatio < 1) {
      envelope = function(envelopeUndampedFrequency) {
        const exponentialDecay = envelopeUndampedFrequency * dampingRatio;
        const currentDisplacement = exponentialDecay * duration;
        const a2 = exponentialDecay - velocity;
        const b2 = angularFrequency(envelopeUndampedFrequency, dampingRatio);
        const c2 = Math.exp(-currentDisplacement);
        return epsilon - a2 / b2 * c2;
      };
      derivative = function(derivativeUndampedFrequency) {
        const exponentialDecay = derivativeUndampedFrequency * dampingRatio;
        const currentDisplacement = exponentialDecay * duration;
        const d = currentDisplacement * velocity + velocity;
        const e = Math.pow(dampingRatio, 2) * Math.pow(derivativeUndampedFrequency, 2) * duration;
        const f = Math.exp(-currentDisplacement);
        const g = angularFrequency(Math.pow(derivativeUndampedFrequency, 2), dampingRatio);
        const factor = -envelope(derivativeUndampedFrequency) + epsilon > 0 ? -1 : 1;
        return factor * ((d - e) * f) / g;
      };
    } else {
      envelope = function(envelopeUndampedFrequency) {
        const a2 = Math.exp(-envelopeUndampedFrequency * duration);
        const b2 = (envelopeUndampedFrequency - velocity) * duration + 1;
        return -epsilon + a2 * b2;
      };
      derivative = function(derivativeUndampedFrequency) {
        const a2 = Math.exp(-derivativeUndampedFrequency * duration);
        const b2 = (velocity - derivativeUndampedFrequency) * Math.pow(duration, 2);
        return a2 * b2;
      };
    }
    const result = {
      tension: 100,
      friction: 10,
      velocity
    };
    const initialGuess = 5 / duration;
    const undampedFrequency = approximateRoot2(envelope, derivative, initialGuess);
    if (!isNaN(undampedFrequency)) {
      result.tension = Math.pow(undampedFrequency, 2) * mass;
      result.friction = dampingRatio * 2 * Math.sqrt(mass * result.tension);
    }
    return result;
  }
  SpringCurveValueConverter2.computeDerivedCurveOptions = computeDerivedCurveOptions;
})(SpringCurveValueConverter || (SpringCurveValueConverter = {}));

// src/animation/Animators/SpringAnimator.ts
var SpringTensionFrictionDefaults = {
  tension: 500,
  friction: 10,
  tolerance: 1 / 1e4,
  velocity: 0
};
var SpringDampingDurationDefaults = {
  dampingRatio: 1,
  duration: 1,
  velocity: 0,
  mass: 1
};
function isDampingDurationSpringOptions(options) {
  if (!options) {
    return false;
  }
  return typeof options.dampingRatio === "number" || typeof options.duration === "number" || typeof options.mass === "number";
}
var SpringAnimator = class {
  constructor(options, interpolation) {
    this.interpolation = interpolation;
    let _opt;
    if (isDampingDurationSpringOptions(options)) {
      const toPass = { ...SpringDampingDurationDefaults, ...options };
      _opt = SpringCurveValueConverter.computeDerivedCurveOptions(toPass.dampingRatio, toPass.duration, toPass.velocity, toPass.mass);
    } else {
      _opt = options;
    }
    this.options = { ...SpringTensionFrictionDefaults, ..._opt };
    this.state = {
      x: 0,
      v: this.options.velocity
    };
    this.integrator = new Integrator((state) => -this.options.tension * state.x - this.options.friction * state.v);
  }
  isReady() {
    return this.interpolator !== void 0 && this.difference !== void 0;
  }
  next(delta2) {
    this.state = this.integrator.integrateState(this.state, delta2);
    const value = this.interpolator(this.progress());
    return value;
  }
  isFinished() {
    const positionNearZero = Math.abs(this.state.x) < this.options.tolerance;
    const velocityNearZero = Math.abs(this.state.v) < this.options.tolerance;
    return positionNearZero && velocityNearZero;
  }
  setFrom(value) {
    this.current = value;
    this.updateInterpolator();
  }
  setVelocity(velocity) {
    this.state.v = velocity;
  }
  progress() {
    return 1 - this.state.x / this.difference;
  }
  setTo(value) {
    this.destination = value;
    this.difference = this.interpolation.difference(this.destination, this.current);
    this.state.x = this.difference;
    this.updateInterpolator();
  }
  getState() {
    return this.state;
  }
  updateInterpolator() {
    if (this.current === void 0 || this.destination === void 0) {
      return;
    }
    this.interpolator = this.interpolation.interpolate(this.current, this.destination);
  }
};

// src/interpolation/Interpolation.ts
function isInterpolatable(value) {
  return typeof value === "function" && value.interpolationFor && typeof value.interpolationFor === "function";
}
var Interpolation;
(function(Interpolation3) {
  function handleUndefined(from, to) {
    if (from === void 0) {
      from = to;
    }
    if (to === void 0) {
      to = from;
    }
    return [from, to];
  }
  Interpolation3.handleUndefined = handleUndefined;
})(Interpolation || (Interpolation = {}));

// src/interpolation/NumberInterpolation.ts
var NumberInterpolation = {
  interpolate(from, to) {
    ;
    [from, to] = Interpolation.handleUndefined(from, to);
    const a1 = +from;
    const b1 = to - a1;
    return (progress2) => {
      const value = a1 + b1 * progress2;
      return value;
    };
  },
  difference(from, to) {
    return to - from;
  }
};

// src/interpolation/ObjectInterpolation.ts
var ObjectInterpolation = (valueInterpolation) => {
  return {
    interpolate(from, to) {
      ;
      [from, to] = Interpolation.handleUndefined(from, to);
      const result = Object.assign({}, from);
      const interpolations = {};
      const keys2 = new Set();
      for (const key6 in from) {
        interpolations[key6] = valueInterpolation.interpolate(from[key6], to[key6]);
        keys2.add(key6);
      }
      for (const key6 in to) {
        if (!keys2.has(key6)) {
          interpolations[key6] = valueInterpolation.interpolate(from[key6], to[key6]);
          keys2.add(key6);
        }
      }
      return (progress2) => {
        for (const key6 in interpolations) {
          result[key6] = interpolations[key6](progress2);
        }
        return result;
      };
    },
    difference(from, to) {
      let sum = 0;
      for (const key6 in from) {
        const difference = valueInterpolation.difference(from[key6], to[key6]);
        sum += Math.pow(difference, 2);
      }
      return Math.sqrt(sum);
    }
  };
};

// src/interpolation/NoInterpolation.ts
var NoInterpolation = {
  interpolate(from, to) {
    ;
    [from, to] = Interpolation.handleUndefined(from, to);
    return (progress2) => {
      return progress2 < 0.5 ? from : to;
    };
  },
  difference(from, to) {
    return from === to ? 0 : 1;
  }
};

// src/interpolation/ColorInterpolation.ts
var ColorInterpolation = (type = ColorMixModelType.HUSL) => {
  return {
    interpolate(from, to) {
      ;
      [from, to] = Interpolation.handleUndefined(from, to);
      return Color.interpolate(Color(from), Color(to), type);
    },
    difference(from, to) {
      return Color.difference(Color(from), Color(to));
    }
  };
};

// src/interpolation/ValueInterpolation.ts
var DefaultInterpolationOptions = {
  colorModel: ColorMixModelType.HUSL
};
var ValueInterpolation = class {
  constructor(options = DefaultInterpolationOptions) {
    this.interpolate = (from, to) => {
      ;
      [from, to] = Interpolation.handleUndefined(from, to);
      return this.interPolationForValue(from).interpolate(from, to);
    };
    this.difference = (from, to) => {
      const interpolation = this.interPolationForValue(from);
      return interpolation.difference(from, to);
    };
    this.options = { ...DefaultInterpolationOptions, ...options };
  }
  interPolationForValue(value) {
    const type = typeof value;
    if (type === "number") {
      return NumberInterpolation;
    } else if (type === "boolean" || type === "function") {
      return NoInterpolation;
    } else if (Color.isColor(value)) {
      return ColorInterpolation(this.options.colorModel);
    } else if (type === "object") {
      if (value === null) {
        return NoInterpolation;
      }
      const constructor = value.constructor;
      if (constructor && isInterpolatable(constructor)) {
        const interpolation = constructor.interpolationFor(value, this);
        if (interpolation && interpolation !== this && interpolation.constructor !== ValueInterpolation) {
          return interpolation;
        }
      }
      return ObjectInterpolation(this);
    }
    console.warn(`No interpolation defined for ${value}`);
    return NoInterpolation;
  }
};
var AnyInterpolation = new ValueInterpolation();

// src/animation/Animators/InertialScrollAnimator.ts
var Defaults = {
  velocity: 0,
  min: 0,
  max: 0,
  momentum: {
    friction: 2,
    tolerance: 10
  },
  bounce: {
    tension: 500,
    friction: 10,
    tolerance: 1
  }
};
var InertialScrollAnimator = class {
  constructor(options) {
    this.options = Object.assign({ ...Defaults }, options);
    this.frictionAnimator = new FrictionAnimator({
      friction: this.options.momentum.friction,
      tolerance: this.options.momentum.tolerance,
      velocity: this.options.velocity
    });
    this.springAnimator = new SpringAnimator({
      tension: this.options.bounce.tension,
      friction: this.options.bounce.friction,
      tolerance: this.options.bounce.tolerance,
      velocity: this.options.velocity
    }, NumberInterpolation);
    this.useSpring = false;
  }
  isReady() {
    return true;
  }
  next(delta2) {
    this.current = this.currentAnimator.next(delta2);
    if (!this.useSpring) {
      this.tryTransitionToSpring();
    }
    return this.current;
  }
  get currentAnimator() {
    if (this.useSpring) {
      return this.springAnimator;
    }
    return this.frictionAnimator;
  }
  isFinished() {
    return this.currentAnimator.isFinished();
  }
  get state() {
    return this.currentAnimator.getState();
  }
  setFrom(value) {
    this.setState({ x: value, v: this.state.v });
  }
  setState(state) {
    this.frictionAnimator.setFrom(state.x);
    this.frictionAnimator.setVelocity(state.v);
    if (this.isValidState()) {
      return this.tryTransitionToSpring();
    } else {
      let bound = 0;
      if (this.state.x <= this.options.min) {
        bound = this.options.min;
      }
      if (this.state.x >= this.options.max) {
        bound = this.options.max;
      }
      return this.transitionToSpring(bound);
    }
  }
  setTo(destination) {
    this.frictionAnimator.setTo(destination);
    this.springAnimator.setTo(destination);
  }
  setLimits(min, max) {
    this.options.min = min;
    this.options.max = max;
  }
  tryTransitionToSpring() {
    const belowMinWithVelocity = this.state.x < this.options.min && this.state.v <= 0;
    const aboveMaxWithVelocity = this.state.x > this.options.max && this.state.v >= 0;
    if (belowMinWithVelocity || aboveMaxWithVelocity) {
      let bound;
      if (belowMinWithVelocity) {
        bound = this.options.min;
      } else {
        bound = this.options.max;
      }
      this.transitionToSpring(bound);
    } else {
      this.useSpring = false;
    }
  }
  transitionToSpring(bound) {
    this.springAnimator.setFrom(this.state.x);
    this.springAnimator.setVelocity(this.state.v);
    this.springAnimator.setTo(bound);
    this.useSpring = true;
  }
  isValidState() {
    const belowMinTravelingBack = this.state.x < this.options.min && this.state.v > 0;
    const aboveMaxTravelingBack = this.state.x > this.options.max && this.state.v < 0;
    if (belowMinTravelingBack || aboveMaxTravelingBack) {
      let bound;
      if (belowMinTravelingBack) {
        bound = this.options.min;
      } else {
        bound = this.options.max;
      }
      const friction = this.frictionAnimator.options.friction;
      const solution = 1 - friction * (bound - this.state.x) / this.state.v;
      return solution > 0;
    }
    return true;
  }
};

// src/animation/Drivers/AnimationDriver.ts
var AnimationDriver = class {
  constructor(animator, updateCallback, finishedCallback) {
    this.animator = animator;
    this.updateCallback = updateCallback;
    this.finishedCallback = finishedCallback;
    this.update = (frame2, elapsed) => {
      if (this.animator.isFinished()) {
        this.finish();
      } else {
        const value = this.animator.next(elapsed);
        this.updateCallback(value);
      }
    };
    if (!this.animator.isReady()) {
      console.warn("AnimationDriver initialized with animator that isn't ready");
    }
  }
  finish() {
    if (this.finishedCallback) {
      this.finishedCallback(this.animator.isFinished());
    }
  }
  isFinished() {
    return this.animator.isFinished();
  }
};

// src/animation/Drivers/MainLoopDriver.ts
var MainLoopAnimationDriver = class extends AnimationDriver {
  play() {
    if (RenderEnvironment.target !== RenderTarget.preview) {
      this.finishedCallback && this.finishedCallback(false);
      return;
    }
    MainLoop.on("update", this.update);
  }
  cancel() {
    MainLoop.off("update", this.update);
  }
  finish() {
    MainLoop.off("update", this.update);
    super.finish();
  }
};

// src/components/hoc/WithDragging.tsx
var DraggingContext = createContext10({ dragging: false });
var hoistNonReactStatic = require_hoist_non_react_statics_cjs();
function WithDragging(Component19) {
  const _WithDraggingHOC = class extends Component4 {
    constructor(props, defaultProps) {
      super(props, defaultProps);
      this.state = {
        isDragging: false
      };
      this.x = Animatable(0);
      this.y = Animatable(0);
      this.onChangePosition = (change, transaction) => {
        if (change.value === change.oldValue) {
          return;
        }
        if (this.props.onMove) {
          this.props.onMove(this.point, this);
        }
      };
      this.isMoving = false;
      this.isAnimating = false;
      this.directionLockAxis = null;
      this._constraints = null;
      this.panStart = (event) => {
        if (!this.props.enabled) {
          return;
        }
        this.isMoving = this.isAnimating;
        this.stopAnimation();
        this.resetdirectionLock();
        this.layerStartPoint = this.point;
        this.correctedLayerStartPoint = this.point;
        if (this._constraints && this.props.bounce) {
          this.correctedLayerStartPoint = this.constrainPosition(this.correctedLayerStartPoint, this._constraints, 1 / this.props.overdragScale);
        }
        this.previousPoint = this.correctedLayerStartPoint;
        if (!this.state.isDragging) {
          this.setState({ isDragging: true });
        }
        if (this.props.onDragSessionStart) {
          this.props.onDragSessionStart(event, this);
        }
      };
      this.pan = (event) => {
        const {
          enabled,
          speedX,
          speedY,
          directionLock,
          overdragScale,
          vertical,
          horizontal,
          pixelAlign,
          onDragStart,
          onDragWillMove,
          onDragDidMove,
          onDragSessionMove
        } = this.props;
        if (!enabled) {
          return;
        }
        let point = { ...this.previousPoint };
        point.x += event.delta.x * speedX;
        point.y += event.delta.y * speedY;
        this.previousPoint = { ...point };
        if (this._constraints) {
          point = this.constrainPosition(point, this._constraints, overdragScale);
        }
        if (directionLock) {
          if (this.directionLockAxis === null) {
            const offset = event.offset;
            offset.x = offset.x * speedX;
            offset.y = offset.y * speedY;
            this.updatedirectionLock(offset);
            return;
          } else {
            if (this.directionLockAxis === "y") {
              point.x = this.layerStartPoint.x;
            }
            if (this.directionLockAxis === "x") {
              point.y = this.layerStartPoint.y;
            }
          }
        }
        if (!this.state.isDragging) {
          this.setState({ isDragging: true });
          this.isMoving = true;
          if (onDragStart) {
            onDragStart(event, this);
          }
        }
        if (onDragWillMove) {
          onDragWillMove(event, this);
        }
        if (pixelAlign) {
          point.x = Math.round(point.x);
          point.y = Math.round(point.y);
        }
        if (!horizontal && !vertical) {
          return;
        }
        let axis = null;
        if (horizontal && !vertical) {
          axis = "x";
        } else if (vertical && !horizontal) {
          axis = "y";
        }
        this.setPoint(point, axis);
        if (onDragDidMove) {
          onDragDidMove(event, this);
        }
        if (onDragSessionMove) {
          onDragSessionMove(event, this);
        }
      };
      this.panEnd = (event) => {
        if (!this.props.enabled) {
          return;
        }
        this.startAnimation(event);
        const { onDragSessionEnd, onDragEnd } = this.props;
        if (this.state.isDragging) {
          if (onDragEnd) {
            onDragEnd(event, this);
          }
        }
        if (onDragSessionEnd) {
          onDragSessionEnd(event, this);
        }
        if (this.state.isDragging) {
          this.setState({ isDragging: false });
        }
        this.isMoving = this.isAnimating;
      };
      this.mouseWheelStart = (event) => {
        this.correctedLayerStartPoint = this.point;
        this.previousPoint = this.correctedLayerStartPoint;
        this.stopAnimation();
      };
      this.mouseWheel = (event) => {
        const {
          enabled,
          speedX,
          speedY,
          vertical,
          horizontal,
          pixelAlign,
          onDragWillMove,
          onDragDidMove,
          mouseWheel
        } = this.props;
        if (!mouseWheel || !enabled) {
          return;
        }
        let point = { ...this.point };
        point.x -= event.delta.x * speedX;
        point.y -= event.delta.y * speedY;
        if (this._constraints) {
          point = this.constrainPosition(point, this._constraints, 0, false);
        }
        if (onDragWillMove) {
          onDragWillMove(event, this);
        }
        if (pixelAlign) {
          point.x = Math.round(point.x);
          point.y = Math.round(point.y);
        }
        if (!horizontal && !vertical) {
          return;
        }
        let axis = null;
        if (horizontal && !vertical) {
          axis = "x";
        } else if (vertical && !horizontal) {
          axis = "y";
        }
        this.setPoint(point, axis);
        if (onDragDidMove) {
          onDragDidMove(event, this);
        }
      };
      this.mouseWheelEnd = (event) => {
      };
      this.onAnimationStep = (axis, value) => {
        if (axis === "x" && this.props.horizontal === false) {
          return;
        }
        if (axis === "y" && this.props.vertical === false) {
          return;
        }
        let delta2 = 0;
        if (this.constraints) {
          if (this.props.bounce) {
            delta2 = value - this.getValue(axis);
          } else {
            const { minX, minY, maxX, maxY } = this.calculateConstraints(this._constraints);
            if (axis === "x") {
              delta2 = clamp3(value, minX, maxX) - this.getValue(axis);
            }
            if (axis === "y") {
              delta2 = clamp3(value, minY, maxY) - this.getValue(axis);
            }
          }
        } else {
          delta2 = value - this.getValue(axis);
        }
        const updatePoint = this.point;
        if (axis === "x") {
          updatePoint[axis] = updatePoint[axis] + delta2;
        }
        if (axis === "y") {
          updatePoint[axis] = updatePoint[axis] + delta2;
        }
        this.setPoint(updatePoint, axis);
      };
      this.onAnimationStop = (axis) => {
        if (axis === "x" && this.props.horizontal === false) {
          return;
        }
        if (axis === "y" && this.props.vertical === false) {
          return;
        }
        if (!this.animation) {
          return;
        }
        if (this.props.pixelAlign) {
          const point = this.point;
          point.x = Math.round(point.x);
          point.y = Math.round(point.y);
          this.setPoint(point, axis);
        }
        if (this.animation.x.isFinished() && this.animation.y.isFinished()) {
          return this.stopAnimation();
        }
      };
      this.stopAnimation = () => {
        this.isAnimating = false;
        this.isMoving = false;
        if (!this.animation) {
          return;
        }
        this.animation.x.cancel();
        this.animation.y.cancel();
        if (this.props.onDragAnimationEnd) {
          this.props.onDragAnimationEnd(this.animation, this);
        }
        this.animation = null;
      };
      const x = this.props.left;
      const y = this.props.top;
      if (!x) {
        this.x = Animatable(0);
      } else if (isAnimatable2(x)) {
        this.x = x;
      } else {
        this.x = Animatable(x);
      }
      if (!y) {
        this.y = Animatable(0);
      } else if (isAnimatable2(y)) {
        this.y = y;
      } else {
        this.y = Animatable(y);
      }
      this.x.onUpdate(this.onChangePosition);
      this.y.onUpdate(this.onChangePosition);
      const constraints = this.props.constraints;
      if (constraints) {
        this.constraints = constraints;
      }
    }
    UNSAFE_componentWillReceiveProps(props) {
      if (this.props.left !== props.left && isFiniteNumber(props.left)) {
        this.x.set(props.left);
      }
      if (this.props.top !== props.top && isFiniteNumber(props.top)) {
        this.y.set(props.top);
      }
      const constraints = props.constraints;
      if (constraints) {
        this.constraints = constraints;
      }
    }
    get point() {
      return { x: this.x.get(), y: this.y.get() };
    }
    setPoint(point, axis = null) {
      switch (axis) {
        case "x":
          this.x.set(point.x);
          break;
        case "y":
          this.y.set(point.y);
          break;
        case null:
          this.x.set(point.x);
          this.y.set(point.y);
          break;
      }
    }
    getValue(axis) {
      switch (axis) {
        case "x":
          return this.x.get();
        case "y":
          return this.y.get();
      }
    }
    get width() {
      const width = this.props.width;
      if (!width) {
        return 100;
      }
      if (isAnimatable2(width)) {
        return width.get();
      }
      if (typeof width === "string") {
        return parseFloat(width);
      }
      return width;
    }
    get height() {
      const height = this.props.height;
      if (!height) {
        return 100;
      }
      if (isAnimatable2(height)) {
        return height.get();
      }
      if (typeof height === "string") {
        return parseFloat(height);
      }
      return height;
    }
    get constraints() {
      return this._constraints;
    }
    set constraints(value) {
      if (value !== null && typeof value === "object") {
        this._constraints = {
          x: value.x || 0,
          y: value.y || 0,
          width: value.width || 0,
          height: value.height || 0
        };
      } else {
        this._constraints = null;
      }
      if (this._constraints) {
        this.updateAnimationConstraints(this._constraints);
      }
    }
    get constraintsOffset() {
      if (!this.constraints) {
        return { x: 0, y: 0 };
      }
      const { minX, minY, maxX, maxY } = this.calculateConstraints(this._constraints);
      const point = this.point;
      const constrainedPoint = { x: clamp3(point.x, minX, maxX), y: clamp3(point.y, minY, maxY) };
      const offset = { x: point.x - constrainedPoint.x, y: point.y - constrainedPoint.y };
      return offset;
    }
    get isBeyondConstraints() {
      const constraintsOffset = this.constraintsOffset;
      if (constraintsOffset.x !== 0) {
        return true;
      }
      if (constraintsOffset.y !== 0) {
        return true;
      }
      return false;
    }
    clampAndScale(value, min, max, scale2, scaleAllowed) {
      if (!scaleAllowed) {
        return clamp3(value, min, max);
      }
      if (value < min) {
        value = min + (value - min) * scale2;
      }
      if (value > max) {
        value = max + (value - max) * scale2;
      }
      return value;
    }
    calculateConstraints(bounds) {
      if (!bounds) {
        return { minX: Infinity, maxX: Infinity, minY: Infinity, maxY: Infinity };
      }
      if (bounds.width < this.width) {
        bounds.width = this.width;
      }
      if (bounds.height < this.height) {
        bounds.height = this.height;
      }
      const constraints = {
        minX: Rect.minX(bounds),
        maxX: Rect.maxX(bounds),
        minY: Rect.minY(bounds),
        maxY: Rect.maxY(bounds)
      };
      constraints.maxX -= this.width;
      constraints.maxY -= this.height;
      return constraints;
    }
    constrainPosition(proposedPoint, bounds, scale2, overdrag = this.props.overdrag) {
      const { maxX, maxY, minX, minY } = this.calculateConstraints(this._constraints);
      const point = {
        x: this.clampAndScale(proposedPoint.x, minX, maxX, scale2, overdrag),
        y: this.clampAndScale(proposedPoint.y, minY, maxY, scale2, overdrag)
      };
      if (this.props.speedX === 0 || this.props.horizontal === false) {
        point.x = proposedPoint.x;
      }
      if (this.props.speedY === 0 || this.props.vertical === false) {
        point.y = proposedPoint.y;
      }
      return point;
    }
    updatedirectionLock(correctedDelta) {
      if (Math.abs(correctedDelta.y) > this.props.directionLockThreshold.y) {
        this.directionLockAxis = "y";
      } else if (Math.abs(correctedDelta.x) > this.props.directionLockThreshold.x) {
        this.directionLockAxis = "x";
      }
      if (this.directionLockAxis !== null) {
        if (this.props.onDragDirectionLockStart) {
          this.props.onDragDirectionLockStart(this.directionLockAxis, this);
        }
      }
    }
    resetdirectionLock() {
      this.directionLockAxis = null;
    }
    setupAnimation() {
      if (this.animation) {
        return;
      }
      this.animation = { x: this.setupAnimationForAxis("x"), y: this.setupAnimationForAxis("y") };
      this.updateAnimationConstraints(this._constraints);
    }
    setupAnimationForAxis(axis) {
      const properties = {};
      properties[axis] = true;
      const animator = new InertialScrollAnimator({
        momentum: this.props.momentumOptions,
        bounce: this.props.bounceOptions
      });
      const updateCallback = (value) => {
        this.onAnimationStep(axis, value);
      };
      const doneCallback = () => {
        this.onAnimationStop(axis);
      };
      return new MainLoopAnimationDriver(animator, updateCallback, doneCallback);
    }
    updateAnimationConstraints(constraints) {
      if (!this.animation) {
        return;
      }
      if (constraints) {
        const { minX, minY, maxX, maxY } = this.calculateConstraints(constraints);
        this.animation.x.animator.setLimits(minX, maxX);
        this.animation.y.animator.setLimits(minY, maxY);
      } else {
        this.animation.x.animator.setLimits(-Infinity, Infinity);
        this.animation.y.animator.setLimits(-Infinity, Infinity);
      }
    }
    startAnimation(event) {
      const {
        momentum,
        bounce,
        momentumVelocityMultiplier,
        speedX,
        speedY,
        overdrag,
        onDragAnimationStart
      } = this.props;
      if (!(momentum || bounce)) {
        return;
      }
      if (this.isBeyondConstraints === false && momentum === false) {
        return;
      }
      if (this.isBeyondConstraints === false && this.state.isDragging === false) {
        return;
      }
      const { minX, minY, maxX, maxY } = this.calculateConstraints(this._constraints);
      const startAnimationX = overdrag === true || this.point.x > minX && this.point.x < maxX;
      const startAnimationY = overdrag === true || this.point.y > minY && this.point.y < maxY;
      if (startAnimationX === startAnimationY && startAnimationY === false) {
        return;
      }
      const velocity = event.velocity(0.1);
      let velocityX = velocity.x * momentumVelocityMultiplier * speedX;
      let velocityY = velocity.y * momentumVelocityMultiplier * speedY;
      if (this.directionLockAxis === "x") {
        velocityY = 0;
      }
      if (this.directionLockAxis === "y") {
        velocityX = 0;
      }
      this.setupAnimation();
      this.isAnimating = true;
      this.isMoving = true;
      if (!this.animation) {
        return;
      }
      this.animation.x.animator.setState({ x: this.point.x, v: velocityX });
      if (startAnimationX) {
        this.animation.x.play();
      }
      this.animation.y.animator.setState({ x: this.point.y, v: velocityY });
      if (startAnimationY) {
        this.animation.y.play();
      }
      if (onDragAnimationStart) {
        onDragAnimationStart(this.animation, this);
      }
    }
    wrapHandler(ownHandler, originalHandler) {
      if (!originalHandler) {
        return ownHandler;
      }
      return (event) => {
        ownHandler(event);
        originalHandler(event);
      };
    }
    render() {
      const {
        onPanStart,
        onPan,
        onPanEnd,
        onMouseWheelStart,
        onMouseWheel,
        onMouseWheelEnd,
        ...attributes
      } = this.props;
      const originalProps = { ...attributes };
      Object.keys(_WithDraggingHOC.draggingDefaultProps).forEach((key6) => {
        delete originalProps[key6];
      });
      originalProps.onPanStart = this.wrapHandler(this.panStart, onPanStart);
      originalProps.onPan = this.wrapHandler(this.pan, onPan);
      originalProps.onPanEnd = this.wrapHandler(this.panEnd, onPanEnd);
      originalProps.onMouseWheelStart = this.wrapHandler(this.mouseWheelStart, onMouseWheelStart);
      originalProps.onMouseWheel = this.wrapHandler(this.mouseWheel, onMouseWheel);
      originalProps.onMouseWheelEnd = this.wrapHandler(this.mouseWheelEnd, onMouseWheelEnd);
      originalProps.left = this.x;
      originalProps.top = this.y;
      return /* @__PURE__ */ createElement16(DraggingContext.Provider, {
        value: { dragging: this.state.isDragging }
      }, /* @__PURE__ */ createElement16(Component19, {
        ...originalProps
      }));
    }
  };
  let WithDraggingHOC = _WithDraggingHOC;
  WithDraggingHOC.draggingDefaultProps = {
    momentum: true,
    momentumOptions: { friction: 2.1, tolerance: 1 },
    momentumVelocityMultiplier: 800,
    speedX: 1,
    speedY: 1,
    bounce: true,
    bounceOptions: { friction: 40, tension: 200, tolerance: 1 },
    directionLock: false,
    directionLockThreshold: { x: 10, y: 10 },
    overdrag: true,
    overdragScale: 0.5,
    pixelAlign: true,
    velocityTimeout: 100,
    velocityScale: 890,
    horizontal: true,
    vertical: true,
    enabled: true,
    constraints: {},
    mouseWheel: false
  };
  WithDraggingHOC.defaultProps = Object.assign({}, Component19.defaultProps, _WithDraggingHOC.draggingDefaultProps);
  const withDragging = WithDraggingHOC;
  hoistNonReactStatic(withDragging, Component19);
  return withDragging;
}

// src/components/hoc/WithEvents.tsx
var hoistNonReactStatic2 = require_hoist_non_react_statics_cjs();
var hoverProps = {
  onMouseEnter: "mouseenter",
  onMouseLeave: "mouseleave"
};
var hoverEventKeys = Object.keys(hoverProps);
var eventHandlerMapping = {
  panstart: ["onPanStart"],
  pan: ["onPan"],
  panend: ["onPanEnd"],
  tapstart: ["onTapStart", "onMouseDown"],
  tap: ["onTap", "onClick"],
  tapend: ["onTapEnd", "onMouseUp"],
  mousewheelstart: ["onMouseWheelStart"],
  mousewheel: ["onMouseWheel"],
  mousewheelend: ["onMouseWheelEnd"]
};
var tapEventKeys = new Set(["tapstart", "tap", "tapend"]);
function WithEvents(BaseComponent) {
  var _a;
  const withEvents = (_a = class extends Component5 {
    constructor() {
      super(...arguments);
      this.shouldCancelTap = false;
      this.activeEventListeners = new Map();
      this.hasFramerEventListener = false;
      this.component = createRef();
    }
    get element() {
      return this.component.current && this.component.current.element;
    }
    componentDidMount() {
      this.addEventListeners();
    }
    componentDidUpdate(prevProps) {
      this.addEventListeners(prevProps);
    }
    componentWillUnmount() {
      this.removeEventListeners();
    }
    addEventListeners(prevProps) {
      if (this.element && !this.hasFramerEventListener) {
        this.element.addEventListener("FramerEvent", ({ detail }) => {
          const type = detail.type;
          const framerEvent = detail.event;
          this.handleEvent(type, framerEvent);
        });
        hoverEventKeys.forEach((eventName) => this.addHoverEvent(eventName));
        this.hasFramerEventListener = true;
      } else if (this.element && prevProps) {
        hoverEventKeys.forEach((eventName) => this.checkHoverEvent(eventName, prevProps));
      } else if (!this.element) {
        this.hasFramerEventListener = false;
      }
    }
    removeEventListeners() {
      hoverEventKeys.forEach((eventName) => this.removeHoverEvent(eventName));
    }
    addHoverEvent(eventName) {
      const originalEventListener = this.props[eventName];
      if (this.element && originalEventListener) {
        const eventListener = (e) => {
          const framerEvent = new FramerEvent(e);
          originalEventListener(framerEvent);
        };
        this.activeEventListeners.set(eventName, eventListener);
        const domEventName = hoverProps[eventName];
        this.element.addEventListener(domEventName, eventListener);
      }
    }
    removeHoverEvent(eventName) {
      const eventListener = this.activeEventListeners.get(eventName);
      if (this.element && eventListener) {
        const domEventName = hoverProps[eventName];
        this.element.removeEventListener(domEventName, eventListener);
        this.activeEventListeners.delete(eventName);
      }
    }
    checkHoverEvent(eventName, prevProps) {
      if (prevProps[eventName] !== this.props[eventName]) {
        this.removeHoverEvent(eventName);
        this.addHoverEvent(eventName);
      }
    }
    handleEvent(type, framerEvent) {
      const eventListenerKeys = eventHandlerMapping[type];
      if (!eventListenerKeys)
        return;
      eventListenerKeys.forEach((eventKey) => {
        const eventListener = this.props[eventKey];
        const cancelEvent = this.shouldCancelTap && tapEventKeys.has(eventKey);
        if (eventListener && !cancelEvent) {
          eventListener(framerEvent);
        }
      });
    }
    render() {
      return /* @__PURE__ */ createElement17(DraggingContext.Consumer, null, (value) => {
        this.shouldCancelTap = value.dragging;
        return /* @__PURE__ */ createElement17(BaseComponent, {
          ...this.props,
          ref: this.component
        });
      });
    }
  }, _a.defaultProps = Object.assign({}, BaseComponent.defaultProps), _a);
  hoistNonReactStatic2(withEvents, BaseComponent);
  return withEvents;
}

// src/render/presentation/Frame/DeprecatedFrame.tsx
import {
  Children as Children4,
  cloneElement as cloneElement3,
  createElement as createElement20
} from "react";

// src/data/ObservableObject.ts
var hasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
function ObservableObject(initial = {}, makeAnimatables = false, observeAnimatables = true) {
  const unproxiedState = {};
  unproxiedState[$private] = {
    makeAnimatables,
    observeAnimatables,
    observers: new Observers(),
    reset() {
      for (const key6 in state) {
        if (hasOwnProperty(state, key6)) {
          state[key6] = hasOwnProperty(initial, key6) ? initial[key6] : void 0;
        }
      }
    },
    transactions: new Set()
  };
  const state = new Proxy(unproxiedState, sharedProxyHandler);
  Object.assign(state, initial);
  return state;
}
(function(ObservableObject2) {
  function resetObject(target) {
    return target[$private].reset();
  }
  ObservableObject2.resetObject = resetObject;
  function addObserver(target, observer) {
    return target[$private].observers.add(observer);
  }
  ObservableObject2.addObserver = addObserver;
})(ObservableObject || (ObservableObject = {}));
var ObservableObjectProxyHandler = class {
  constructor() {
    this.set = (target, key6, value, receiver) => {
      if (key6 === $private) {
        return false;
      }
      const privateObject = target[$private];
      let animatable;
      let rawValue;
      if (isAnimatable2(value)) {
        animatable = value;
        rawValue = animatable.get();
      } else {
        rawValue = value;
      }
      if (privateObject.makeAnimatables && typeof value !== "function" && typeof value !== "object" && !animatable) {
        animatable = Animatable(value);
      }
      if (privateObject.observeAnimatables && animatable) {
        const transactions = privateObject.transactions;
        animatable.onUpdate({
          update: (change, transaction) => {
            if (transaction) {
              transactions.add(transaction);
            }
            privateObject.observers.notify({ value: receiver }, transaction);
          },
          finish: (transaction) => {
            if (transactions.delete(transaction)) {
              privateObject.observers.finishTransaction(transaction);
            }
          }
        });
      }
      let result = false;
      let changed = true;
      if (target[key6] !== void 0) {
        if (isAnimatable2(target[key6])) {
          changed = target[key6].get() !== rawValue;
          target[key6].set(rawValue);
        } else {
          changed = target[key6] !== rawValue;
          target[key6] = rawValue;
        }
        const rawValueIsObject = rawValue !== null && typeof rawValue === "object";
        if (Array.isArray(rawValue) || rawValueIsObject)
          changed = true;
        result = true;
      } else {
        if (animatable) {
          value = animatable;
        }
        result = Reflect.set(target, key6, value);
      }
      if (changed) {
        privateObject.observers.notify({ value: receiver });
      }
      return result;
    };
    this.get = (target, key6, receiver) => {
      if (key6 === $private) {
        return target[key6];
      }
      const value = Reflect.get(target, key6, receiver);
      return typeof value === "function" ? value.bind(receiver) : value;
    };
  }
  deleteProperty(target, key6) {
    const result = Reflect.deleteProperty(target, key6);
    target[$private].observers.notify({ value: target });
    return result;
  }
  ownKeys(target) {
    const keys2 = Reflect.ownKeys(target);
    const privateIndex = keys2.indexOf($private);
    if (privateIndex !== -1) {
      keys2.splice(privateIndex, 1);
    }
    return keys2;
  }
  getOwnPropertyDescriptor(target, key6) {
    if (key6 === $private) {
      return void 0;
    }
    return Reflect.getOwnPropertyDescriptor(target, key6);
  }
};
var sharedProxyHandler = new ObservableObjectProxyHandler();
var $private = Symbol("private");

// src/render/traits/Radius.ts
var key2 = "radius";
function hasRadius(props) {
  return key2 in props;
}
function getRadiusValue(value) {
  let num = Number(value);
  if (typeof value === "string" && isNaN(num)) {
    return value;
  } else if (isAnimatable2(value)) {
    num = Animatable.getNumber(value);
  }
  return num ? `${num}px` : "0";
}
function hasRadiusValue(value) {
  return value && value !== "0";
}
function collectRadiusFromProps(props, style) {
  if (!hasRadius(props))
    return;
  const { radius } = props;
  if (typeof radius === "string" || isAnimatable2(radius) || isFiniteNumber(radius)) {
    const radiusValue = getRadiusValue(radius);
    if (hasRadiusValue(radiusValue)) {
      style.borderTopLeftRadius = style.borderTopRightRadius = style.borderBottomRightRadius = style.borderBottomLeftRadius = radiusValue;
    }
  } else if (radius) {
    const topLeft = getRadiusValue(radius.topLeft);
    const topRight = getRadiusValue(radius.topRight);
    const bottomRight = getRadiusValue(radius.bottomRight);
    const bottomLeft = getRadiusValue(radius.bottomLeft);
    if (hasRadiusValue(topLeft) || hasRadiusValue(topRight) || hasRadiusValue(bottomRight) || hasRadiusValue(bottomLeft)) {
      style.borderTopLeftRadius = topLeft;
      style.borderTopRightRadius = topRight;
      style.borderBottomRightRadius = bottomRight;
      style.borderBottomLeftRadius = bottomLeft;
    }
  }
}

// src/render/traits/Blending.ts
function collectBlendingFromProps(node, style) {
  if (!node.blendingMode || node.blendingMode === "normal")
    return;
  style.mixBlendMode = node.blendingMode;
}

// src/render/traits/Overflow.ts
function collectOverflowFromProps(props, style) {
  if (props.overflow) {
    style.overflow = props.overflow;
  }
}

// src/render/traits/Opacity.ts
var key3 = "opacity";
function withOpacity(target) {
  return key3 in target;
}
function collectOpacityFromProps(props, style) {
  if (!withOpacity(props))
    return;
  const opacity = Animatable.getNumber(props.opacity);
  if (opacity === 1)
    return;
  style.opacity = opacity;
}

// src/render/style/shadow.tsx
import {
  Fragment as Fragment6,
  createElement as createElement19,
  useContext as useContext21
} from "react";

// src/render/types/Shadow.ts
var shadowKeys = ["color", "x", "y", "blur"];
var Shadow;
(function(Shadow3) {
  function is(shadow) {
    return shadow && shadowKeys.every((key6) => key6 in shadow);
  }
  Shadow3.is = is;
})(Shadow || (Shadow = {}));
var boxShadowKeys = ["inset", "color", "x", "y", "blur", "spread"];
var BoxShadow;
(function(BoxShadow2) {
  function is(shadow) {
    return shadow && boxShadowKeys.every((key6) => key6 in shadow);
  }
  BoxShadow2.is = is;
  function toCSS(shadow) {
    const inset = shadow.inset ? "inset " : "";
    return `${inset}${shadow.x}px ${shadow.y}px ${shadow.blur}px ${shadow.spread}px ${shadow.color}`;
  }
  BoxShadow2.toCSS = toCSS;
})(BoxShadow || (BoxShadow = {}));

// src/render/presentation/CustomProperties.tsx
import {
  PureComponent,
  createContext as createContext11,
  createElement as createElement18
} from "react";
var VariableRegex = /var\(([^),]+)/;
var CustomPropertiesContext = createContext11(() => null);
var CustomProperties = class extends PureComponent {
  constructor() {
    super(...arguments);
    this.lookup = (variable) => {
      const match = VariableRegex.exec(variable);
      const customProperty = match ? match[1].trim() : "";
      return this.props.customProperties[customProperty] || null;
    };
  }
  render() {
    const { children, customProperties } = this.props;
    return /* @__PURE__ */ createElement18(CustomPropertiesContext.Provider, {
      value: this.lookup
    }, /* @__PURE__ */ createElement18("div", {
      style: customProperties
    }, children));
  }
};

// src/render/style/shadow.tsx
function shadowsAsFilter(shadows) {
  const filters = [];
  if (shadows && shadows.length) {
    const dropShadows = shadows.map((shadowItem) => {
      return `drop-shadow(${shadowItem.x}px ${shadowItem.y}px ${shadowItem.blur}px ${shadowItem.color})`;
    });
    filters.push(...dropShadows);
  }
  return filters;
}
function collectTextShadowsForProps(props, style) {
  if (!props.shadows || props.shadows.length === 0)
    return;
  const textShadow = props.shadows.map((shadow) => {
    return `${shadow.x}px ${shadow.y}px ${shadow.blur}px ${shadow.color}`;
  }).join(", ");
  if (!textShadow)
    return;
  style.textShadow = textShadow;
}
function collectBoxShadowsForProps(props, style) {
  if (!props.shadows || props.shadows.length === 0)
    return;
  const boxShadow = props.shadows.map((shadowItem) => BoxShadow.toCSS(shadowItem)).join(", ");
  if (!boxShadow)
    return;
  style.boxShadow = boxShadow;
}
function shadowForShape(boxShadows, rect, shapeId, fillAlpha, strokeAlpha, strokeWidth, strokeClipId, svgStrokeAttributes) {
  const definition = [];
  let outsetElement = null;
  let insetElement = null;
  const needsStrokeClip = false;
  const shadows = [];
  const insetShadows = [];
  const boxShadowsCount = boxShadows.length;
  const svgShadowClass = "svg-shadow";
  const svgShadowProps = RenderTarget.current() === RenderTarget.canvas ? { className: svgShadowClass } : {};
  for (let i = 0, il = boxShadowsCount; i < il; i++) {
    const shadow = boxShadows[i];
    shadow.inset ? insetShadows.push(shadow) : shadows.push(shadow);
  }
  if (shadows.length > 0) {
    shadows.reverse();
    const outsideShadowId = shapeId.add("_shadow_out");
    const normalizedFrame = Rect.atOrigin(rect);
    const shadowRects = [normalizedFrame];
    for (let i = 0, il = shadows.length; i < il; i++) {
      const shadow = shadows[i];
      const shadowFrame = localShadowFrame(shadow, normalizedFrame, true);
      if (shadowFrame === null) {
        continue;
      }
      shadowRects.push(shadowFrame);
    }
    let maxBlur = 0;
    const filterElements = [];
    const mergeElements = [];
    for (let i = 0, il = shadows.length; i < il; i++) {
      const shadow = shadows[i];
      const shadowElements = outerShadowElements(shapeId, shadow, i);
      maxBlur = Math.max(maxBlur, shadow.blur);
      filterElements.push(shadowElements.filterElements);
      mergeElements.push(shadowElements.mergeElement);
    }
    let expandStrokeWidth = strokeWidth;
    if (!isFiniteNumber(expandStrokeWidth))
      expandStrokeWidth = 0;
    let miter = svgStrokeAttributes.strokeMiterlimit;
    if (!isFiniteNumber(miter))
      miter = 4;
    let shadowRect = Rect.merge(...shadowRects);
    shadowRect = Rect.inflate(shadowRect, (expandStrokeWidth * miter / 2 + maxBlur) * 1.1);
    const width = rect.width + (strokeWidth ? strokeWidth / 2 : 0.1);
    const height = rect.height + (strokeWidth ? strokeWidth / 2 : 0.1);
    const filterX = shadowRect.x / width * 100;
    const filterY = shadowRect.y / height * 100;
    const filterWidth = shadowRect.width / width * 100;
    const filterHeight = shadowRect.height / height * 100;
    definition.push(/* @__PURE__ */ createElement19("filter", {
      key: outsideShadowId.id,
      id: outsideShadowId.id,
      x: `${filterX.toFixed(1)}%`,
      y: `${filterY.toFixed(1)}%`,
      width: `${filterWidth.toFixed(1)}%`,
      height: `${filterHeight.toFixed(1)}%`,
      filterUnits: "objectBoundingBox",
      ...svgShadowProps
    }, filterElements, shadows.length > 1 ? /* @__PURE__ */ createElement19("feMerge", null, mergeElements) : null));
    outsetElement = /* @__PURE__ */ createElement19("g", {
      filter: outsideShadowId.urlLink,
      ...svgShadowProps
    }, /* @__PURE__ */ createElement19("use", {
      ...svgStrokeAttributes,
      fill: "black",
      fillOpacity: fillAlpha <= 0 ? 0 : 1,
      stroke: "black",
      strokeOpacity: strokeAlpha <= 0 ? 0 : 1,
      strokeWidth: strokeAlpha > 0 ? strokeWidth : 0,
      xlinkHref: shapeId.link,
      clipPath: strokeClipId.urlLink
    }));
  }
  if (insetShadows.length) {
    insetShadows.reverse();
    const insideShadowId = shapeId.add("_shadow_inside");
    const normalizedFrame = Rect.atOrigin(rect);
    const shadowFrames = [normalizedFrame];
    for (let i = 0, il = insetShadows.length; i < il; i++) {
      const shadow = insetShadows[i];
      const shadowFrame = localShadowFrame(shadow, normalizedFrame, true);
      if (shadowFrame === null) {
        continue;
      }
      shadowFrames.push(shadowFrame);
    }
    const shadowRect = Rect.merge(...shadowFrames);
    const width = rect.width + (strokeWidth ? strokeWidth / 2 : 0.1);
    const height = rect.height + (strokeWidth ? strokeWidth / 2 : 0.1);
    const filterX = shadowRect.x / width * 100;
    const filterY = shadowRect.y / height * 100;
    const filterWidth = shadowRect.width / width * 100;
    const filterHeight = shadowRect.height / height * 100;
    const filterElements = [];
    const mergeElements = [];
    for (let i = 0, il = insetShadows.length; i < il; i++) {
      const shadow = insetShadows[i];
      const shadowElements = innerShadowElements(shapeId, shadow, i);
      filterElements.push(shadowElements.filterElements);
      mergeElements.push(shadowElements.mergeElement);
    }
    definition.push(/* @__PURE__ */ createElement19("filter", {
      key: insideShadowId.id,
      id: insideShadowId.id,
      x: `${filterX.toFixed(1)}%`,
      y: `${filterY.toFixed(1)}%`,
      width: `${filterWidth.toFixed(1)}%`,
      height: `${filterHeight.toFixed(1)}%`,
      filterUnits: "objectBoundingBox",
      ...svgShadowProps
    }, filterElements, insetShadows.length > 1 ? /* @__PURE__ */ createElement19("feMerge", null, mergeElements) : null));
    let clipPath;
    if (needsStrokeClip) {
      clipPath = strokeClipId.urlLink;
    }
    insetElement = /* @__PURE__ */ createElement19("use", {
      fill: "black",
      fillOpacity: "1",
      filter: insideShadowId.urlLink,
      xlinkHref: shapeId.link,
      clipPath,
      ...svgShadowProps
    });
  }
  return { definition, outsetElement, insetElement, needsStrokeClip };
}
function outerShadowElements(shapeID, shadow, index) {
  const shadowKey = shapeID.add("_outer_shadow" + index);
  const offsetResultId = shadowKey.add("offset").id;
  const blurResultId = shadowKey.add("blur").id;
  const matrixResultId = shadowKey.add("matrix").id;
  const filterElements = /* @__PURE__ */ createElement19(OuterShadowFilterElements, {
    key: shadowKey.id + "-filters",
    shadow,
    blurId: blurResultId,
    offsetId: offsetResultId,
    matrixId: matrixResultId
  });
  const mergeElement = /* @__PURE__ */ createElement19("feMergeNode", {
    key: shadowKey.id + "-merge",
    in: matrixResultId
  });
  return { filterElements, mergeElement };
}
var OuterShadowFilterElements = (props) => {
  const lookup = useContext21(CustomPropertiesContext);
  const { shadow, blurId, offsetId, matrixId } = props;
  let color2 = shadow.color;
  const result = lookup(color2);
  if (result) {
    color2 = result;
  }
  const rgb = ConvertColor.toRgb(color2);
  const r = roundedNumberString(rgb.r / 255, 3);
  const g = roundedNumberString(rgb.g / 255, 3);
  const b2 = roundedNumberString(rgb.b / 255, 3);
  const matrixValues = `0 0 0 0 ${r}   0 0 0 0 ${g}   0 0 0 0 ${b2}  0 0 0 ${rgb.a} 0`;
  return /* @__PURE__ */ createElement19(Fragment6, null, /* @__PURE__ */ createElement19("feOffset", {
    dx: shadow.x,
    dy: shadow.y,
    in: "SourceAlpha",
    result: offsetId
  }), /* @__PURE__ */ createElement19("feGaussianBlur", {
    stdDeviation: shadow.blur / 2,
    in: offsetId,
    result: blurId
  }), /* @__PURE__ */ createElement19("feColorMatrix", {
    colorInterpolationFilters: "sRGB",
    values: matrixValues,
    type: "matrix",
    in: blurId,
    result: matrixId
  }));
};
function innerShadowElements(shapeID, shadow, index) {
  const shadowKey = shapeID.add("_inside_shadow" + index);
  const blurId = shadowKey.add("blur").id;
  const offsetId = shadowKey.add("offset").id;
  const compositeId = shadowKey.add("composite").id;
  const matrixId = shadowKey.add("matrix").id;
  const filterElements = /* @__PURE__ */ createElement19(InnerShadowFilterElements, {
    key: shadowKey.id + "-filters",
    shadow,
    blurId,
    offsetId,
    compositeId,
    matrixId
  });
  const mergeElement = /* @__PURE__ */ createElement19("feMergeNode", {
    key: shadowKey.id + "-merge",
    in: matrixId
  });
  return { filterElements, mergeElement };
}
var InnerShadowFilterElements = (props) => {
  const lookup = useContext21(CustomPropertiesContext);
  const { shadow, blurId, offsetId, compositeId, matrixId } = props;
  let color2 = shadow.color;
  const result = lookup(color2);
  if (result) {
    color2 = result;
  }
  const rgb = ConvertColor.toRgb(color2);
  const r = rgb.r / 255;
  const g = rgb.g / 255;
  const b2 = rgb.b / 255;
  const matrixValues = `0 0 0 0 ${r}   0 0 0 0 ${g}   0 0 0 0 ${b2}  0 0 0 ${rgb.a} 0`;
  return /* @__PURE__ */ createElement19(Fragment6, null, /* @__PURE__ */ createElement19("feGaussianBlur", {
    stdDeviation: shadow.blur / 2,
    in: "SourceAlpha",
    result: blurId
  }), /* @__PURE__ */ createElement19("feOffset", {
    dx: shadow.x,
    dy: shadow.y,
    in: blurId,
    result: offsetId
  }), /* @__PURE__ */ createElement19("feComposite", {
    in: offsetId,
    in2: "SourceAlpha",
    operator: "arithmetic",
    k2: "-1",
    k3: "1",
    result: compositeId
  }), /* @__PURE__ */ createElement19("feColorMatrix", {
    colorInterpolationFilters: "sRGB",
    values: matrixValues,
    type: "matrix",
    in: compositeId,
    result: matrixId
  }));
};
function localShadowFrame(shadow, frame2, isSVG2) {
  let growth = shadow.blur;
  if (BoxShadow.is(shadow)) {
    if (isSVG2 !== true) {
      if (shadow.inset)
        return null;
      growth += shadow.spread;
    }
  }
  let minX;
  let maxX;
  let minY;
  let maxY;
  if (isSVG2 === true) {
    minX = -Math.abs(shadow.x) - growth;
    maxX = Math.abs(shadow.x) + frame2.width + growth;
    minY = -Math.abs(shadow.y) - growth;
    maxY = Math.abs(shadow.y) + frame2.height + growth;
  } else {
    minX = shadow.x - growth;
    maxX = shadow.x + frame2.width + growth;
    minY = shadow.y - growth;
    maxY = shadow.y + frame2.height + growth;
  }
  if (maxX <= minX || maxY <= minY)
    return null;
  return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
}

// src/render/utils/filtersForNode.ts
function collectLayerFilters(props, style) {
  const filters = [];
  if (isFiniteNumber(props.brightness)) {
    filters.push(`brightness(${props.brightness / 100})`);
  }
  if (isFiniteNumber(props.contrast)) {
    filters.push(`contrast(${props.contrast / 100})`);
  }
  if (isFiniteNumber(props.grayscale)) {
    filters.push(`grayscale(${props.grayscale / 100})`);
  }
  if (isFiniteNumber(props.hueRotate)) {
    filters.push(`hue-rotate(${props.hueRotate}deg)`);
  }
  if (isFiniteNumber(props.invert)) {
    filters.push(`invert(${props.invert / 100})`);
  }
  if (isFiniteNumber(props.saturate)) {
    filters.push(`saturate(${props.saturate / 100})`);
  }
  if (isFiniteNumber(props.sepia)) {
    filters.push(`sepia(${props.sepia / 100})`);
  }
  if (isFiniteNumber(props.blur)) {
    filters.push(`blur(${props.blur}px)`);
  }
  if (props.dropShadows) {
    filters.push(...shadowsAsFilter(props.dropShadows));
  }
  if (filters.length === 0)
    return;
  style.filter = style.WebkitFilter = filters.join(" ");
}
function collectBackgroundFilters(props, style) {
  if (isFiniteNumber(props.backgroundBlur)) {
    style.backdropFilter = style.WebkitBackdropFilter = `blur(${props.backgroundBlur}px)`;
  }
}
function collectFiltersFromProps(props, style) {
  collectBackgroundFilters(props, style);
  collectLayerFilters(props, style);
}

// src/render/traits/TextColor.ts
function collectTextColorFromProps(props, style) {
  const { color: color2 } = props;
  if (typeof color2 === "string") {
    style.color = color2;
  } else if (Color.isColorObject(color2)) {
    style.color = color2.initialValue || Color.toRgbString(color2);
  }
}

// src/render/style/collectVisualStyleFromProps.ts
function collectVisualStyleFromProps(props, style, isTextNode = false) {
  collectBackgroundFromProps(props, style);
  collectRadiusFromProps(props, style);
  collectFiltersFromProps(props, style);
  collectBlendingFromProps(props, style);
  collectOverflowFromProps(props, style);
  collectOpacityFromProps(props, style);
  collectTextColorFromProps(props, style);
  if (isTextNode) {
    collectTextShadowsForProps(props, style);
  } else {
    collectBoxShadowsForProps(props, style);
  }
}

// src/render/traits/Transform.ts
var { getNumber } = Animatable;
var transformDefaults = {
  z: 0,
  rotation: 0,
  rotationX: 0,
  rotationY: 0,
  rotationZ: 0,
  scale: 1,
  scaleX: 1,
  scaleY: 1,
  scaleZ: 1,
  skew: 0,
  skewX: 0,
  skewY: 0,
  originX: 0.5,
  originY: 0.5,
  originZ: 0
};
function getRotation(rotation, rotate) {
  if (typeof rotate === "string") {
    rotate = parseFloat(rotate);
  }
  return isFiniteNumber(rotate) ? rotate : getNumber(rotation);
}
function collectTransformFromProps(props, rect, style) {
  const motionStyle = style;
  const x = typeof rect.x === "number" ? `${rect.x}px` : rect.x;
  const y = typeof rect.y === "number" ? `${rect.y}px` : rect.y;
  const z = getNumber(props.z);
  const scaleZ = getNumber(props.scaleZ);
  const originZ = getNumber(props.originZ);
  const rotationZ = getRotation(props.rotationZ, resolveMotionValue(motionStyle.rotateZ));
  const rotationX = getRotation(props.rotationX, resolveMotionValue(motionStyle.rotateX));
  const rotationY = getRotation(props.rotationY, resolveMotionValue(motionStyle.rotateY));
  const scale2 = getNumber(props.scale);
  const scaleX = getNumber(props.scaleX);
  const scaleY = getNumber(props.scaleY);
  const skew = getNumber(props.skew);
  const skewX = getNumber(props.skewX);
  const skewY = getNumber(props.skewY);
  const rotation = getRotation(props.rotation, resolveMotionValue(motionStyle.rotate));
  const force3d = RenderEnvironment.target === RenderTarget.export;
  if (force3d || z !== 0 || scaleZ !== 1 || originZ !== 0 || rotationZ !== 0 || rotationX !== 0 || rotationY !== 0) {
    style.transform = `
            ${`translate3d(${x}, ${y}, ${z}px)`}
            scale3d(${scaleX * scale2}, ${scaleY * scale2}, ${scaleZ})
            skew(${skew}deg,${skew}deg)
            skewX(${skewX}deg)
            skewY(${skewY}deg)
            translateZ(${originZ}px)
            rotateX(${rotationX}deg)
            rotateY(${rotationY}deg)
            rotateZ(${(rotation + rotationZ).toFixed(4)}deg)
            translateZ(${-originZ}px)`;
  } else {
    style.transform = `
            ${`translate(${x}, ${y})`}
            scale(${scaleX * scale2}, ${scaleY * scale2})
            skew(${skew}deg,${skew}deg)
            skewX(${skewX}deg)
            skewY(${skewY}deg)
            rotate(${rotation.toFixed(4)}deg)`;
  }
  const transformOrigin = `${getNumber(props.originX) * 100}% ${getNumber(props.originY) * 100}%`;
  style.transformOrigin = transformOrigin;
  style.WebkitTransformOrigin = transformOrigin;
}

// src/render/presentation/Frame/DeprecatedFrame.tsx
function cssBackgroundSize(size2) {
  switch (size2) {
    case "fit":
      return "contain";
    case "stretch":
      return "100% 100%";
    default:
      return "cover";
  }
}
function collectBackgroundImageFromProps(props, style) {
  const image = backgroundImageFromProps(props);
  if (image) {
    style.backgroundImage = `url("${image.src}")`;
    style.backgroundSize = cssBackgroundSize(image.fit);
    style.backgroundRepeat = "no-repeat";
    style.backgroundPosition = "center";
  }
}
function toPixelString(value) {
  return isFiniteNumber(value) ? `${value}px` : value;
}
function applyLayoutProp(style, props, key6) {
  if (props[key6] !== void 0) {
    const value = Animatable.get(props[key6], void 0);
    style[key6] = toPixelString(value);
  }
}
var _DeprecatedFrame = class extends Layer {
  constructor() {
    super(...arguments);
    this.element = null;
    this.imageDidChange = false;
    this.state = {
      size: null
    };
    this.updateStyle = () => {
      if (!this.element) {
        return;
      }
      Object.assign(this.element.style, this.getStyle());
    };
    this.setElement = (element) => {
      this.element = element;
    };
    this.onPropsChange = (props) => {
      const rect = _DeprecatedFrame.rect(Animatable.objectToValues(props.value));
      if (this.state.size && isAnimatable2(this.state.size.width) && isAnimatable2(props.value.width)) {
        this.state.size.width.set(rect.width);
      }
      if (this.state.size && isAnimatable2(this.state.size.height) && isAnimatable2(props.value.height)) {
        this.state.size.height.set(rect.height);
      }
      this.updateStyle();
    };
    this.onSizeChange = () => {
      this.updateStyle();
    };
  }
  static rect(props) {
    const constraintValues = ConstraintValues.fromProperties(props);
    return ConstraintValues.toRect(constraintValues, props.parentSize || null, null, true);
  }
  get rect() {
    return _DeprecatedFrame.rect(this.props);
  }
  static getDerivedStateFromProps(nextProps, prevState) {
    const size2 = _DeprecatedFrame.updatedSize(nextProps, prevState);
    const { target } = RenderEnvironment;
    const nextBackgroundImageSrc = nextProps.background && BackgroundImage.isImageObject(nextProps.background) ? nextProps.background.src : null;
    if (nextBackgroundImageSrc) {
      return {
        size: size2
      };
    }
    if (prevState.size) {
      if (target === RenderTarget.preview) {
        return null;
      }
      if (prevState.size.width === size2.width && prevState.size.height === size2.height) {
        return null;
      }
    }
    return {
      size: size2
    };
  }
  static updatedSize(props, state) {
    const rect = _DeprecatedFrame.rect(props);
    let size2 = state.size;
    const newSize = { width: rect.width, height: rect.height };
    const { target } = RenderEnvironment;
    if (!size2) {
      if (target === RenderTarget.preview) {
        size2 = ObservableObject(newSize, true);
      } else {
        size2 = newSize;
      }
    } else {
      if (isAnimatable2(size2.width) && isAnimatable2(size2.height)) {
        size2.width.set(newSize.width);
        size2.height.set(newSize.height);
      } else {
        size2 = newSize;
      }
    }
    return size2;
  }
  getStyle() {
    const rect = this.rect;
    const style = {
      display: "block",
      position: "absolute",
      width: `${rect.width}px`,
      height: `${rect.height}px`,
      pointerEvents: void 0,
      userSelect: "none"
    };
    let left = Animatable.get(this.props.left, void 0);
    let top = Animatable.get(this.props.top, void 0);
    Object.assign(style, this.props._initialStyle);
    const hasParentSize = this.context.size !== ParentSizeState.Disabled;
    const perspective = Animatable.get(this.props.perspective, void 0);
    style.perspective = perspective;
    style.WebkitPerspective = perspective;
    let backfaceVisibility = void 0;
    const backfaceVisible = Animatable.get(this.props.backfaceVisible, void 0);
    if (backfaceVisible === true) {
      backfaceVisibility = "visible";
    } else if (backfaceVisible === false) {
      backfaceVisibility = "hidden";
    }
    style.backfaceVisibility = backfaceVisibility;
    style.WebkitBackfaceVisibility = backfaceVisibility;
    const preserve3d = Animatable.get(this.props.preserve3d, void 0);
    if (preserve3d === true) {
      style.transformStyle = "preserve-3d";
    } else if (preserve3d === false) {
      style.transformStyle = "flat";
    }
    if (!hasParentSize) {
      applyLayoutProp(style, this.props, "right");
      applyLayoutProp(style, this.props, "bottom");
      const width = Animatable.get(this.props.width, void 0);
      const stringWidth = toPixelString(width);
      const height = Animatable.get(this.props.height, void 0);
      const stringHeight = toPixelString(height);
      if (typeof left === "string" && left.endsWith("%") && this.props.right === null) {
        left = `calc(${left} - calc(${stringWidth}} / 2))`;
        style.width = stringWidth;
      }
      if (typeof top === "string" && top.endsWith("%") && this.props.bottom === null) {
        top = `calc(${top} - calc(${stringHeight} / 2))`;
        style.height = stringHeight;
      }
      if (top !== void 0 && style.bottom !== void 0) {
        style.height = void 0;
        top = toPixelString(Animatable.get(this.props.top, void 0));
      } else {
        style.height = stringHeight;
      }
      if (left !== void 0 && style.right !== void 0) {
        style.width = void 0;
        left = toPixelString(Animatable.get(this.props.left, void 0));
      } else {
        style.width = stringWidth;
      }
    }
    const transformRect = { ...rect };
    if (typeof left !== "undefined") {
      transformRect.x = left;
    }
    if (typeof top !== "undefined") {
      transformRect.y = top;
    }
    collectTransformFromProps(this.props, transformRect, style);
    collectVisualStyleFromProps(this.props, style);
    collectBackgroundImageFromProps(this.props, style);
    Layer.applyWillChange(this.props, style, false);
    if (this.props.style) {
      Object.assign(style, this.props.style);
    }
    return style;
  }
  componentDidMount() {
    const { target } = RenderEnvironment;
    if (target === RenderTarget.preview) {
      this.propsObserver = ObservableObject(this.props, true);
      this.propsObserverCancel = ObservableObject.addObserver(this.propsObserver, this.onPropsChange);
      if (this.props.parentSize && isAnimatable2(this.props.parentSize.width) && isAnimatable2(this.props.parentSize.height)) {
        this.sizeObserver = ObservableObject(this.props.parentSize, true);
        this.sizeObserverCancel = ObservableObject.addObserver(this.sizeObserver, this.onSizeChange);
      }
    }
  }
  componentDidUpdate() {
    const { target } = RenderEnvironment;
    this.propsObserverCancel && this.propsObserverCancel();
    this.sizeObserverCancel && this.sizeObserverCancel();
    if (target === RenderTarget.preview) {
      this.propsObserver = ObservableObject(this.props, true);
      this.propsObserverCancel = ObservableObject.addObserver(this.propsObserver, this.onPropsChange);
      if (this.props.parentSize && isAnimatable2(this.props.parentSize.width) && isAnimatable2(this.props.parentSize.height)) {
        this.sizeObserver = ObservableObject(this.props.parentSize, true);
        this.sizeObserverCancel = ObservableObject.addObserver(this.sizeObserver, this.onSizeChange);
      }
    }
  }
  componentWillUnmount() {
    this.propsObserverCancel && this.propsObserverCancel();
    this.propsObserverCancel = void 0;
    this.sizeObserverCancel && this.sizeObserverCancel();
    this.sizeObserverCancel = void 0;
  }
  render() {
    if (safeWindow["perf"])
      safeWindow["perf"].nodeRender();
    const { visible, id, className } = this.props;
    if (!visible) {
      return null;
    }
    const style = this.getStyle();
    const rect = this.rect;
    const parentSize = { width: rect.width, height: rect.height };
    return /* @__PURE__ */ createElement20("div", {
      id,
      style,
      ref: this.setElement,
      className
    }, /* @__PURE__ */ createElement20(ProvideParentSize, {
      parentSize
    }, this.layoutChildren()), /* @__PURE__ */ createElement20(Border, {
      ...this.props
    }));
  }
  layoutChildren() {
    let _forwardedOverrides = this.props._forwardedOverrides;
    const extractions = this.props._overrideForwardingDescription;
    if (extractions) {
      let added = false;
      _forwardedOverrides = {};
      for (const key6 in extractions) {
        added = true;
        _forwardedOverrides[key6] = this.props[extractions[key6]];
      }
      if (!added) {
        _forwardedOverrides = void 0;
      }
    }
    let children = Children4.map(this.props.children, (child) => {
      if (isConstraintSupportingChild(child)) {
        return cloneElement3(child, {
          parentSize: this.state.size,
          _forwardedOverrides
        });
      } else if (_forwardedOverrides && child) {
        return cloneElement3(child, { _forwardedOverrides });
      } else {
        return child;
      }
    });
    if (children && children.length === 1 && typeof children[0] === "string") {
      children = [/* @__PURE__ */ createElement20(Center, {
        key: "0"
      }, children)];
    }
    return children;
  }
};
var DeprecatedFrame = _DeprecatedFrame;
DeprecatedFrame.supportsConstraints = true;
DeprecatedFrame.defaultFrameSpecificProps = {
  ...constraintDefaults,
  ...transformDefaults,
  opacity: 1,
  background: Color("rgba(0, 170, 255, 0.3)"),
  visible: true,
  borderWidth: 0,
  borderColor: "#222",
  borderStyle: "solid"
};
DeprecatedFrame.defaultProps = {
  ...Layer.defaultProps,
  ..._DeprecatedFrame.defaultFrameSpecificProps
};
DeprecatedFrame.contextType = ConstraintsContext;
var Center = (props) => {
  const style = Object.assign({}, {
    height: "100%",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    fontFamily: "Helvetica"
  }, props.style || {});
  return /* @__PURE__ */ createElement20("div", {
    style
  }, props.children);
};

// src/render/presentation/Frame/isDeprecatedFrameProps.ts
var frameWithMotionPropsFields = [
  "_border",
  "_constraints",
  "animate",
  "initial",
  "variants",
  "transition",
  "inherit",
  "center",
  "initial",
  "transformTemplate",
  "transformValues",
  "animate",
  "variants",
  "transition",
  "onUpdate",
  "onAnimationComplete",
  "onPanSessionStart",
  "onTapCancel",
  "whileTap",
  "whileHover",
  "onHoverStart",
  "onHoverEnd",
  "drag",
  "dragDirectionLock",
  "dragPropagation",
  "dragConstraints",
  "dragElastic",
  "dragMomentum",
  "dragTransition",
  "onDragStart",
  "onDragEnd",
  "onDrag",
  "onDirectionLock",
  "onDragTransitionEnd",
  "x",
  "y",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "position",
  "border",
  "borderRadius",
  "shadow",
  "size"
];
var deprecatedFramePropsFields = [
  "autoSize",
  "aspectRatio",
  "borderWidth",
  "borderStyle",
  "borderColor",
  "centerX",
  "centerY"
];
function isDeprecatedFrameProps(props) {
  let field;
  for (const propKey in props) {
    if (isAnimatable2(props[propKey]))
      return true;
  }
  for (field of frameWithMotionPropsFields) {
    if (props.hasOwnProperty(field))
      return false;
  }
  for (field of deprecatedFramePropsFields) {
    if (props.hasOwnProperty(field))
      return true;
  }
  return false;
}

// src/render/presentation/Frame/index.tsx
var DeprecatedFrameWithEvents = WithEvents(DeprecatedFrame);
var Frame = forwardRef3(function Frame2(props, ref) {
  const parentSize = useParentSize();
  if (isDeprecatedFrameProps(props)) {
    const currentParentSize = props.parentSize || deprecatedParentSize(parentSize);
    return /* @__PURE__ */ createElement21(DeprecatedFrameWithEvents, {
      ...props,
      parentSize: currentParentSize
    });
  }
  return /* @__PURE__ */ createElement21(FrameWithMotion, {
    ...props,
    ref
  });
});

// src/components/EmptyState.tsx
function EmptyState({
  title = "",
  description = "Click and drag the connector to any frame on the canvas \u2192",
  children,
  size: size2,
  hide,
  insideUserCodeComponent = false
}) {
  const { target } = RenderEnvironment;
  const childCount = Children5.count(children);
  if (insideUserCodeComponent && childCount === 0) {
    return /* @__PURE__ */ createElement22(FrameWithMotion, {
      ...size2,
      "data-name": "placeholder"
    });
  }
  if (target !== RenderTarget.canvas)
    return null;
  if (hide)
    return null;
  if (childCount !== 0)
    return null;
  return /* @__PURE__ */ createElement22(FrameWithMotion, {
    key: "empty-state",
    className: "framerInternalUI-canvasPlaceholder",
    top: 0,
    left: 0,
    bottom: 0,
    right: 0,
    style: { position: "absolute" }
  }, /* @__PURE__ */ createElement22("div", {
    style: {
      display: "flex",
      alignItems: "center",
      lineHeight: "1.4",
      height: "100%",
      width: "100%"
    }
  }, /* @__PURE__ */ createElement22("div", {
    style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexDirection: "column",
      width: "100%",
      WebkitMaskImage: `linear-gradient(90deg, black, black calc(100% - 12px * ${scaleFactor}), transparent)`
    }
  }, /* @__PURE__ */ createElement22(Title, null, title), /* @__PURE__ */ createElement22(Description, null, description))));
}
var scaleFactor = "var(--framerInternalCanvas-canvasPlaceholderContentScaleFactor, 1)";
var Title = ({ children }) => {
  return /* @__PURE__ */ createElement22("span", {
    style: {
      display: "flex",
      flexDirection: "column",
      textAlign: "center",
      flexGrow: 1,
      flexShrink: 0,
      fontWeight: 600,
      marginBottom: "5px"
    }
  }, children);
};
var Description = ({ children }) => {
  return /* @__PURE__ */ createElement22("span", {
    style: {
      display: "flex",
      flexDirection: "column",
      textAlign: "center",
      flexGrow: 1,
      flexShrink: 0,
      fontWeight: 400,
      maxWidth: "200px"
    }
  }, children);
};

// src/components/Scroll/useWheelScroll.ts
import { useRef as useRef15, useCallback as useCallback5 } from "react";

// src/render/utils/debounce.ts
function debounce(fn, time3) {
  let timeout;
  const debounced = (...args) => {
    safeWindow.clearTimeout(timeout);
    timeout = safeWindow.setTimeout(fn, time3, ...args);
  };
  const cancel = () => {
    safeWindow.clearTimeout(timeout);
  };
  debounced.cancel = cancel;
  return debounced;
}

// src/components/Scroll/useWheelScroll.ts
function useWheelScroll(ref, {
  enabled,
  initial,
  prev,
  direction,
  constraints,
  offsetX,
  offsetY,
  onScrollStart,
  onScroll,
  onScrollEnd
}) {
  const isWheelScrollActive = useRef15(false);
  const getPointData = useCallback5(() => {
    const point = getPoint(offsetX, offsetY);
    const data = {
      point,
      velocity: { x: offsetX.getVelocity(), y: offsetY.getVelocity() },
      offset: { x: point.x - initial.x, y: point.y - initial.y },
      delta: { x: point.x - prev.x, y: point.y - prev.y }
    };
    prev.x = point.x;
    prev.y = point.y;
    return data;
  }, []);
  let handler;
  if (enabled) {
    let clampX = function(v) {
      return constraints.current === null ? v : clamp3(v, constraints.current.left, constraints.current.right);
    }, clampY = function(v) {
      return constraints.current === null ? v : clamp3(v, constraints.current.top, constraints.current.bottom);
    }, updateX = function(delta2) {
      offsetX.stop();
      offsetX.set(clampX(offsetX.get() - delta2));
    }, updateY = function(delta2) {
      offsetY.stop();
      offsetY.set(clampY(offsetY.get() - delta2));
    };
    const debouncedOnScrollEnd = debounce(() => {
      onScrollEnd && onScrollEnd(getPointData());
      isWheelScrollActive.current = false;
    }, 200);
    handler = (e) => {
      e.preventDefault();
      if (!isWheelScrollActive.current) {
        const x = offsetX.get();
        const y = offsetY.get();
        initial.x = x;
        initial.y = y;
        prev.x = x;
        prev.y = y;
        onScrollStart && onScrollStart(getPointData());
        isWheelScrollActive.current = true;
      }
      switch (direction) {
        case "horizontal":
          updateX(e.deltaX);
          break;
        case "vertical":
          updateY(e.deltaY);
          break;
        default:
          updateX(e.deltaX);
          updateY(e.deltaY);
      }
      onScroll && onScroll(getPointData());
      debouncedOnScrollEnd();
    };
  }
  useDomEvent(ref, "wheel", handler, { passive: false });
}
function getPoint(x, y) {
  return { x: x.get(), y: y.get() };
}

// src/components/Scroll/EmulatedScroll.tsx
var directionMap = {
  horizontal: "x",
  vertical: "y",
  both: true
};
function convertScrollDirectionToDrag(scrollDirection) {
  return scrollDirection ? directionMap[scrollDirection] : scrollDirection;
}
var useUpdateChildSize = ({
  dragDirection,
  children,
  fromCanvasComponent
}) => {
  return useMemo10(() => {
    return Children6.map(children, (child) => {
      if (child === null || typeof child !== "object" || typeof child.type === "string") {
        return child;
      }
      const updatedSize = {};
      switch (dragDirection) {
        case "vertical":
          updatedSize.width = "100%";
          break;
        case "horizontal":
          updatedSize.height = "100%";
          break;
        default:
          return child;
      }
      const update = fromCanvasComponent ? { style: Object.assign({}, child.props.style, updatedSize) } : updatedSize;
      return cloneElement4(child, update);
    });
  }, [dragDirection, children]);
};
var numberFromOptionalMotionValue = (value) => {
  return typeof value === "number" ? value : value.get();
};
var EmulatedScroll = forwardRef4(function EmulatedScroll2(props, forwardedRef) {
  const {
    direction = "vertical",
    directionLock = false,
    dragEnabled = true,
    dragElastic,
    dragMomentum,
    dragTransition,
    wheelEnabled = true,
    contentOffsetX = 0,
    contentOffsetY = 0,
    contentWidth,
    contentHeight,
    onScrollStart,
    onScroll,
    onScrollEnd,
    onDragStart,
    onDrag,
    onDragEnd,
    onUpdate,
    onDirectionLock,
    style,
    children,
    scrollAnimate,
    resetOffset,
    overdragEnabled = true,
    layoutId: specificLayoutId,
    native,
    ...containerProps
  } = props;
  const layoutId = useLayoutId2(props, { specificLayoutId, postfix: "scroll" });
  const defaultX = useMotionValue(typeof contentOffsetX === "number" ? contentOffsetX : 0);
  const defaultY = useMotionValue(typeof contentOffsetY === "number" ? contentOffsetY : 0);
  const x = isMotionValue2(contentOffsetX) ? contentOffsetX : defaultX;
  const y = isMotionValue2(contentOffsetY) ? contentOffsetY : defaultY;
  const measuredConstraints = useRef16(null);
  const dragControls = useDragControls();
  const isInTarget = useIsInCurrentNavigationTarget();
  const wasInTargetRef = useRef16(true);
  injectComponentCSSRules();
  useEffect17(() => {
    dragControls.updateConstraints();
  });
  function setMeasureDragConstraints(constraints) {
    constraints = offsetToZero(constraints);
    if (contentWidth !== void 0)
      constraints.left = -contentWidth;
    if (contentHeight !== void 0)
      constraints.top = -contentHeight;
    return measuredConstraints.current = constraints;
  }
  const { initial, prev } = useRef16({
    initial: { x: 0, y: 0 },
    prev: { x: 0, y: 0 }
  }).current;
  const isPreview = RenderTarget.current() === RenderTarget.preview;
  const containerFallbackRef = useRef16(null);
  const containerRef = forwardedRef || containerFallbackRef;
  const contentRef = useRef16(null);
  const lastOffsetRef = useRef16(null);
  function shouldResetScroll(inTarget) {
    const hasEnteredTarget = inTarget && wasInTargetRef.current === false;
    return resetOffset && hasEnteredTarget;
  }
  function measureAndUpdateScrollOffset() {
    if (!contentRef.current || !containerRef.current)
      return;
    const mustReset = shouldResetScroll(isInTarget);
    wasInTargetRef.current = isInTarget;
    const previous = lastOffsetRef.current;
    if (previous === null && contentOffsetX === void 0 && contentOffsetY === void 0)
      return;
    const shouldUpdateOffset = previous === null || !isMotionValue2(contentOffsetX) && contentOffsetX !== previous.offsetX || !isMotionValue2(contentOffsetY) && contentOffsetY !== previous.offsetY;
    const currentMaxXOffset = contentRef.current.offsetWidth - containerRef.current.offsetWidth;
    const currentMaxYOffset = contentRef.current.offsetHeight - containerRef.current.offsetHeight;
    const hasSizeChanged = currentMaxXOffset !== (previous == null ? void 0 : previous.maxXOffset) || currentMaxYOffset !== (previous == null ? void 0 : previous.maxYOffset);
    const hasScrollOffsetChanged = (previous == null ? void 0 : previous.x) !== x.get() || (previous == null ? void 0 : previous.y) !== y.get();
    const shouldStayPinned = hasSizeChanged && !hasScrollOffsetChanged;
    if (mustReset || shouldUpdateOffset || shouldStayPinned) {
      const currentOffsetX = direction !== "vertical" ? numberFromOptionalMotionValue(contentOffsetX) : 0;
      const currentOffsetY = direction !== "horizontal" ? numberFromOptionalMotionValue(contentOffsetY) : 0;
      const nextXOffset = -Math.min(currentOffsetX, currentMaxXOffset);
      const nextYOffset = -Math.min(currentOffsetY, currentMaxYOffset);
      x.set(nextXOffset);
      y.set(nextYOffset);
      lastOffsetRef.current = {
        maxXOffset: currentMaxXOffset,
        maxYOffset: currentMaxYOffset,
        offsetX: currentOffsetX,
        offsetY: currentOffsetY,
        x: nextXOffset,
        y: nextYOffset
      };
    }
  }
  useLayoutEffect5(() => {
    if (RenderTarget.current() !== RenderTarget.canvas)
      return;
    measureAndUpdateScrollOffset();
  });
  useLayoutEffect5(() => {
    if (RenderTarget.current() === RenderTarget.canvas)
      return;
    measureAndUpdateScrollOffset();
  }, []);
  useEffect17(() => {
    if (shouldResetScroll(isInTarget))
      measureAndUpdateScrollOffset();
    if (isInTarget === false)
      wasInTargetRef.current = false;
  }, [isInTarget]);
  const getLatestPoint = () => ({ x: x.get(), y: y.get() });
  const resetInitialPoint = useCallback7(() => {
    const point = getLatestPoint();
    initial.x = point.x;
    initial.y = point.y;
    prev.x = point.x;
    prev.y = point.y;
  }, []);
  const getPointData = useCallback7(() => {
    const point = getLatestPoint();
    const data = {
      point,
      velocity: { x: x.getVelocity(), y: y.getVelocity() },
      offset: { x: point.x - initial.x, y: point.y - initial.y },
      delta: { x: point.x - prev.x, y: point.y - prev.y }
    };
    prev.x = point.x;
    prev.y = point.y;
    return data;
  }, [x, y]);
  const updateScrollListeners = useCallback7(() => {
    onUpdate && onUpdate({ x: x.get(), y: y.get() });
    onScroll && onScroll(getPointData());
  }, [onScroll, onUpdate, getPointData, x, y]);
  const scheduleUpdateScrollListeners = useCallback7(() => {
    es_default.update(updateScrollListeners, false, true);
  }, [updateScrollListeners]);
  const onMotionDragStart = (event, info) => {
    resetInitialPoint();
    onDragStart && onDragStart(event, info);
    onScrollStart && onScrollStart(info);
  };
  const onMotionDragTransitionEnd = () => onScrollEnd && onScrollEnd(getPointData());
  const onWheelScrollStart = (info) => {
    dragControls.updateConstraints();
    onScrollStart == null ? void 0 : onScrollStart(info);
  };
  useWheelScroll(containerRef, {
    enabled: wheelEnabled,
    initial,
    prev,
    direction,
    offsetX: x,
    offsetY: y,
    onScrollStart: onWheelScrollStart,
    onScroll,
    onScrollEnd,
    constraints: measuredConstraints
  });
  const overdragX = useMotionValue(0);
  const overdragY = useMotionValue(0);
  useLayoutEffect5(() => {
    const setScrollX = (xValue) => {
      const element = containerRef.current;
      if (!(element instanceof HTMLDivElement))
        return;
      element.scrollLeft = -xValue;
      const constraints = measuredConstraints.current;
      if (constraints && overdragEnabled) {
        let overdragXValue = 0;
        if (xValue > constraints.right)
          overdragXValue = xValue;
        if (xValue < constraints.left)
          overdragXValue = xValue - constraints.left;
        overdragX.set(overdragXValue);
      }
      scheduleUpdateScrollListeners();
    };
    const currentX = x.get();
    if (currentX !== 0)
      setScrollX(currentX);
    return x.onChange(setScrollX);
  }, [x, overdragX, scheduleUpdateScrollListeners, overdragEnabled]);
  useLayoutEffect5(() => {
    const setScrollY = (yValue) => {
      const element = containerRef.current;
      if (!(element instanceof HTMLDivElement))
        return;
      element.scrollTop = -yValue;
      const constraints = measuredConstraints.current;
      if (constraints && overdragEnabled) {
        let overdragYValue = 0;
        if (yValue > constraints.bottom)
          overdragYValue = yValue;
        if (yValue < constraints.top)
          overdragYValue = yValue - constraints.top;
        overdragY.set(overdragYValue);
      }
      scheduleUpdateScrollListeners();
    };
    const currentY = y.get();
    if (currentY !== 0)
      setScrollY(currentY);
    return y.onChange(setScrollY);
  }, [y, overdragY, scheduleUpdateScrollListeners, overdragEnabled]);
  const nativeOnScroll = useCallback6(() => {
    const element = containerRef.current;
    if (!(element instanceof HTMLDivElement))
      return;
    const xDelta = Math.abs(x.get() + element.scrollLeft);
    const yDelta = Math.abs(y.get() + element.scrollTop);
    if (xDelta > 1)
      x.set(-element.scrollLeft);
    if (yDelta > 1)
      y.set(-element.scrollTop);
  }, [x, y]);
  const isEmpty2 = Children6.count(children) === 0;
  const width = direction !== "vertical" && !isEmpty2 ? "auto" : "100%";
  const height = direction !== "horizontal" && !isEmpty2 ? "auto" : "100%";
  const size2 = !containerProps.__fromCanvasComponent ? {
    width: containerProps.__fromCodeComponentNode ? "100%" : containerProps.width,
    height: containerProps.__fromCodeComponentNode ? "100%" : containerProps.height
  } : {};
  return /* @__PURE__ */ createElement23(FrameWithMotion, {
    "data-framer-component-type": "Scroll",
    background: "none",
    ...containerProps,
    ...size2,
    style: {
      ...style,
      willChange: isPreview ? "transform" : void 0,
      overflow: "hidden"
    },
    onScroll: nativeOnScroll,
    preserve3d: containerProps.preserve3d,
    ref: containerRef,
    layoutId,
    onBeforeLayoutMeasure: measureAndUpdateScrollOffset
  }, /* @__PURE__ */ createElement23(FrameWithMotion, {
    "data-framer-component-type": "ScrollContentWrapper",
    animate: scrollAnimate,
    drag: dragEnabled && convertScrollDirectionToDrag(direction),
    dragDirectionLock: directionLock,
    dragElastic,
    dragMomentum,
    dragTransition,
    dragConstraints: containerRef,
    dragControls,
    onDragStart: onMotionDragStart,
    onDrag,
    onDragEnd,
    onDragTransitionEnd: onMotionDragTransitionEnd,
    onDirectionLock,
    onMeasureDragConstraints: setMeasureDragConstraints,
    width,
    height,
    _dragX: x,
    _dragY: y,
    position: "relative",
    x: overdragEnabled ? overdragX : void 0,
    y: overdragEnabled ? overdragY : void 0,
    ref: contentRef,
    style: {
      display: isEmpty2 ? "block" : "inline-block",
      willChange: isPreview ? "transform" : void 0,
      backgroundColor: "transparent",
      overflow: "visible",
      minWidth: "100%",
      minHeight: "100%"
    },
    preserve3d: containerProps.preserve3d
  }, /* @__PURE__ */ createElement23(EmptyState, {
    children,
    size: {
      width: isFiniteNumber(containerProps.width) ? containerProps.width : "100%",
      height: isFiniteNumber(containerProps.height) ? containerProps.height : "100%"
    },
    insideUserCodeComponent: !containerProps.__fromCodeComponentNode,
    title: "Scroll",
    description: "Click and drag the connector to any frame on the canvas \u2192"
  }), useUpdateChildSize({
    dragDirection: direction,
    children,
    fromCanvasComponent: containerProps.__fromCanvasComponent
  })));
});
function offsetToZero({ top, left, right, bottom }) {
  const width = right - left;
  const height = bottom - top;
  return {
    top: -height,
    left: -width,
    right: 0,
    bottom: 0
  };
}

// src/components/Scroll/NativeScroll.tsx
import {
  createElement as createElement24,
  forwardRef as forwardRef5,
  useLayoutEffect as useLayoutEffect7,
  useRef as useRef17
} from "react";

// src/modules/cx.ts
function cx(...classNames) {
  return classNames.filter(Boolean).join(" ");
}

// src/components/utils/useEmulatedTouchScroll.ts
import React27, { useEffect as useEffect18 } from "react";

// src/components/utils/animatePointWithInertia.ts
var AnimationPhase;
(function(AnimationPhase2) {
  AnimationPhase2[AnimationPhase2["None"] = 0] = "None";
  AnimationPhase2[AnimationPhase2["Running"] = 1] = "Running";
  AnimationPhase2[AnimationPhase2["Completed"] = 2] = "Completed";
  AnimationPhase2[AnimationPhase2["Cancelled"] = 3] = "Cancelled";
})(AnimationPhase || (AnimationPhase = {}));
function isRunningAnimation(...phases) {
  let runningAny = false;
  let cancelledAny = false;
  phases.forEach((phase) => {
    runningAny = runningAny || phase === 1;
    cancelledAny = cancelledAny || phase === 3;
  });
  return runningAny && !cancelledAny;
}
function didFinishAnimations(...phases) {
  return phases.every((phase) => phase === 0 || phase === 2);
}
var timeConstant = 400;
function animatePointWithInertia({
  from,
  velocity,
  onUpdate,
  onComplete,
  onStop
}) {
  const latest = from;
  let animationPhaseX = 0;
  let animationPhaseY = 0;
  const animations2 = [];
  const updateHandler = () => {
    if (isRunningAnimation(animationPhaseX, animationPhaseY)) {
      onUpdate(latest);
    }
  };
  const completionHandler = () => {
    if (didFinishAnimations(animationPhaseX, animationPhaseY)) {
      onComplete();
    }
  };
  if (velocity.x) {
    animationPhaseX = 1;
    animations2.push(inertia({
      from: from.x,
      velocity: -velocity.x,
      timeConstant,
      onUpdate: (value) => {
        latest.x = value;
        es_default.update(updateHandler, false, true);
      },
      onComplete: () => {
        if (animationPhaseX !== 1) {
          throw Error("animation x should be running when completing");
        }
        animationPhaseX = 2;
        completionHandler();
      }
    }));
  }
  if (velocity.y) {
    animationPhaseY = 1;
    animations2.push(inertia({
      from: from.y,
      velocity: -velocity.y,
      timeConstant,
      onUpdate: (value) => {
        latest.y = value;
        es_default.update(updateHandler, false, true);
      },
      onComplete: () => {
        if (animationPhaseY !== 1) {
          throw Error("animation y should be running when completing");
        }
        animationPhaseY = 2;
        completionHandler();
      }
    }));
  }
  if (!isRunningAnimation(animationPhaseX, animationPhaseY)) {
    completionHandler();
  }
  return {
    stop: () => {
      if (!isRunningAnimation(animationPhaseX, animationPhaseY))
        return;
      animations2.forEach((animation) => animation.stop());
      animationPhaseX = animationPhaseX === 1 ? 3 : animationPhaseX;
      animationPhaseY = animationPhaseY === 1 ? 3 : animationPhaseY;
      onStop();
    }
  };
}

// src/components/utils/useEmulatedTouchScroll.ts
var scrollThreshold = 3;
var isTouchDevice = isTouch();
var isSafariBrowser = isSafari();
function getTouchAction(element) {
  if (!(element instanceof HTMLElement))
    return null;
  return element.style.touchAction;
}
function canPanInDirection(element, direction) {
  switch (direction) {
    case "horizontal":
      return getTouchAction(element) === "pan-x";
    case "vertical":
      return getTouchAction(element) === "pan-y";
    default:
      return false;
  }
}
function isInteractiveElement(element) {
  const tag = element.tagName.toLowerCase();
  if (tag === "input")
    return true;
  if (tag === "text")
    return true;
  if (tag === "textarea")
    return true;
  return false;
}
function canStartScrollFromElement(element, direction) {
  if (!(element instanceof Element))
    return false;
  if (isInteractiveElement(element))
    return false;
  if (element.hasAttribute("draggable")) {
    if (!canPanInDirection(element, direction)) {
      return false;
    }
  }
  return true;
}
function getEventPoint(event) {
  return {
    x: event.pageX,
    y: event.pageY
  };
}
function setStyle(element, property, value) {
  if (element == null ? void 0 : element.style) {
    element.style[property] = value;
  }
}
function getStyle(element, property) {
  var _a;
  return (_a = element == null ? void 0 : element.style) == null ? void 0 : _a[property];
}
var TouchScrollPhase;
(function(TouchScrollPhase2) {
  TouchScrollPhase2[TouchScrollPhase2["Idle"] = 0] = "Idle";
  TouchScrollPhase2[TouchScrollPhase2["TouchDown"] = 1] = "TouchDown";
  TouchScrollPhase2[TouchScrollPhase2["Drag"] = 2] = "Drag";
  TouchScrollPhase2[TouchScrollPhase2["DragLocked"] = 3] = "DragLocked";
  TouchScrollPhase2[TouchScrollPhase2["DragAnimation"] = 4] = "DragAnimation";
  TouchScrollPhase2[TouchScrollPhase2["Interrupted"] = 5] = "Interrupted";
})(TouchScrollPhase || (TouchScrollPhase = {}));
var emptyObject = {};
Object.freeze(emptyObject);
function useEmulateTouchScroll(ref, direction, enabled) {
  if (isTouchDevice)
    return emptyObject;
  if (RenderTarget.current() !== RenderTarget.preview)
    return emptyObject;
  const scrollAnimationControlsRef = React27.useRef(null);
  useEffect18(() => {
    if (!ref.current)
      return;
    const element = ref.current;
    let phase = 0;
    let targets = null;
    let downPoint = null;
    let scrollOffsetStart = null;
    let mouseMoveEvents = [];
    function onMouseMove(event) {
      var _a;
      switch (phase) {
        case 0:
        case 4:
        case 3:
          return;
      }
      if (event.metaKey)
        return;
      const point = getEventPoint(event);
      if (!downPoint)
        return;
      const offset = Point.subtract(point, downPoint);
      if (phase === 1 || phase === 5) {
        const deltaX = Math.abs(offset.x);
        const deltaY = Math.abs(offset.y);
        if ((deltaX > scrollThreshold || deltaY > scrollThreshold) && deltaX !== deltaY) {
          const scrollDirection = deltaX > deltaY ? "horizontal" : "vertical";
          const shouldIgnoreBecauseOfDirectionLock = direction === "horizontal" && scrollDirection === "vertical" || direction === "vertical" && scrollDirection === "horizontal";
          if (shouldIgnoreBecauseOfDirectionLock) {
            phase = 3;
            return;
          }
          phase = 2;
          targets == null ? void 0 : targets.forEach(([target]) => setStyle(target, "pointerEvents", "none"));
        }
      }
      if (isSafariBrowser)
        event.preventDefault();
      if (phase !== 2)
        return;
      (_a = window.getSelection()) == null ? void 0 : _a.empty();
      mouseMoveEvents = getRecentEvents([...mouseMoveEvents, event]);
      if (scrollOffsetStart) {
        if (direction !== "vertical")
          element.scrollLeft = scrollOffsetStart.x - offset.x;
        if (direction !== "horizontal")
          element.scrollTop = scrollOffsetStart.y - offset.y;
      }
    }
    function onMouseUp(event) {
      window.removeEventListener("mousemove", onMouseMove, false);
      window.removeEventListener("mouseup", onMouseUp);
      if (phase === 2 && targets) {
        targets.forEach(([target, originalPointerEventsValue]) => setStyle(target, "pointerEvents", originalPointerEventsValue || "auto"));
      }
      targets = null;
      const velocity = calculateVelocity({ mouseMoveEvents, mouseUpEvent: event });
      downPoint = null;
      if (phase === 2) {
        const shouldAnimateY = direction !== "horizontal" && velocity.y !== 0;
        const shouldAnimateX = direction !== "vertical" && velocity.x !== 0;
        if (!shouldAnimateY && !shouldAnimateX) {
          phase = 0;
          return;
        }
        phase = 4;
        scrollAnimationControlsRef.current = animatePointWithInertia({
          from: { x: element.scrollLeft, y: element.scrollTop },
          velocity: {
            x: shouldAnimateX ? velocity.x : 0,
            y: shouldAnimateY ? velocity.y : 0
          },
          onUpdate: (position) => {
            if (shouldAnimateX)
              element.scrollLeft = position.x;
            if (shouldAnimateY)
              element.scrollTop = position.y;
          },
          onStop: () => {
            if (phase !== 5) {
              phase = 0;
            }
            scrollAnimationControlsRef.current = null;
          },
          onComplete: () => {
            if (phase !== 4) {
              throw Error("On animation completion we should still be in the animation phase");
            }
            phase = 0;
            scrollAnimationControlsRef.current = null;
          }
        });
      } else {
        phase = 0;
      }
    }
    function onMouseWheel() {
      var _a;
      (_a = scrollAnimationControlsRef.current) == null ? void 0 : _a.stop();
    }
    function onMouseDown(event) {
      var _a;
      if (!enabled)
        return;
      if (event.metaKey)
        return;
      if (!canStartScrollFromElement(event.target, direction)) {
        if (phase === 4) {
          phase = 0;
          (_a = scrollAnimationControlsRef.current) == null ? void 0 : _a.stop();
        }
        return;
      }
      const previousPhase = phase;
      phase = previousPhase === 4 ? 5 : 1;
      downPoint = getEventPoint(event);
      targets = document.elementsFromPoint(downPoint.x, downPoint.y).filter((targetEl) => targetEl instanceof HTMLElement || targetEl instanceof SVGElement).map((targetEl) => [targetEl, getStyle(targetEl, "pointerEvents")]);
      scrollOffsetStart = { x: element.scrollLeft, y: element.scrollTop };
      mouseMoveEvents = [];
      if (scrollAnimationControlsRef.current) {
        if (previousPhase !== 4) {
          throw Error("When stopping a drag animation we need to be animating");
        }
        scrollAnimationControlsRef.current.stop();
      }
      window.addEventListener("mousemove", onMouseMove);
      window.addEventListener("mouseup", onMouseUp);
      element.addEventListener("mousewheel", onMouseWheel);
    }
    element.addEventListener("mousedown", onMouseDown);
    return () => {
      var _a;
      element.removeEventListener("mousedown", onMouseDown);
      element.removeEventListener("mousewheel", onMouseWheel);
      window.removeEventListener("mousemove", onMouseMove);
      window.removeEventListener("mouseup", onMouseUp);
      phase = 5;
      (_a = scrollAnimationControlsRef.current) == null ? void 0 : _a.stop();
    };
  }, [ref, direction, enabled]);
  return React27.useMemo(() => {
    return {
      cancelEmulatedTouchScrollAnimation: () => {
        var _a;
        (_a = scrollAnimationControlsRef.current) == null ? void 0 : _a.stop();
      }
    };
  }, []);
}
var timeDelta = 4 / 60 * 1e3;
function getRecentEvents(events2) {
  const currentTime = new CustomEvent("getTime").timeStamp;
  const maxAge = currentTime - timeDelta;
  return events2.filter((event) => event.timeStamp > maxAge);
}
var zeroPoint = { x: 0, y: 0 };
function calculateVelocity({
  mouseMoveEvents,
  mouseUpEvent
}) {
  const recentMouseMoveEvents = getRecentEvents(mouseMoveEvents);
  const oldestMouseMoveEvent = recentMouseMoveEvents[0];
  if (!oldestMouseMoveEvent)
    return zeroPoint;
  const deltaX = mouseUpEvent.clientX - oldestMouseMoveEvent.clientX;
  const deltaY = mouseUpEvent.clientY - oldestMouseMoveEvent.clientY;
  const time3 = mouseUpEvent.timeStamp - oldestMouseMoveEvent.timeStamp;
  if (time3 === 0)
    return zeroPoint;
  return {
    x: deltaX / time3 * 1e3,
    y: deltaY / time3 * 1e3
  };
}

// src/components/NavigationContainerContext.tsx
import {
  createContext as createContext12
} from "react";
import { useContext as useContext22 } from "react";
var NavigationContainerContext = createContext12(true);
function useIsInCurrentNavigationTarget() {
  const isInCurrentNavigationTarget = useContext22(NavigationContainerContext);
  return isInCurrentNavigationTarget;
}

// src/components/utils/useUpdateScrollOffset.ts
import { useLayoutEffect as useLayoutEffect6 } from "react";
function useUpdateScrollOffset(ref, side, offset, cancelEmulatedTouchScrollAnimation) {
  useLayoutEffect6(() => {
    if (isMotionValue2(offset)) {
      const updateScrollLeft = () => {
        cancelEmulatedTouchScrollAnimation == null ? void 0 : cancelEmulatedTouchScrollAnimation();
        const element = ref.current;
        if (element)
          element[side] = Math.abs(offset.get());
      };
      updateScrollLeft();
      return offset.onChange(updateScrollLeft);
    } else if (isFiniteNumber(offset)) {
      const element = ref.current;
      if (!element)
        return;
      cancelEmulatedTouchScrollAnimation == null ? void 0 : cancelEmulatedTouchScrollAnimation();
      element[side] = Math.abs(offset);
    }
  }, [offset]);
}

// src/components/Scroll/NativeScroll.tsx
var NativeScroll = forwardRef5(function NativeScroll2(props, forwardedRef) {
  const {
    direction = "vertical",
    scrollBarVisible = false,
    dragEnabled = true,
    contentOffsetX = 0,
    contentOffsetY = 0,
    contentWidth,
    contentHeight,
    children,
    resetOffset,
    onScroll,
    className,
    directionLock = false,
    wheelEnabled = true,
    scrollAnimate,
    dragTransition,
    dragMomentum,
    dragElastic,
    overdragEnabled = true,
    onScrollStart,
    onScrollEnd,
    onDragStart,
    onDrag,
    onDragEnd,
    onUpdate,
    onDirectionLock,
    layoutId: specificLayoutId,
    native,
    ...containerProps
  } = props;
  const layoutId = useLayoutId2(props, { specificLayoutId, postfix: "scroll" });
  const fallbackRef = useRef17(null);
  const ref = forwardedRef || fallbackRef;
  const { cancelEmulatedTouchScrollAnimation } = useEmulateTouchScroll(ref, direction, dragEnabled);
  injectComponentCSSRules();
  const isInTarget = useIsInCurrentNavigationTarget();
  const previousIsInTargetRef = useRef17(isInTarget);
  const updateScrollOffsetHandler = () => {
    if (!resetOffset)
      return;
    const previousIsTarget = previousIsInTargetRef.current;
    previousIsInTargetRef.current = isInTarget;
    const shouldResetOffset = isInTarget && !previousIsTarget;
    if (!shouldResetOffset)
      return;
    const element = ref.current;
    if (!element)
      return;
    if (direction !== "vertical") {
      cancelEmulatedTouchScrollAnimation == null ? void 0 : cancelEmulatedTouchScrollAnimation();
      element.scrollLeft = Math.abs(isMotionValue2(contentOffsetX) ? contentOffsetX.get() : contentOffsetX);
    }
    if (direction !== "horizontal") {
      cancelEmulatedTouchScrollAnimation == null ? void 0 : cancelEmulatedTouchScrollAnimation();
      element.scrollTop = Math.abs(isMotionValue2(contentOffsetY) ? contentOffsetY.get() : contentOffsetY);
    }
  };
  useLayoutEffect7(updateScrollOffsetHandler, [isInTarget]);
  useUpdateScrollOffset(ref, "scrollLeft", contentOffsetX, cancelEmulatedTouchScrollAnimation);
  useUpdateScrollOffset(ref, "scrollTop", contentOffsetY, cancelEmulatedTouchScrollAnimation);
  const size2 = !containerProps.__fromCanvasComponent ? {
    width: containerProps.__fromCodeComponentNode ? "100%" : containerProps.width,
    height: containerProps.__fromCodeComponentNode ? "100%" : containerProps.height
  } : {};
  return /* @__PURE__ */ createElement24(FrameWithMotion, {
    ref,
    "data-framer-component-type": "NativeScroll",
    background: "none",
    ...containerProps,
    ...size2,
    onScroll,
    layoutId,
    onBeforeLayoutMeasure: updateScrollOffsetHandler,
    className: cx(className, `direction-${direction}`, !scrollBarVisible && "scrollbar-hidden")
  }, /* @__PURE__ */ createElement24(EmptyState, {
    children,
    size: {
      width: isFiniteNumber(containerProps.width) ? containerProps.width : "100%",
      height: isFiniteNumber(containerProps.height) ? containerProps.height : "100%"
    },
    insideUserCodeComponent: !containerProps.__fromCodeComponentNode,
    title: "Scroll",
    description: "Click and drag the connector to any frame on the canvas \u2192"
  }), children);
});

// src/components/Scroll/Scroll.tsx
var Scroll = forwardRef6(function Scroll2(props, forwardedRef) {
  if (props.native) {
    return /* @__PURE__ */ createElement25(NativeScroll, {
      ref: forwardedRef,
      ...props
    });
  } else {
    return /* @__PURE__ */ createElement25(EmulatedScroll, {
      ref: forwardedRef,
      ...props
    });
  }
});
addPropertyControls(Scroll, {
  native: {
    type: ControlType.Boolean,
    defaultValue: false
  },
  direction: {
    type: ControlType.SegmentedEnum,
    title: "Direction",
    options: ["vertical", "horizontal", "both"],
    defaultValue: "vertical"
  },
  contentOffsetX: {
    type: ControlType.Number,
    title: "Offset X",
    defaultValue: 0,
    min: 0,
    step: 10,
    displayStepper: true,
    hidden: ({ direction }) => direction === "vertical"
  },
  contentOffsetY: {
    type: ControlType.Number,
    title: "Offset Y",
    defaultValue: 0,
    min: 0,
    step: 10,
    displayStepper: true,
    hidden: ({ direction }) => direction === "horizontal"
  },
  directionLock: {
    type: ControlType.Boolean,
    title: "Lock",
    enabledTitle: "1 Axis",
    disabledTitle: "Off",
    defaultValue: true,
    hidden: ({ native }) => native === true
  },
  dragEnabled: {
    type: ControlType.Boolean,
    title: "Drag",
    enabledTitle: "On",
    disabledTitle: "Off",
    defaultValue: true
  },
  overdragEnabled: {
    type: ControlType.Boolean,
    title: "Overdrag",
    enabledTitle: "On",
    disabledTitle: "Off",
    defaultValue: true,
    hidden: ({ native }) => native === true
  },
  wheelEnabled: {
    type: ControlType.Boolean,
    title: "Wheel",
    enabledTitle: "On",
    disabledTitle: "Off",
    defaultValue: true,
    hidden: ({ native }) => native === true
  },
  scrollBarVisible: {
    type: ControlType.Boolean,
    title: "Scroll Bar",
    enabledTitle: "Visible",
    disabledTitle: "Hidden",
    defaultValue: false,
    hidden: ({ native }) => native === false
  },
  resetOffset: {
    type: ControlType.Boolean,
    title: "Reset",
    enabledTitle: "True",
    disabledTitle: "False",
    defaultValue: false
  }
});
Scroll.supportsConstraints = true;

// src/components/Draggable.ts
var Draggable = WithDragging(DeprecatedFrameWithEvents);

// src/components/Scroll/DeprecatedScroll.tsx
import {
  Children as Children7,
  Component as Component6,
  cloneElement as cloneElement5,
  createElement as createElement26
} from "react";

// src/components/utils/RectProvider.ts
function isRectProviding(c2) {
  return "rect" in c2 && c2.rect instanceof Function;
}

// src/utils/observable.ts
function getObservableNumber(value, defaultValue = 0) {
  if (!value) {
    return defaultValue;
  }
  if (isAnimatable2(value)) {
    return value.get();
  }
  return value;
}

// src/components/Scroll/DeprecatedScroll.tsx
var _DeprecatedScroll = class extends Component6 {
  wrapHandlers(dragHandler, scrollHandler) {
    if (!scrollHandler) {
      return dragHandler;
    }
    return (event, draggable) => {
      if (dragHandler) {
        dragHandler(event, draggable);
      }
      scrollHandler(event, this);
    };
  }
  render() {
    return /* @__PURE__ */ createElement26(ConsumeParentSize, null, ({ size: newParentSize }) => {
      const parentSize = deprecatedParentSize(newParentSize);
      const frameProps = Object.assign({}, this.props, {
        parentSize
      });
      Object.keys(_DeprecatedScroll.scrollProps).map((key6) => {
        delete frameProps[key6];
      });
      if (!this.props.children) {
        return /* @__PURE__ */ createElement26(DeprecatedFrame, {
          ...frameProps
        }, /* @__PURE__ */ createElement26(Draggable, {
          width: frameProps.width,
          height: frameProps.height
        }));
      }
      const contentSize = { top: 0, left: 0, bottom: 0, right: 0 };
      const { width, height } = DeprecatedFrame.rect(frameProps);
      const children = Children7.map(this.props.children, (child) => {
        if (child === null || typeof child !== "object" || typeof child.type === "string") {
          return child;
        }
        const type = child.type;
        if (isRectProviding(type)) {
          const frame2 = type.rect(child.props, parentSize);
          if (frame2) {
            contentSize.top = Math.min(Rect.minY(frame2), contentSize.top);
            contentSize.left = Math.min(Rect.minX(frame2), contentSize.left);
            contentSize.bottom = Math.max(Rect.maxY(frame2), contentSize.bottom);
            contentSize.right = Math.max(Rect.maxX(frame2), contentSize.right);
          }
        }
        const update = {};
        if (this.props.direction === "vertical") {
          update.width = width;
        } else if (this.props.direction === "horizontal") {
          update.height = height;
        }
        return cloneElement5(child, update);
      });
      const {
        onScrollStart,
        onScroll,
        onScrollEnd,
        onScrollSessionStart,
        onScrollSessionEnd
      } = this.props;
      const w = getObservableNumber(width);
      const h = getObservableNumber(height);
      const contentW = Math.max(contentSize.right, w);
      const contentH = Math.max(contentSize.bottom, h);
      const x = Math.min(0, w - contentW);
      const y = Math.min(0, h - contentH);
      const constraints = {
        x,
        y,
        width: contentW + contentW - w,
        height: contentH + contentH - h
      };
      const draggableProps = {};
      draggableProps.enabled = this.props.draggingEnabled;
      draggableProps.background = "none";
      draggableProps.width = contentW;
      draggableProps.height = contentH;
      draggableProps.constraints = constraints;
      draggableProps.onMove = this.props.onMove;
      draggableProps.onDragSessionStart = this.wrapHandlers(this.props.onDragSessionStart, onScrollSessionStart);
      draggableProps.onDragSessionMove = this.props.onDragSessionMove;
      draggableProps.onDragSessionEnd = this.wrapHandlers(this.props.onDragSessionEnd, onScrollSessionEnd);
      draggableProps.onDragAnimationStart = this.props.onDragAnimationStart;
      draggableProps.onDragAnimationEnd = this.props.onDragAnimationEnd;
      draggableProps.onDragDidMove = this.wrapHandlers(this.props.onDragDidMove, onScroll);
      draggableProps.onDragDirectionLockStart = this.props.onDragDirectionLockStart;
      draggableProps.onDragStart = this.wrapHandlers(this.props.onDragStart, onScrollStart);
      draggableProps.onDragEnd = this.wrapHandlers(this.props.onDragEnd, onScrollEnd);
      draggableProps.onDragWillMove = this.props.onDragWillMove;
      draggableProps.horizontal = this.props.direction !== "vertical";
      draggableProps.vertical = this.props.direction !== "horizontal";
      draggableProps.directionLock = this.props.directionLock;
      draggableProps.mouseWheel = true;
      draggableProps.left = this.props.contentOffsetX;
      draggableProps.top = this.props.contentOffsetY;
      draggableProps.preserve3d = this.props.preserve3d;
      return /* @__PURE__ */ createElement26(DeprecatedFrame, {
        ...frameProps
      }, /* @__PURE__ */ createElement26(Draggable, {
        ...draggableProps
      }, children), /* @__PURE__ */ createElement26(EmptyState, {
        children: this.props.children,
        size: { width: w, height: h },
        title: "Connect to scrollable area"
      }));
    });
  }
};
var DeprecatedScroll = _DeprecatedScroll;
DeprecatedScroll.supportsConstraints = true;
DeprecatedScroll.scrollProps = {
  draggingEnabled: true,
  direction: "vertical",
  directionLock: true,
  mouseWheel: true,
  contentOffsetX: null,
  contentOffsetY: null
};
DeprecatedScroll.defaultProps = Object.assign({}, DeprecatedFrame.defaultProps, _DeprecatedScroll.scrollProps, {
  overflow: "visible",
  background: "none",
  width: "100%",
  height: "100%"
});
DeprecatedScroll.propertyControls = {
  direction: {
    type: ControlType.SegmentedEnum,
    title: "Direction",
    options: ["vertical", "horizontal", "both"]
  },
  directionLock: {
    type: ControlType.Boolean,
    title: "Lock",
    enabledTitle: "1 Axis",
    disabledTitle: "Off",
    hidden(props) {
      return props.direction !== "both";
    }
  }
};

// src/components/Screen.tsx
import {
  Component as Component9,
  createElement as createElement27,
  createRef as createRef2
} from "react";

// src/events/recognizer/GestureRecognizer.ts
var State3;
(function(State4) {
  State4[State4["Possible"] = 2] = "Possible";
  State4[State4["Began"] = 4] = "Began";
  State4[State4["Changed"] = 8] = "Changed";
  State4[State4["Ended"] = 16] = "Ended";
  State4[State4["Failed"] = 32] = "Failed";
  State4[State4["Cancelled"] = 64] = "Cancelled";
  State4[State4["Recognized"] = 128] = "Recognized";
})(State3 || (State3 = {}));
function stateName(state) {
  switch (state) {
    case 2:
      return "Possible";
    case 4:
      return "Began";
    case 8:
      return "Changed";
    case 16:
      return "Ended";
    case 32:
      return "Failed";
    case 64:
      return "Cancelled";
    case 128:
      return "Recognized";
    default:
      return "Unknown";
  }
}
function containsBitmask(value, bitmask) {
  return (value & bitmask) !== 0;
}
var GestureRecognizer = class {
  constructor() {
    this._state = 2;
    this.preventers = [];
  }
  get state() {
    return this._state;
  }
  setState(state) {
    this._state = state;
  }
  get isPrevented() {
    let prevented = false;
    for (const recognizer of this.preventers) {
      if (recognizer.state & (4 | 8 | 16)) {
        prevented = true;
        break;
      }
    }
    return prevented;
  }
  canBePreventedBy(recognizer) {
    this.preventers.push(recognizer);
  }
  hasState(bitmask) {
    return containsBitmask(this.state, bitmask);
  }
  stateSwitch(newState) {
    let allowedStates;
    switch (this.state) {
      case 2:
        allowedStates = 4 | 128 | 32;
        break;
      case 4:
        allowedStates = 8 | 64 | 16;
        break;
      case 8:
        allowedStates = 8 | 64 | 16;
        break;
      case 128:
      case 16:
      case 64:
      case 32:
        allowedStates = 2;
        break;
      default:
        allowedStates = 0;
    }
    if (!containsBitmask(newState, allowedStates)) {
      console.warn(`Unallowed state change from ${stateName(this.state)} to ${stateName(newState)}`);
      return;
    }
    this.setState(newState);
  }
  cancel() {
    if (this.hasState(4 | 8)) {
      this.setState(64);
    }
    this.reset();
  }
  reset() {
    if (!this.hasState(2)) {
      this.stateSwitch(2);
    }
  }
};

// src/events/recognizer/PanGestureRecognizer.ts
var PanGestureRecognizer = class extends GestureRecognizer {
  constructor() {
    super(...arguments);
    this.eventType = "pan";
  }
  pointerSessionBegan(session, event) {
    this.recognize(session, event);
  }
  pointerSessionMoved(session, event) {
    this.recognize(session, event);
  }
  pointerSessionEnded(session, event) {
    this.panend(event);
  }
  recognize(session, event) {
    if (Math.abs(event.delta.x) > 0 || Math.abs(event.delta.y) > 0) {
      if (this.startEvent) {
        this.pan(event);
      } else {
        this.panstart(event);
      }
    }
  }
  reset() {
    this.startEvent = null;
    super.reset();
  }
  panstart(event) {
    if (!this.hasState(State3.Possible) || event.isLeftMouseClick !== void 0 && !event.isLeftMouseClick) {
      return;
    }
    this.stateSwitch(State3.Began);
    this.startEvent = event;
    if (this.handler && this.startEvent.target) {
      this.handler.gestureBegan(this.eventType, event, this.startEvent.target);
    }
  }
  pan(event) {
    if (!this.hasState(State3.Began | State3.Changed)) {
      return;
    }
    if (!this.startEvent) {
      return;
    }
    this.stateSwitch(State3.Changed);
    if (this.handler && this.startEvent.target) {
      this.handler.gestureChanged(this.eventType, event, this.startEvent.target);
    }
  }
  panend(event) {
    if (!this.hasState(State3.Began | State3.Changed)) {
      return;
    }
    if (!this.startEvent) {
      return;
    }
    this.stateSwitch(State3.Ended);
    if (this.handler && this.startEvent.target) {
      this.handler.gestureEnded(this.eventType, event, this.startEvent.target);
    }
  }
};

// src/events/recognizer/TapGestureRecognizer.ts
var TapGestureRecognizer = class extends GestureRecognizer {
  constructor() {
    super(...arguments);
    this.eventType = "tap";
  }
  pointerSessionBegan(session, event) {
    if (this.handler && (event.isLeftMouseClick === void 0 || event.isLeftMouseClick)) {
      this.handler.gestureBegan(this.eventType, event, null);
    }
  }
  pointerSessionMoved(session, event) {
  }
  pointerSessionEnded(session, event) {
    if (this.isPrevented) {
      this.stateSwitch(State3.Failed);
    } else if (!session.startEvent || session.startEvent.target === event.target) {
      this.stateSwitch(State3.Recognized);
      if (this.handler) {
        this.handler.gestureChanged(this.eventType, event, null);
      }
    } else {
      this.stateSwitch(State3.Failed);
    }
    if (this.handler) {
      this.handler.gestureEnded(this.eventType, event, null);
    }
  }
};

// src/events/recognizer/MouseWheelGestureRecognizer.ts
var MouseWheelGestureRecognizer = class extends GestureRecognizer {
  constructor() {
    super(...arguments);
    this.eventType = "mousewheel";
    this.onMouseWheelEnd = debounce((event) => {
      if (this.handler && this.startEvent) {
        this.stateSwitch(State3.Ended);
        this.handler.gestureEnded(this.eventType, event, this.startEvent.target);
        this.startEvent = null;
        this.reset();
      }
    }, 300);
  }
  pointerSessionBegan(session, event) {
  }
  pointerSessionMoved(session, event) {
  }
  pointerSessionEnded(session, event) {
  }
  mouseWheel(session, event) {
    if (!this.handler)
      return;
    if (this.hasState(State3.Possible)) {
      this.startEvent = event;
      this.stateSwitch(State3.Began);
      this.handler.gestureBegan(this.eventType, event, this.startEvent.target);
      return;
    }
    if (this.hasState(State3.Began | State3.Changed) && this.startEvent) {
      this.stateSwitch(State3.Changed);
      this.handler.gestureChanged(this.eventType, event, this.startEvent.target);
    }
    this.onMouseWheelEnd(event);
  }
};

// src/events/FramerEventSession.ts
var FramerEventSession = class {
  constructor(dispatcher, customOrigin) {
    this.events = [];
    this.recognizers = [];
    this.mouseWheelRecognizer = new MouseWheelGestureRecognizer();
    this.dispatcher = dispatcher;
    if (customOrigin) {
      this.originElement = customOrigin;
    } else {
      this.originElement = document.body;
    }
    const pan = new PanGestureRecognizer();
    const tap = new TapGestureRecognizer();
    pan.handler = this;
    tap.handler = this;
    this.mouseWheelRecognizer.handler = this;
    this.recognizers = [tap, pan];
  }
  get isStarted() {
    return this.events.length !== 0;
  }
  get startEvent() {
    if (this.isStarted) {
      return this.events[0];
    } else {
      return null;
    }
  }
  get lastEvent() {
    if (this.events.length > 0) {
      return this.events[this.events.length - 1];
    } else {
      return null;
    }
  }
  processEvent(event) {
    this.events.push(event);
    return event;
  }
  pointerDown(event) {
    if (this.isStarted) {
      return;
    }
    this.processEvent(event);
    this.recognizers.map((r) => {
      r.cancel();
      r.pointerSessionBegan(this, event);
    });
  }
  pointerMove(event) {
    if (!this.isStarted) {
      return;
    }
    this.processEvent(event);
    this.recognizers.map((r) => {
      r.pointerSessionMoved(this, event);
    });
  }
  pointerUp(event) {
    if (!this.isStarted) {
      return;
    }
    this.processEvent(event);
    this.recognizers.map((r) => {
      r.pointerSessionEnded(this, event);
    });
    this.clearEvents();
    this.recognizers.map((r) => {
      r.reset();
    });
  }
  mouseWheel(event) {
    this.processEvent(event);
    this.mouseWheelRecognizer.mouseWheel(this, event);
    this.clearEvents();
  }
  clearEvents() {
    this.events = [];
  }
  dispatch(type, event, target = null) {
    const dispatchTarget = target || this.startEvent && this.startEvent.target || event.target;
    if (dispatchTarget) {
      this.dispatcher(type, event, dispatchTarget);
    }
  }
  gestureBegan(type, event, target) {
    this.dispatch(`${type}start`, event, target);
  }
  gestureChanged(type, event, target) {
    this.dispatch(type, event, target);
  }
  gestureEnded(type, event, target) {
    this.dispatch(`${type}end`, event, target);
  }
  velocity(t = Loop.TimeStep * 2) {
    if (!this.isStarted || this.events.length < 2) {
      return { x: 0, y: 0 };
    }
    const events2 = this.events;
    let i = events2.length - 1;
    let event = null;
    while (i >= 0) {
      event = events2[i];
      if (MainLoop.time - event.loopTime > t) {
        break;
      }
      i--;
    }
    if (!event) {
      return { x: 0, y: 0 };
    }
    const current = events2[events2.length - 1];
    const time3 = (MainLoop.time - event.loopTime) * 1e3;
    if (time3 === 0) {
      return { x: 0, y: 0 };
    }
    const velocity = {
      x: (current.devicePoint.x - event.devicePoint.x) / time3,
      y: (current.devicePoint.y - event.devicePoint.y) / time3
    };
    if (velocity.x === Infinity) {
      velocity.x = 0;
    }
    if (velocity.y === Infinity) {
      velocity.y = 0;
    }
    return velocity;
  }
  offset(event) {
    if (!this.startEvent) {
      return { x: 0, y: 0 };
    }
    const subtract = (pointA, pointB) => {
      return {
        x: pointA.x - pointB.x,
        y: pointA.y - pointB.y
      };
    };
    return subtract(event.devicePoint, this.startEvent.devicePoint);
  }
};

// src/events/recognizer/TouchEventListener.ts
import {
  Component as Component7
} from "react";
var TouchEventListener = class extends Component7 {
  constructor() {
    super(...arguments);
    this.domTouchStart = (originalEvent) => {
      safeWindow.addEventListener("touchmove", this.domTouchMove);
      safeWindow.addEventListener("touchend", this.domTouchEnd);
      const event = new FramerEvent(originalEvent, this.props.session);
      this.props.session.pointerDown(event);
    };
    this.domTouchMove = (originalEvent) => {
      const event = new FramerEvent(originalEvent, this.props.session);
      this.props.session.pointerMove(event);
    };
    this.domTouchEnd = (originalEvent) => {
      safeWindow.removeEventListener("touchmove", this.domTouchMove);
      safeWindow.removeEventListener("touchend", this.domTouchEnd);
      const event = new FramerEvent(originalEvent, this.props.session);
      this.props.session.pointerUp(event);
    };
  }
  render() {
    return this.props.children;
  }
  componentDidMount() {
    safeWindow.addEventListener("touchstart", this.domTouchStart);
  }
  componentWillUnmount() {
    safeWindow.removeEventListener("touchstart", this.domTouchStart);
    safeWindow.removeEventListener("touchmove", this.domTouchMove);
    safeWindow.removeEventListener("touchend", this.domTouchEnd);
  }
};

// src/events/recognizer/MouseEventListener.ts
import {
  Component as Component8
} from "react";
var MouseEventListener = class extends Component8 {
  constructor() {
    super(...arguments);
    this.domMouseDown = (originalEvent) => {
      safeWindow.addEventListener("mousemove", this.domMouseMove);
      safeWindow.addEventListener("mouseup", this.domMouseUp);
      const event = new FramerEvent(originalEvent, this.props.session);
      this.props.session.pointerDown(event);
    };
    this.domMouseMove = (originalEvent) => {
      const leftMouseButtonOnlyDown = originalEvent.buttons === void 0 ? originalEvent.which === 1 : originalEvent.buttons === 1;
      if (!leftMouseButtonOnlyDown) {
        this.domMouseUp(originalEvent);
        return;
      }
      const event = new FramerEvent(originalEvent, this.props.session);
      this.props.session.pointerMove(event);
    };
    this.domMouseUp = (originalEvent) => {
      safeWindow.removeEventListener("mousemove", this.domMouseMove);
      safeWindow.removeEventListener("mouseup", this.domMouseUp);
      const event = new FramerEvent(originalEvent, this.props.session);
      this.props.session.pointerUp(event);
    };
    this.domMouseWheel = (originalEvent) => {
      const event = new FramerEvent(originalEvent, this.props.session);
      this.props.session.mouseWheel(event);
    };
  }
  render() {
    return this.props.children;
  }
  componentDidMount() {
    safeWindow.addEventListener("mousedown", this.domMouseDown);
    safeWindow.addEventListener("wheel", this.domMouseWheel);
  }
  componentWillUnmount() {
    safeWindow.removeEventListener("mousemove", this.domMouseMove);
    safeWindow.removeEventListener("mousedown", this.domMouseDown);
    safeWindow.removeEventListener("mouseup", this.domMouseUp);
    safeWindow.removeEventListener("wheel", this.domMouseWheel);
  }
};

// src/events/FramerEventListener.ts
var FramerEventListener = environment_exports.isTouch() ? TouchEventListener : MouseEventListener;

// src/components/Navigation.tsx
import {
  Children as Children8,
  Component as Component12,
  Suspense,
  cloneElement as cloneElement6,
  createContext as createContext15,
  createElement as createElement32
} from "react";

// src/components/NavigationTransitions.ts
var TransitionDefaults;
(function(TransitionDefaults2) {
  TransitionDefaults2.Fade = {
    exit: { opacity: 0 },
    enter: { opacity: 0 }
  };
  TransitionDefaults2.PushLeft = {
    exit: { x: "-30%" },
    enter: { x: "100%" }
  };
  TransitionDefaults2.PushRight = {
    exit: { x: "30%" },
    enter: { x: "-100%" }
  };
  TransitionDefaults2.PushUp = {
    exit: { y: "-30%" },
    enter: { y: "100%" }
  };
  TransitionDefaults2.PushDown = {
    exit: { y: "30%" },
    enter: { y: "-100%" }
  };
  TransitionDefaults2.Instant = {
    animation: { type: false },
    enter: { opacity: 0 }
  };
  TransitionDefaults2.Modal = {
    overCurrentContext: true,
    goBackOnTapOutside: true,
    position: { center: true },
    enter: { opacity: 0, scale: 1.2 }
  };
  TransitionDefaults2.OverlayLeft = {
    overCurrentContext: true,
    goBackOnTapOutside: true,
    position: { right: 0, top: 0, bottom: 0 },
    enter: { x: "100%" }
  };
  TransitionDefaults2.OverlayRight = {
    overCurrentContext: true,
    goBackOnTapOutside: true,
    position: { left: 0, top: 0, bottom: 0 },
    enter: { x: "-100%" }
  };
  TransitionDefaults2.OverlayUp = {
    overCurrentContext: true,
    goBackOnTapOutside: true,
    position: { bottom: 0, left: 0, right: 0 },
    enter: { y: "100%" }
  };
  TransitionDefaults2.OverlayDown = {
    overCurrentContext: true,
    goBackOnTapOutside: true,
    position: { top: 0, left: 0, right: 0 },
    enter: { y: "-100%" }
  };
  TransitionDefaults2.FlipLeft = {
    backfaceVisible: false,
    exit: { rotateY: -180 },
    enter: { rotateY: 180 }
  };
  TransitionDefaults2.FlipRight = {
    backfaceVisible: false,
    exit: { rotateY: 180 },
    enter: { rotateY: -180 }
  };
  TransitionDefaults2.FlipUp = {
    backfaceVisible: false,
    exit: { rotateX: 180 },
    enter: { rotateX: -180 }
  };
  TransitionDefaults2.FlipDown = {
    backfaceVisible: false,
    exit: { rotateX: -180 },
    enter: { rotateX: 180 }
  };
  TransitionDefaults2.MagicMotion = {
    withMagicMotion: true
  };
})(TransitionDefaults || (TransitionDefaults = {}));
function pushTransition(options) {
  const side = options && options.appearsFrom ? options.appearsFrom : "right";
  switch (side) {
    case "right":
      return TransitionDefaults.PushLeft;
    case "left":
      return TransitionDefaults.PushRight;
    case "bottom":
      return TransitionDefaults.PushUp;
    case "top":
      return TransitionDefaults.PushDown;
  }
}
function overlayTransition(options) {
  const side = options && options.appearsFrom ? options.appearsFrom : "bottom";
  switch (side) {
    case "right":
      return TransitionDefaults.OverlayLeft;
    case "left":
      return TransitionDefaults.OverlayRight;
    case "bottom":
      return TransitionDefaults.OverlayUp;
    case "top":
      return TransitionDefaults.OverlayDown;
  }
}
function flipTransition(options) {
  const side = options && options.appearsFrom ? options.appearsFrom : "bottom";
  switch (side) {
    case "right":
      return TransitionDefaults.FlipLeft;
    case "left":
      return TransitionDefaults.FlipRight;
    case "bottom":
      return TransitionDefaults.FlipUp;
    case "top":
      return TransitionDefaults.FlipDown;
  }
}

// src/components/NavigationContainer.tsx
import {
  createElement as createElement31,
  memo
} from "react";
import { useRef as useRef20, useEffect as useEffect20, useContext as useContext25 } from "react";

// src/components/AnimateLayout/AnimateLayoutTrees.tsx
import {
  Component as Component10,
  createElement as createElement28
} from "react";

// src/components/AnimateLayout/animation.ts
function createAnimation(animation) {
  const { shouldStackAnimate, transition, current, prevViewportBox, onComplete, prevParent } = animation;
  const config = {
    shouldStackAnimate,
    transition,
    current,
    onComplete,
    prevParent: prevParent ? prevParent : void 0
  };
  if (!shouldStackAnimate)
    return config;
  config.originBox = prevViewportBox;
  return config;
}

// src/components/AnimateLayout/TreeContext.ts
import {
  createContext as createContext13
} from "react";
var LayoutTreeContext = createContext13({
  promoteTree: () => false,
  markTreeAsSafeToRemove: () => {
  }
});

// src/components/AnimateLayout/AnimateLayoutTrees.tsx
var syncContextStub = {
  register: () => {
  },
  remove: () => {
  },
  add: () => {
  },
  flush: () => {
  },
  syncUpdate: () => {
  }
};
var TREE_ROOT_ID = "____treeroot";
var AnimateLayoutTrees = class extends Component10 {
  constructor() {
    super(...arguments);
    this.scheduled = false;
    this.resetScheduled = false;
    this.layoutIdConfig = new Map();
    this.treeContext = {
      promoteTree: (...args) => this.promoteTree(...args),
      markTreeAsSafeToRemove: (tree) => this.markTreeAsSafeToRemove(tree)
    };
    this.syncContext = {
      ...syncContextStub,
      forceUpdate: () => {
        this.syncContext = {
          ...this.syncContext
        };
        this.forceUpdate();
      }
    };
    this.batch = createBatcher();
    this.stackCrossfaders = new Map([[TREE_ROOT_ID, createCrossfader()]]);
  }
  promoteTree(tree, shouldAnimate, transition, resets) {
    var _a, _b, _c;
    if (tree === this.lead)
      return false;
    const prevFollow = this.follow;
    this.follow = this.lead;
    this.lead = tree;
    if (resets)
      this.resetScheduled = true;
    if (!shouldAnimate) {
      this.startCrossfade(new Map([[TREE_ROOT_ID, {}]]), { type: false });
      return false;
    }
    this.layoutIdConfig.clear();
    const currentStyle = {};
    for (const [layoutId, lead] of this.lead.children) {
      const follow = (_a = this.follow) == null ? void 0 : _a.children.get(layoutId);
      snapshotRotate(layoutId, lead, follow, currentStyle);
      follow && resetRotate2(follow);
      resetRotate2(lead);
    }
    this.lead.childrenToResetTransform.forEach((child) => child.resetTransform());
    for (const [layoutId, lead] of this.lead.children) {
      const follow = (_b = this.follow) == null ? void 0 : _b.children.get(layoutId);
      follow && snapshotViewportBox(follow);
      snapshotViewportBox(lead);
      const prevViewportBox = (follow == null ? void 0 : follow.prevViewportBox) ? copyAxisBox2(follow == null ? void 0 : follow.prevViewportBox) : void 0;
      const config = {
        lead,
        current: currentStyle[layoutId],
        transition,
        prevViewportBox,
        shouldStackAnimate: follow ? true : false,
        prevParent: follow == null ? void 0 : follow.getProjectionParent()
      };
      this.layoutIdConfig.set(layoutId, config);
    }
    if (prevFollow !== this.lead && prevFollow !== this.follow) {
      (_c = prevFollow == null ? void 0 : prevFollow.rootChild) == null ? void 0 : _c.setVisibility(false);
    }
    this.scheduled = true;
    return true;
  }
  markTreeAsSafeToRemove(tree) {
    this.safeToRemoveTree = tree;
  }
  markTreeChildrenAsSafeToRemove(tree) {
    var _a;
    if (!tree)
      return;
    for (const [_, child] of tree.children) {
      (_a = child.layoutSafeToRemove) == null ? void 0 : _a.call(child);
    }
  }
  componentDidUpdate() {
    if (this.scheduled)
      this.startLayoutAnimation(this.resetScheduled);
    if (this.safeToRemoveTree)
      this.markTreeChildrenAsSafeToRemove(this.safeToRemoveTree);
    this.safeToRemoveTree = void 0;
    this.scheduled = false;
    this.resetScheduled = false;
  }
  componentWillUnmount() {
    this.stopCrossfadeAnimation();
  }
  startLayoutAnimation(shouldReset) {
    const { lead, follow } = this;
    const leadChildren = lead == null ? void 0 : lead.children;
    const followChildren = follow == null ? void 0 : follow.children;
    const toCrossfade = new Map();
    const handler = {
      layoutReady: (child) => {
        const layoutId = child.getLayoutId();
        if (layoutId === void 0)
          return;
        const config = this.layoutIdConfig.get(layoutId);
        if (!config)
          return child.notifyLayoutReady({ shouldStackAnimate: false });
        const followChild = followChildren == null ? void 0 : followChildren.get(layoutId);
        const leadChild = leadChildren == null ? void 0 : leadChildren.get(layoutId);
        child.pointTo(leadChild != null ? leadChild : child);
        const isLead = Boolean(leadChildren && leadChild === child);
        if (isLead) {
          if (followChild && leadChild)
            toCrossfade.set(layoutId, config);
          child.notifyLayoutReady(createAnimation({
            ...config,
            onComplete: () => {
              var _a;
              (_a = followChild == null ? void 0 : followChild.layoutSafeToRemove) == null ? void 0 : _a.call(followChild);
            }
          }));
        }
      }
    };
    if (lead && leadChildren) {
      for (const [_, child] of leadChildren)
        this.batch.add(child);
      lead.layoutMayBeMutated = false;
    }
    if (!shouldReset && follow && followChildren) {
      for (const [_, child] of followChildren)
        this.batch.add(child);
      follow.layoutMayBeMutated = true;
    }
    this.batch.flush(handler);
    this.startCrossfade(toCrossfade);
  }
  startCrossfade(toCrossfade, transition) {
    var _a, _b, _c, _d, _e;
    if (!((_a = this.lead) == null ? void 0 : _a.rootChild))
      return;
    const isExit = (_b = this.follow) == null ? void 0 : _b.isExiting;
    let rootTransition = transition;
    const leadRoot = (_c = this.lead) == null ? void 0 : _c.rootChild;
    const followRoot = (_d = this.follow) == null ? void 0 : _d.rootChild;
    leadRoot == null ? void 0 : leadRoot.setVisibility(true);
    followRoot == null ? void 0 : followRoot.setVisibility(true);
    const createCrossfadeAnimation = (config, id) => {
      var _a2, _b2;
      const followChild = (_a2 = this.follow) == null ? void 0 : _a2.children.get(id);
      const leadChild = (_b2 = this.lead) == null ? void 0 : _b2.children.get(id);
      if (leadChild === leadRoot || followChild === followRoot) {
        if (leadChild === leadRoot)
          rootTransition = config.transition;
        return;
      }
      if (!this.stackCrossfaders.has(id)) {
        this.stackCrossfaders.set(id, createCrossfader());
      }
      const crossfader = this.stackCrossfaders.get(id);
      crossfader.setOptions({
        lead: leadChild,
        follow: followChild
      });
      leadChild == null ? void 0 : leadChild.setCrossfader(crossfader);
      followChild == null ? void 0 : followChild.setCrossfader(crossfader);
      crossfader.toLead(config == null ? void 0 : config.transition);
    };
    toCrossfade.forEach(createCrossfadeAnimation);
    if (!leadRoot || !followRoot)
      return;
    const rootCrossfader = this.stackCrossfaders.get(TREE_ROOT_ID);
    rootCrossfader.setOptions({
      lead: leadRoot,
      follow: followRoot,
      preserveFollowOpacity: !isExit,
      crossfadeOpacity: true
    });
    leadRoot.setCrossfader(rootCrossfader);
    followRoot.setCrossfader(rootCrossfader);
    const leadRootId = leadRoot.getLayoutId();
    const leadTransition = leadRootId ? ((_e = this.layoutIdConfig.get(leadRootId)) == null ? void 0 : _e.transition) || rootTransition : rootTransition;
    rootCrossfader.toLead(leadTransition);
  }
  stopCrossfadeAnimation() {
    this.stackCrossfaders.forEach((crossfader) => crossfader.stop());
  }
  render() {
    return /* @__PURE__ */ createElement28(LayoutTreeContext.Provider, {
      value: this.treeContext
    }, /* @__PURE__ */ createElement28(SharedLayoutContext.Provider, {
      value: this.syncContext
    }, this.props.children));
  }
};
function copyAxisBox2(box) {
  if (!box)
    return void 0;
  return {
    x: { ...box.x },
    y: { ...box.y }
  };
}
function snapshotRotate(layoutId, lead, follow, styleMap) {
  const followRotate = follow == null ? void 0 : follow.getValue("rotate");
  const leadRotate = lead.getValue("rotate");
  styleMap[layoutId] = { rotate: (leadRotate == null ? void 0 : leadRotate.isAnimating()) ? leadRotate.get() : (followRotate == null ? void 0 : followRotate.get()) || 0 };
}
var transformAxes2 = ["", "X", "Y", "Z"];
function resetRotate2(child) {
  let hasRotate = false;
  const resetValues = {};
  transformAxes2.forEach((axis) => {
    const key6 = "rotate" + axis;
    if (!child.hasValue(key6))
      return;
    hasRotate = true;
    resetValues[key6] = child.getStaticValue(key6);
    child.setStaticValue(key6, 0);
  });
  if (!hasRotate)
    return;
  child.syncRender();
  for (const key6 in resetValues) {
    child.setStaticValue(key6, resetValues[key6]);
  }
  child.scheduleRender();
}

// src/components/AnimateLayout/SharedLayoutTree.tsx
import {
  Component as Component11,
  createElement as createElement29,
  useContext as useContext23
} from "react";
var LayoutTree = class extends Component11 {
  constructor() {
    super(...arguments);
    this.children = new Map();
    this.childrenToResetTransform = new Set();
    this.layoutMayBeMutated = false;
    this.syncContext = {
      add: () => {
      },
      flush: () => {
      },
      syncUpdate: (force) => {
      },
      forceUpdate: () => {
        this.syncContext = { ...this.syncContext };
        this.forceUpdate();
      },
      register: (child) => this.addChild(child),
      remove: (child) => this.removeChild(child)
    };
  }
  addChild(child) {
    const layoutId = child.getLayoutId();
    if (layoutId) {
      this.children.set(layoutId, child);
      this.setRootChild(child);
    } else if (child.shouldResetTransform()) {
      this.childrenToResetTransform.add(child);
    }
  }
  setRootChild(child) {
    if (!this.rootChild)
      return this.rootChild = child;
    this.rootChild = this.rootChild.depth < child.depth ? this.rootChild : child;
  }
  removeChild(child) {
    const layoutId = child.getLayoutId();
    if (layoutId) {
      this.children.delete(layoutId);
    } else {
      this.childrenToResetTransform.delete(child);
    }
  }
  componentDidMount() {
    const { isLead, animatesLayout, transition } = this.props;
    if (isLead !== void 0 && isLead)
      this.props.treeContext.promoteTree(this, !!animatesLayout, transition);
  }
  shouldComponentUpdate({ isLead, isExiting, animatesLayout, transition }) {
    this.isExiting = isExiting;
    if (this.props.isLead === void 0)
      return true;
    const hasBecomeLead = !this.props.isLead && isLead;
    const hasExitBeenCancelled = this.props.isExiting && !isExiting;
    const shouldPromote = hasBecomeLead || hasExitBeenCancelled;
    if (this.layoutMayBeMutated && shouldPromote && !animatesLayout) {
      return this.props.treeContext.promoteTree(this, true, { type: false }, true);
    } else if (shouldPromote) {
      return this.props.treeContext.promoteTree(this, !!animatesLayout, transition);
    } else if (isExiting && !animatesLayout) {
      this.props.treeContext.markTreeAsSafeToRemove(this);
    }
    return false;
  }
  render() {
    return /* @__PURE__ */ createElement29(FramerTreeLayoutContext.Provider, {
      value: this.syncContext
    }, this.props.children);
  }
};
var SharedLayoutTree = (props) => {
  const treeContext = useContext23(LayoutTreeContext);
  return /* @__PURE__ */ createElement29(LayoutTree, {
    ...props,
    treeContext
  });
};

// src/components/NavigationTargetContext.tsx
import {
  createElement as createElement30
} from "react";
import { createContext as createContext14, useContext as useContext24, useRef as useRef19, useCallback as useCallback8, useEffect as useEffect19 } from "react";

// src/components/utils/useConstant.ts
import { useRef as useRef18 } from "react";
function useConstant2(init) {
  const ref = useRef18(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}

// src/components/utils/useMap.ts
function newMap() {
  return new Map();
}
function useMap() {
  return useConstant2(newMap);
}

// src/components/NavigationTargetContext.tsx
var NavigationTargetContext = createContext14({ register: () => {
}, deregister: () => {
} });
var NavigationTargetWrapper = ({ isCurrent, isOverlayed, children }) => {
  const callbacks2 = useMap();
  const register = useCallback8((fn) => {
    if (callbacks2.has(fn)) {
      console.warn("NavigationTargetWrapper: already registered");
      return;
    }
    callbacks2.set(fn, void 0);
  }, [callbacks2]);
  const deregister = useCallback8((fn) => {
    const cleanup = callbacks2.get(fn);
    cleanup == null ? void 0 : cleanup();
    callbacks2.delete(fn);
  }, [callbacks2]);
  const value = useRef19({ register, deregister }).current;
  useEffect19(() => {
    callbacks2.forEach((_, cb2) => {
      const newCleanup = cb2(isCurrent, isOverlayed);
      callbacks2.set(cb2, isFunction(newCleanup) ? newCleanup : void 0);
    });
    return () => {
      callbacks2.forEach((cleanup, cb2) => {
        if (!cleanup)
          return;
        cleanup();
        callbacks2.set(cb2, void 0);
      });
    };
  }, [isCurrent, isOverlayed, callbacks2]);
  return /* @__PURE__ */ createElement30(NavigationTargetContext.Provider, {
    value
  }, children);
};
function useOnCurrentTargetChange(callback, deps = []) {
  const { register, deregister } = useContext24(NavigationTargetContext);
  useEffect19(() => {
    if (!callback)
      return;
    register(callback);
    return () => deregister(callback);
  }, [register, deregister, ...deps]);
}

// src/components/NavigationContainer.tsx
var NavigationContainer = memo(function NavigationContainer2({
  isLayeredContainer,
  isCurrent,
  isPrevious,
  isOverlayed = false,
  visible,
  transitionProps,
  children,
  backdropColor,
  onTapBackdrop,
  backfaceVisible,
  exitBackfaceVisible,
  animation,
  exitAnimation,
  instant,
  initialProps,
  exitProps,
  position = { top: 0, right: 0, bottom: 0, left: 0 },
  withMagicMotion,
  index,
  areMagicMotionLayersPresent,
  id
}) {
  const animate4 = useAnimation();
  const presence = useContext25(PresenceContext);
  const { persistLayoutIdCache } = useContext25(LayoutIdContext);
  const previousState = useRef20({
    wasCurrent: void 0,
    wasPrevious: false,
    wasBeingRemoved: false,
    wasReset: true,
    origins: getOriginProps({}, initialProps, transitionProps)
  });
  const isBeingRemoved = presence !== null && !presence.isPresent;
  if (isCurrent && previousState.current.wasCurrent === void 0)
    persistLayoutIdCache();
  useEffect20(() => {
    if (isLayeredContainer || !animate4)
      return;
    if (isBeingRemoved) {
      previousState.current = {
        ...previousState.current,
        wasBeingRemoved: isBeingRemoved
      };
      return;
    }
    const { wasPrevious, wasCurrent } = previousState.current;
    const shouldAnimateIn = isCurrent && !wasCurrent || !isBeingRemoved && previousState.current.wasBeingRemoved && isCurrent;
    const shouldAnimateOut = isPrevious && !wasPrevious;
    const origins = getOriginProps(previousState.current.origins, initialProps, transitionProps);
    let wasReset = previousState.current.wasReset;
    if (shouldAnimateIn || shouldAnimateOut) {
      animate4.stop();
      animate4.start({
        zIndex: index,
        ...origins,
        ...transitionProps
      });
      wasReset = false;
    } else if (wasReset === false) {
      animate4.stop();
      animate4.set({ zIndex: index, ...allAnimatableProperties, opacity: 0 });
      wasReset = true;
    }
    previousState.current = {
      wasCurrent: !!isCurrent,
      wasPrevious: !!isPrevious,
      wasBeingRemoved: false,
      wasReset,
      origins
    };
  }, [isCurrent, isPrevious, isBeingRemoved]);
  const transition = instant ? { type: false } : { ...animation, velocity: 0 };
  const exitTransition = instant ? { type: false } : exitAnimation || animation;
  const layout = { ...position };
  if (layout.left === void 0 || layout.right === void 0)
    layout.width = "auto";
  if (layout.top === void 0 || layout.bottom === void 0)
    layout.height = "auto";
  const needsPerspective = contains3Dprops(transitionProps) || contains3Dprops(initialProps);
  const perspective = needsPerspective && (isLayeredContainer || isCurrent || isPrevious) ? 1200 : void 0;
  const identity = { ...allAnimatableProperties, ...previousState.current.origins };
  const animations2 = isLayeredContainer ? {
    initial: { ...identity, ...initialProps },
    animate: { ...identity, ...transitionProps, transition },
    exit: { ...identity, ...exitProps, transition: animate4 }
  } : {
    animate: animate4,
    exit: { ...identity, ...exitProps, transition: exitTransition }
  };
  const isPresent2 = isBeingRemoved || areMagicMotionLayersPresent === false ? false : true;
  const isCurrentTarget = !!isCurrent && isPresent2;
  return /* @__PURE__ */ createElement31(FrameWithMotion, {
    width: "100%",
    height: "100%",
    style: {
      position: "absolute",
      transformStyle: "flat",
      backgroundColor: "transparent",
      overflow: "hidden",
      zIndex: isLayeredContainer || isBeingRemoved || isCurrent && withMagicMotion ? index : void 0,
      pointerEvents: "none",
      visibility: visible ? "visible" : "hidden",
      perspective
    }
  }, isLayeredContainer && /* @__PURE__ */ createElement31(FrameWithMotion, {
    width: "100%",
    height: "100%",
    transition: animation,
    initial: { opacity: instant && visible ? 1 : 0 },
    animate: { opacity: 1 },
    exit: { opacity: 0 },
    backgroundColor: backdropColor ? backdropColor : "transparent",
    onTap: !isBeingRemoved ? onTapBackdrop : void 0
  }), /* @__PURE__ */ createElement31(FrameWithMotion, {
    ...layout,
    ...animations2,
    transition: {
      default: transition,
      originX: { type: false },
      originY: { type: false },
      originZ: { type: false }
    },
    backgroundColor: "transparent",
    backfaceVisible: !isBeingRemoved ? backfaceVisible : exitBackfaceVisible,
    "data-framer-component-type": "NavigationContainer",
    "data-framer-is-current-navigation-target": !!isCurrent,
    style: {
      pointerEvents: "initial",
      opacity: isLayeredContainer || isCurrent && withMagicMotion ? 1 : 0
    },
    "data-is-present": isPresent2 ? void 0 : false
  }, /* @__PURE__ */ createElement31(NavigationContainerContext.Provider, {
    value: isCurrentTarget
  }, /* @__PURE__ */ createElement31(NavigationTargetWrapper, {
    isCurrent: isCurrentTarget,
    isOverlayed
  }, /* @__PURE__ */ createElement31(SharedLayoutTree, {
    isLead: isCurrent,
    animatesLayout: !!withMagicMotion,
    transition,
    isExiting: !isPresent2,
    id
  }, children)))));
}, shouldUsePreviousValue);
function shouldUsePreviousValue(prevProps, nextProps) {
  if (nextProps.isCurrent === void 0)
    return false;
  if (prevProps.isCurrent !== nextProps.isCurrent)
    return false;
  if (prevProps.isPrevious !== nextProps.isPrevious)
    return false;
  if (nextProps.isCurrent && prevProps.isOverlayed !== nextProps.isOverlayed)
    return false;
  return true;
}
function getOriginProps(currentOriginProps, initialProps, transitionProps) {
  const result = { ...currentOriginProps };
  if (initialProps) {
    if (isFiniteNumber(initialProps.originX))
      result.originX = initialProps.originX;
    if (isFiniteNumber(initialProps.originY))
      result.originY = initialProps.originY;
    if (isFiniteNumber(initialProps.originZ))
      result.originZ = initialProps.originZ;
  }
  if (transitionProps) {
    if (isFiniteNumber(transitionProps.originX))
      result.originX = transitionProps.originX;
    if (isFiniteNumber(transitionProps.originY))
      result.originY = transitionProps.originY;
    if (isFiniteNumber(transitionProps.originZ))
      result.originZ = transitionProps.originZ;
  }
  return result;
}
function contains3Dprops(containerProps) {
  var _a, _b, _c;
  if (!containerProps)
    return false;
  const containsProps = "rotateX" in containerProps || "rotateY" in containerProps || "z" in containerProps;
  if (!containsProps)
    return false;
  const toPropsContain3d = containerProps.rotateX !== 0 || containerProps.rotateY !== 0 || containerProps.z !== 0;
  const fromPropsContain3d = ((_a = containerProps == null ? void 0 : containerProps.transition) == null ? void 0 : _a.rotateX.from) !== 0 || ((_b = containerProps == null ? void 0 : containerProps.transition) == null ? void 0 : _b.rotateY.from) !== 0 || ((_c = containerProps == null ? void 0 : containerProps.transition) == null ? void 0 : _c.z.from) !== 0;
  return toPropsContain3d || fromPropsContain3d;
}
var allAnimatableProperties = {
  x: 0,
  y: 0,
  z: 0,
  rotate: 0,
  rotateX: 0,
  rotateY: 0,
  rotateZ: 0,
  scale: 1,
  scaleX: 1,
  scaleY: 1,
  scaleZ: 1,
  skew: 0,
  skewX: 0,
  skewY: 0,
  originX: 0.5,
  originY: 0.5,
  originZ: 0,
  opacity: 1
};

// src/components/NavigatorMock.tsx
var NavigatorMock = class {
  constructor() {
    this.warning = () => {
      warnOnce("The Navigator API is only available inside of Framer: https://www.framer.com/");
    };
    this.goBack = () => this.warning();
    this.instant = () => this.warning();
    this.fade = () => this.warning();
    this.push = () => this.warning();
    this.modal = () => this.warning();
    this.overlay = () => this.warning();
    this.flip = () => this.warning();
    this.customTransition = () => this.warning();
    this.magicMotion = () => this.warning();
  }
};
var navigatorMock = new NavigatorMock();

// src/components/reduceNavigationStateForAction.ts
var defaultState = () => ({
  current: -1,
  previous: -1,
  currentOverlay: -1,
  previousOverlay: -1,
  visualIndex: 0,
  overlayItemId: 0,
  historyItemId: 0,
  history: [],
  overlayStack: [],
  containers: {},
  containerIndex: {},
  containerVisualIndex: {},
  containerIsRemoved: {},
  transitionForContainer: {},
  previousTransition: null
});
function reduceNavigationStateForAction(state, action) {
  switch (action.type) {
    case "addOverlay":
      return addOverlay(state, action.transition, action.component);
    case "removeOverlay":
      return removeOverlay(state);
    case "add":
      return add(state, action.key, action.transition, action.component);
    case "remove":
      return remove(state);
    case "update":
      return updateComponent(state, action.key, action.component);
    default:
      return;
  }
}
function updateComponent(currentState, key6, component) {
  return {
    ...currentState,
    containers: {
      ...currentState.containers,
      [key6]: component
    }
  };
}
function addOverlay(currentState, transition, component) {
  const currentOverlay = currentState.overlayStack[currentState.currentOverlay];
  if (currentOverlay && currentOverlay.component === component)
    return;
  const overlayItemId = currentState.overlayItemId + 1;
  const overlayStack = [
    ...currentState.overlayStack,
    {
      key: `stack-${overlayItemId}`,
      component,
      transition
    }
  ];
  return {
    ...currentState,
    overlayStack,
    overlayItemId,
    currentOverlay: Math.max(0, Math.min(currentState.currentOverlay + 1, overlayStack.length - 1)),
    previousOverlay: currentState.currentOverlay
  };
}
function removeOverlay(currentState) {
  return {
    ...currentState,
    overlayStack: [],
    currentOverlay: -1,
    previousOverlay: currentState.currentOverlay
  };
}
function add(currentState, key6, transition, component) {
  if (!currentState.containers[key6])
    currentState.containers[key6] = component;
  currentState.history = currentState.history.slice(0, currentState.current + 1);
  currentState.visualIndex = Math.max(currentState.history.length, 0);
  const currentItem = currentState.history[currentState.history.length - 1];
  const isCurrentScreen = currentItem && currentItem.key === key6;
  currentState.overlayStack = [];
  if (isCurrentScreen && currentState.currentOverlay > -1) {
    return {
      ...currentState,
      currentOverlay: -1,
      previousOverlay: currentState.currentOverlay
    };
  }
  if (isCurrentScreen)
    return;
  const shouldMoveForward = (currentItem == null ? void 0 : currentItem.key) && transition.withMagicMotion ? isNextTargetForward(key6, currentState.containerVisualIndex[key6], currentState.containerIsRemoved[key6], currentState.history) : true;
  currentState.history.push({
    key: key6,
    transition,
    visualIndex: shouldMoveForward ? Math.max(currentState.visualIndex, 0) : currentState.containerVisualIndex[key6]
  });
  const current = currentState.current + 1;
  const previous = currentState.current;
  for (const containerKey in currentState.containerIndex) {
    if (currentState.containerIndex[containerKey] === current) {
      currentState.containerIndex[containerKey] = findLatestHistoryIndex(containerKey, currentState.history);
    }
  }
  currentState.containerIndex[key6] = current;
  const { containerVisualIndex, containerIsRemoved } = magicMotionPropsForAdd(currentState, key6, currentItem == null ? void 0 : currentItem.key, shouldMoveForward);
  const transitionForContainer = updateTransitions(current, previous, currentState.history, currentState.containerIndex, currentState.transitionForContainer);
  return {
    ...currentState,
    current,
    previous,
    containerVisualIndex,
    containerIsRemoved,
    transitionForContainer,
    previousTransition: null,
    currentOverlay: -1,
    historyItemId: currentState.historyItemId + 1,
    previousOverlay: currentState.currentOverlay
  };
}
function remove(currentState) {
  const history = [...currentState.history.slice(0, currentState.current + 1)];
  if (history.length === 1)
    return;
  const currentItem = history.pop();
  if (!currentItem)
    return;
  const target = history[history.length - 1];
  currentState.containerIndex[target.key] = history.length - 1;
  const shouldRemoveContainer = history.every((item) => item.key !== currentItem.key);
  if (shouldRemoveContainer) {
    delete currentState.containers[currentItem.key];
  }
  const current = currentState.current - 1;
  const previous = currentState.current;
  const { containerIsRemoved, containerVisualIndex, previousTransition, visualIndex } = magicMotionPropsForRemove(currentState, target, currentItem);
  const transitionForContainer = updateTransitions(current, previous, currentState.history, currentState.containerIndex, currentState.transitionForContainer);
  return {
    ...currentState,
    current,
    previous,
    containerIsRemoved,
    containerVisualIndex,
    previousTransition,
    visualIndex,
    transitionForContainer
  };
}
function magicMotionPropsForAdd(currentState, nextKey, currentKey, shouldMoveForward) {
  const update = {
    containerVisualIndex: { ...currentState.containerVisualIndex },
    containerIsRemoved: { ...currentState.containerIsRemoved }
  };
  if (shouldMoveForward) {
    update.containerVisualIndex[nextKey] = currentState.history.length - 1;
    update.containerIsRemoved[nextKey] = false;
  } else {
    const nextVisualIndex = currentState.containerVisualIndex[nextKey];
    for (const key6 in currentState.containerVisualIndex) {
      if (currentState.containerVisualIndex[key6] > nextVisualIndex) {
        update.containerIsRemoved[key6] = true;
      }
    }
  }
  return update;
}
function magicMotionPropsForRemove(currentState, target, currentItem) {
  const { history } = globalThis;
  const validTargets = [target.key, currentItem.key];
  const nextValidTarget = history[history.length - 2];
  const previousTransition = currentState.previousTransition === null ? null : { ...currentState.previousTransition };
  const update = {
    containerIsRemoved: { ...currentState.containerIsRemoved },
    containerVisualIndex: { ...currentState.containerVisualIndex },
    previousTransition,
    visualIndex: currentState.visualIndex
  };
  if (nextValidTarget)
    validTargets.push(nextValidTarget.key);
  const shouldRemoveLastKey = currentState.containerVisualIndex[target.key] <= currentState.containerVisualIndex[currentItem.key] || target.visualIndex !== void 0 && target.visualIndex < history.length - 1;
  const nextIndex = target.visualIndex;
  if (shouldRemoveLastKey) {
    update.containerIsRemoved[currentItem.key] = true;
    update.containerVisualIndex[target.key] = nextIndex !== void 0 ? nextIndex : history.length - 1;
  } else {
    update.visualIndex = currentState.visualIndex + 1;
    update.containerVisualIndex[target.key] = currentState.visualIndex + 1;
  }
  if (currentItem.transition.withMagicMotion)
    update.previousTransition = currentItem.transition || null;
  currentState.containerIsRemoved[target.key] = false;
  return update;
}
function findLatestHistoryIndex(key6, history) {
  for (let index = history.length; index > history.length; index--) {
    if (history[index].key === key6)
      return index;
  }
  return -1;
}
function updateTransitions(current, previous, history, containerIndex, transitionForContainer) {
  const transitions = { ...transitionForContainer };
  Object.keys(containerIndex).forEach((key6) => {
    const transition = transitionForScreen(containerIndex[key6], { current, previous, history });
    if (transition) {
      transitions[key6] = transition;
    }
  });
  return transitions;
}
function isNextTargetForward(key6, index, removed, history) {
  if (removed)
    return true;
  if (index === 0)
    return false;
  const forwardHistory = history.slice(index, history.length);
  if (forwardHistory.findIndex((item) => item.key === key6) > -1)
    return true;
  const backwardsHistory = history.slice(0, index - 1);
  if (backwardsHistory.findIndex((item) => item.key === key6) > -1)
    return false;
  return true;
}
function transitionForScreen(screenIndex, stackState) {
  const { current, previous, history } = stackState;
  if (screenIndex !== current && screenIndex !== previous)
    return void 0;
  if (screenIndex === current && current > previous) {
    const item = history[screenIndex];
    return sequence("enter", item.transition.enter, item.transition.animation);
  }
  if (screenIndex === previous && current > previous) {
    const item = history[screenIndex + 1];
    return sequence("exit", item.transition.exit, item.transition.animation);
  }
  if (screenIndex === current && current < previous) {
    const item = history[screenIndex + 1];
    return sequence("enter", item.transition.exit, item.transition.animation);
  }
  if (screenIndex === previous && current < previous) {
    const item = history[screenIndex];
    return sequence("exit", item.transition.enter, item.transition.animation);
  }
}
var allAnimatableKeys = Object.keys(allAnimatableProperties);
function sequence(direction, transition, animation) {
  const value = {};
  const from = {};
  allAnimatableKeys.forEach((property) => {
    value[property] = allAnimatableProperties[property];
    from[property] = {
      ...animation,
      from: allAnimatableProperties[property]
    };
  });
  if (transition) {
    Object.keys(transition).forEach((property) => {
      if (transition[property] === void 0)
        return;
      const transitionTo = transition[property];
      const transitionFrom = typeof transition[property] === "string" ? `${allAnimatableProperties[property]}%` : allAnimatableProperties[property];
      value[property] = direction === "enter" ? transitionFrom : transitionTo;
      from[property] = {
        ...animation,
        from: direction === "enter" ? transitionTo : transitionFrom,
        velocity: 0
      };
    });
  }
  return {
    ...value,
    transition: {
      ...from
    }
  };
}

// src/components/Navigation.tsx
var NavigationContext = createContext15(navigatorMock);
var NavigationConsumer = NavigationContext.Consumer;
var NavigationCallbackContext = createContext15(void 0);
var NavigationCallbackProvider = NavigationCallbackContext.Provider;
var Navigation = class extends Component12 {
  constructor() {
    super(...arguments);
    this.lastEventTimeStamp = null;
    this.state = defaultState();
    this.navigationAction = (action) => {
      var _a;
      if (!this.props.enabled && this.state.history.length > 0)
        return;
      const newState = reduceNavigationStateForAction(this.state, action);
      if (newState) {
        this.setState(newState);
        const currentItem = newState.history[newState.current];
        (_a = this.context) == null ? void 0 : _a.call(this, currentItem.key);
      }
    };
    this.goBack = () => {
      var _a;
      if (this.isSameEventTransition())
        return;
      this.lastEventTimeStamp = ((_a = globalThis.event) == null ? void 0 : _a.timeStamp) || null;
      if (this.state.currentOverlay !== -1)
        return this.navigationAction({ type: "removeOverlay" });
      return this.navigationAction({ type: "remove" });
    };
  }
  componentDidMount() {
    if (this.state.history.length === 0) {
      this.transition(this.props.children, TransitionDefaults.Instant);
    }
    injectComponentCSSRules();
  }
  UNSAFE_componentWillReceiveProps(props) {
    var _a;
    const component = props["children"];
    if (!isReactChild(component) || !isReactElement(component))
      return;
    const key6 = (_a = component.key) == null ? void 0 : _a.toString();
    if (!key6)
      return;
    if (this.state.history.length === 0) {
      this.transition(component, TransitionDefaults.Instant);
    } else {
      this.navigationAction({ type: "update", key: key6, component });
    }
  }
  getStackState(options) {
    const { current, previous, currentOverlay, previousOverlay } = this.state;
    if (options.overCurrentContext) {
      return {
        current: currentOverlay,
        previous: previousOverlay,
        history: this.state.overlayStack
      };
    }
    return {
      current,
      previous,
      history: this.state.history
    };
  }
  isSameEventTransition() {
    if (!globalThis.event)
      return false;
    return this.lastEventTimeStamp === globalThis.event.timeStamp;
  }
  transition(component, transitionTraits, transitionOptions) {
    var _a, _b;
    if (this.isSameEventTransition())
      return;
    this.lastEventTimeStamp = ((_a = globalThis.event) == null ? void 0 : _a.timeStamp) || null;
    if (!component || !isReactChild(component) || !isReactElement(component))
      return;
    const transition = { ...transitionTraits, ...transitionOptions };
    const overCurrentContext = !!transition.overCurrentContext;
    if (overCurrentContext)
      return this.navigationAction({ type: "addOverlay", transition, component });
    const key6 = ((_b = component == null ? void 0 : component.key) == null ? void 0 : _b.toString()) || `stack-${this.state.historyItemId + 1}`;
    this.navigationAction({ type: "add", key: key6, transition, component });
  }
  instant(component) {
    this.transition(component, TransitionDefaults.Instant);
  }
  fade(component, options) {
    this.transition(component, TransitionDefaults.Fade, options);
  }
  push(component, options) {
    this.transition(component, pushTransition(options), options);
  }
  modal(component, options) {
    this.transition(component, TransitionDefaults.Modal, options);
  }
  overlay(component, options) {
    this.transition(component, overlayTransition(options), options);
  }
  flip(component, options) {
    this.transition(component, flipTransition(options), options);
  }
  magicMotion(component, options) {
    this.transition(component, TransitionDefaults.MagicMotion, options);
  }
  customTransition(component, transition) {
    this.transition(component, transition);
  }
  render() {
    const stackState = this.getStackState({ overCurrentContext: false });
    const overlayStackState = this.getStackState({ overCurrentContext: true });
    const activeOverlay = activeOverlayItem(overlayStackState);
    const isOverlayVisible = overlayStackState.current > -1;
    return /* @__PURE__ */ createElement32(FrameWithMotion, {
      top: 0,
      left: 0,
      width: "100%",
      height: "100%",
      position: "relative",
      style: { overflow: "hidden", backgroundColor: "unset", ...this.props.style }
    }, /* @__PURE__ */ createElement32(NavigationContext.Provider, {
      value: this
    }, /* @__PURE__ */ createElement32(NavigationContainer, {
      isLayeredContainer: true,
      position: void 0,
      initialProps: {},
      instant: false,
      transitionProps: transitionPropsForStackWrapper(activeOverlay),
      animation: animationForStackWrapper(activeOverlay),
      backfaceVisible: backfaceVisibleForStackWrapper(activeOverlay),
      visible: true,
      backdropColor: void 0,
      onTapBackdrop: void 0,
      index: 0
    }, /* @__PURE__ */ createElement32(LayoutIdProvider, null, /* @__PURE__ */ createElement32(AnimateLayoutTrees, null, /* @__PURE__ */ createElement32(AnimatePresence, {
      presenceAffectsLayout: false
    }, Object.keys(this.state.containers).map((key6) => {
      var _a, _b, _c, _d, _e;
      const component = this.state.containers[key6];
      const index = this.state.containerIndex[key6];
      const visualIndex = this.state.containerVisualIndex[key6];
      const removed = this.state.containerIsRemoved[key6];
      const historyItem = this.state.history[index];
      const transitionProps = this.state.transitionForContainer[key6];
      const isCurrent = index === this.state.current;
      const isPrevious = index === this.state.previous;
      const areMagicMotionLayersPresent = isCurrent ? false : removed;
      const withMagicMotion = ((_a = historyItem == null ? void 0 : historyItem.transition) == null ? void 0 : _a.withMagicMotion) || isCurrent && !!this.state.previousTransition;
      return /* @__PURE__ */ createElement32(NavigationContainer, {
        key: key6,
        id: key6,
        index: visualIndex,
        isCurrent,
        isPrevious,
        isOverlayed: isOverlayVisible,
        visible: isCurrent || isPrevious,
        position: (_b = historyItem == null ? void 0 : historyItem.transition) == null ? void 0 : _b.position,
        instant: isInstantContainerTransition(index, stackState),
        transitionProps,
        animation: animationPropsForContainer(index, stackState),
        backfaceVisible: getBackfaceVisibleForScreen(index, stackState),
        exitAnimation: (_c = historyItem == null ? void 0 : historyItem.transition) == null ? void 0 : _c.animation,
        exitBackfaceVisible: (_d = historyItem == null ? void 0 : historyItem.transition) == null ? void 0 : _d.backfaceVisible,
        exitProps: (_e = historyItem == null ? void 0 : historyItem.transition) == null ? void 0 : _e.enter,
        withMagicMotion,
        areMagicMotionLayersPresent: areMagicMotionLayersPresent ? false : void 0
      }, /* @__PURE__ */ createElement32(Suspense, {
        fallback: "Loading..."
      }, containerContent({
        component,
        transition: historyItem == null ? void 0 : historyItem.transition
      })));
    }))))), /* @__PURE__ */ createElement32(AnimatePresence, null, this.state.overlayStack.map((item, stackIndex) => {
      return /* @__PURE__ */ createElement32(NavigationContainer, {
        isLayeredContainer: true,
        key: item.key,
        isCurrent: stackIndex === this.state.currentOverlay,
        position: item.transition.position,
        initialProps: initialPropsForOverlay(stackIndex, overlayStackState),
        transitionProps: transitionPropsForOverlay(stackIndex, overlayStackState),
        instant: isInstantContainerTransition(stackIndex, overlayStackState, true),
        animation: animationPropsForContainer(stackIndex, overlayStackState),
        exitProps: item.transition.enter,
        visible: containerIsVisible(stackIndex, overlayStackState),
        backdropColor: backdropColorForTransition(item.transition),
        backfaceVisible: getBackfaceVisibleForOverlay(stackIndex, overlayStackState),
        onTapBackdrop: backdropTapAction(item.transition, this.goBack),
        index: this.state.current + 1 + stackIndex
      }, containerContent({ component: item.component, transition: item.transition }));
    }))));
  }
};
Navigation.defaultProps = {
  enabled: true
};
Navigation.contextType = NavigationCallbackContext;
var animationDefault = {
  stiffness: 500,
  damping: 50,
  restDelta: 1,
  type: "spring"
};
function activeOverlayItem(overlayStack) {
  let currentOverlayItem;
  let previousOverlayItem;
  if (overlayStack.current !== -1) {
    currentOverlayItem = overlayStack.history[overlayStack.current];
  } else {
    previousOverlayItem = overlayStack.history[overlayStack.previous];
  }
  return { currentOverlayItem, previousOverlayItem };
}
function transitionPropsForStackWrapper({ currentOverlayItem }) {
  return currentOverlayItem && currentOverlayItem.transition.exit;
}
function animationForStackWrapper({ currentOverlayItem, previousOverlayItem }) {
  if (currentOverlayItem && currentOverlayItem.transition.animation) {
    return currentOverlayItem.transition.animation;
  }
  if (previousOverlayItem && previousOverlayItem.transition.animation) {
    return previousOverlayItem.transition.animation;
  }
  return animationDefault;
}
function backfaceVisibleForStackWrapper({ currentOverlayItem, previousOverlayItem }) {
  if (currentOverlayItem)
    return currentOverlayItem.transition.backfaceVisible;
  return previousOverlayItem && previousOverlayItem.transition.backfaceVisible;
}
function backdropColorForTransition(transition) {
  if (transition.backdropColor)
    return transition.backdropColor;
  if (transition.overCurrentContext)
    return "rgba(4,4,15,.4)";
  return void 0;
}
function getBackfaceVisibleForOverlay(containerIndex, stackState) {
  const { current, history } = stackState;
  if (containerIndex === current) {
    const navigationItem = history[containerIndex];
    if (navigationItem && navigationItem.transition) {
      return navigationItem.transition.backfaceVisible;
    }
    return true;
  } else if (containerIndex < current) {
    const navigationItem = history[containerIndex + 1];
    if (navigationItem && navigationItem.transition) {
      return navigationItem.transition.backfaceVisible;
    }
    return true;
  } else {
    const navigationItem = history[containerIndex];
    if (navigationItem && navigationItem.transition) {
      return navigationItem.transition.backfaceVisible;
    }
    return true;
  }
}
function initialPropsForOverlay(containerIndex, stackState) {
  const navigationItem = stackState.history[containerIndex];
  if (navigationItem)
    return navigationItem.transition.enter;
}
function getBackfaceVisibleForScreen(screenIndex, stackState) {
  var _a, _b, _c, _d;
  const { current, previous, history } = stackState;
  if (screenIndex === previous && current > previous || screenIndex === current && current < previous) {
    return (_b = (_a = history[screenIndex + 1]) == null ? void 0 : _a.transition) == null ? void 0 : _b.backfaceVisible;
  }
  return (_d = (_c = history[screenIndex]) == null ? void 0 : _c.transition) == null ? void 0 : _d.backfaceVisible;
}
function transitionPropsForOverlay(overlayIndex, stackState) {
  const { current, history } = stackState;
  if (overlayIndex === current) {
    return;
  } else if (overlayIndex < current) {
    const navigationItem = history[overlayIndex + 1];
    if (navigationItem && navigationItem.transition) {
      return navigationItem.transition.exit;
    }
  } else {
    const navigationItem = history[overlayIndex];
    if (navigationItem && navigationItem.transition) {
      return navigationItem.transition.enter;
    }
  }
}
function animationPropsForContainer(containerIndex, stackState) {
  const { current, previous, history } = stackState;
  const containerCurrent = previous > current ? previous : current;
  if (containerIndex < containerCurrent) {
    const navigationItem = history[containerIndex + 1];
    if (navigationItem && navigationItem.transition.animation) {
      return navigationItem.transition.animation;
    }
  } else if (containerIndex !== containerCurrent) {
    const navigationItem = history[containerIndex];
    if (navigationItem && navigationItem.transition.animation) {
      return navigationItem.transition.animation;
    }
  } else {
    const navigationItem = history[containerIndex];
    if (navigationItem.transition.animation) {
      return navigationItem.transition.animation;
    }
  }
  return animationDefault;
}
function isInstantContainerTransition(containerIndex, stackState, overCurrentContext) {
  const { current, previous, history } = stackState;
  if (overCurrentContext && history.length > 1)
    return true;
  if (containerIndex !== previous && containerIndex !== current)
    return true;
  if (current === previous)
    return true;
  return false;
}
function containerIsVisible(containerIndex, stackState) {
  const { current, previous } = stackState;
  if (containerIndex > current && containerIndex > previous)
    return false;
  if (containerIndex === current)
    return true;
  return false;
}
function containerContent(item) {
  return Children8.map(item.component, (child) => {
    var _a;
    if (!isReactChild(child) || !isReactElement(child) || !child.props) {
      return child;
    }
    const props = {
      style: child.props.style
    };
    const position = (_a = item == null ? void 0 : item.transition) == null ? void 0 : _a.position;
    const shouldStretchWidth = !position || position.left !== void 0 && position.right !== void 0;
    const shouldStretchHeight = !position || position.top !== void 0 && position.bottom !== void 0;
    const canStretchStyle = "style" in child.props;
    if (shouldStretchWidth) {
      const canStretchWidth = "width" in child.props;
      if (canStretchWidth)
        props.width = "100%";
      if (canStretchStyle && !canStretchWidth)
        props.style.width = "100%";
    }
    if (shouldStretchHeight) {
      const canStretchHeight = "height" in child.props;
      if (canStretchHeight)
        props.height = "100%";
      if (canStretchStyle && !canStretchHeight)
        props.style.height = "100%";
    }
    return cloneElement6(child, props);
  });
}
function backdropTapAction(transition, goBackAction) {
  if (transition.goBackOnTapOutside !== false)
    return goBackAction;
}

// src/components/Page/EmulatedPage.tsx
import {
  Children as Children10,
  cloneElement as cloneElement8,
  createElement as createElement35,
  forwardRef as forwardRef8,
  useCallback as useCallback9,
  useEffect as useEffect21,
  useLayoutEffect as useLayoutEffect8,
  useRef as useRef21,
  useState as useState8
} from "react";

// src/components/Page/PageContainer.tsx
import {
  createElement as createElement34
} from "react";

// src/components/Stack/Stack.tsx
import {
  Children as Children9,
  cloneElement as cloneElement7,
  createElement as createElement33,
  forwardRef as forwardRef7,
  memo as memo2
} from "react";

// src/components/utils/paddingFromProps.ts
function hasPaddingPerSide(props) {
  const { paddingPerSide, paddingTop, paddingBottom, paddingLeft, paddingRight } = props;
  return paddingPerSide !== false && (paddingTop !== void 0 || paddingBottom !== void 0 || paddingLeft !== void 0 || paddingRight !== void 0);
}
function paddingFromProps(props) {
  const { padding = 0, paddingTop, paddingBottom, paddingLeft, paddingRight } = props;
  if (hasPaddingPerSide(props)) {
    return {
      top: paddingTop !== void 0 ? paddingTop : padding,
      bottom: paddingBottom !== void 0 ? paddingBottom : padding,
      left: paddingLeft !== void 0 ? paddingLeft : padding,
      right: paddingRight !== void 0 ? paddingRight : padding
    };
  }
  return {
    top: padding,
    bottom: padding,
    left: padding,
    right: padding
  };
}
function makePaddingString({
  top,
  left,
  bottom,
  right
}) {
  return `${top}px ${right}px ${bottom}px ${left}px`;
}

// src/components/Stack/Stack.tsx
var Stack = memo2(forwardRef7(function Stack2(stackProps, ref) {
  var _a, _b;
  const {
    direction = "vertical",
    distribution = "start",
    alignment = "center",
    gap = 10,
    children,
    style: styleProp,
    className,
    willChangeTransform,
    __fromCodeComponentNode,
    parentSize,
    __contentWrapperStyle,
    ...containerProps
  } = stackProps;
  injectComponentCSSRules();
  const flexDirection = toFlexDirection(direction);
  const isReverse = isReverseDirection(flexDirection);
  const justifyContent = toJustifyOrAlignment(distribution);
  const padding = hasPaddingPerSide(containerProps) || containerProps.padding ? makePaddingString(paddingFromProps(containerProps)) : void 0;
  const style = { ...styleProp };
  Layer.applyWillChange({ willChangeTransform }, style, true);
  if (__fromCodeComponentNode && !constraintsEnabled(unwrapFrameProps(containerProps))) {
    containerProps.width = "100%";
    containerProps.height = "100%";
    containerProps._constraints = { enabled: true };
  }
  const layoutId = useLayoutId2(stackProps);
  const { children: _children, props } = processOverrideForwarding(containerProps, children);
  const widthType = (_a = containerProps.widthType) != null ? _a : containerProps.width === "auto" ? DimensionType.Auto : DimensionType.FixedNumber;
  const heightType = (_b = containerProps.heightType) != null ? _b : containerProps.height === "auto" ? DimensionType.Auto : DimensionType.FixedNumber;
  const fractionChildren = handleFraction(_children, direction, widthType, heightType);
  const gapChildren = wrapInGapElement(fractionChildren, gap, flexDirection, justifyContent);
  const content = useProvideParentSize(gapChildren, parentSize != null ? parentSize : ParentSizeState.Disabled);
  const attributes = {
    "data-framer-component-type": "Stack"
  };
  if (containerProps.__fromCanvasComponent)
    attributes["data-framer-generated"] = true;
  const contentWrapperStyle = {
    display: "flex",
    flexDirection,
    justifyContent,
    alignItems: toJustifyOrAlignment(alignment),
    padding,
    ...__contentWrapperStyle
  };
  if (contentWrapperStyle.width === void 0) {
    contentWrapperStyle.width = widthType === DimensionType.Auto ? "min-content" : "100%";
  }
  if (contentWrapperStyle.height === void 0) {
    contentWrapperStyle.height = heightType === DimensionType.Auto ? "min-content" : "100%";
  }
  return /* @__PURE__ */ createElement33(FrameWithMotion, {
    background: "none",
    ...props,
    layoutId,
    ref,
    ...attributes,
    style,
    className
  }, /* @__PURE__ */ createElement33(motion.div, {
    "data-framer-stack-content-wrapper": true,
    "data-framer-stack-direction-reverse": isReverse,
    style: contentWrapperStyle
  }, content));
}));
Stack.displayName = "Stack";
function isFractionDimension(dimension) {
  return typeof dimension === "string" && dimension.endsWith("fr");
}
function fraction(dimension) {
  const value = parseFloat(dimension);
  return isFiniteNumber(value) ? value : 0;
}
function handleFraction(children, direction, widthType, heightType) {
  return Children9.map(children, (child) => {
    if (!isReactChild(child) || !isReactElement(child))
      return;
    const isVertical = direction === "vertical";
    const style = {};
    let hasFraction = false;
    const { style: propsStyle, size: size2 } = child.props;
    let { width, height } = child.props;
    if (size2 !== void 0) {
      if (width === void 0)
        width = size2;
      if (height === void 0)
        height = size2;
    }
    let newWidth = width;
    let newHeight = height;
    if (isFractionDimension(width)) {
      hasFraction = true;
      hasFraction = true;
      if (isVertical) {
        if (widthType === DimensionType.Auto) {
          style.alignSelf = "stretch";
          newWidth = "auto";
        } else {
          newWidth = `${fraction(width) * 100}%`;
        }
      } else {
        newWidth = 1;
        style.flexGrow = fraction(width);
        style.flexBasis = 0;
      }
      style.width = newWidth;
    }
    if (isFractionDimension(height)) {
      hasFraction = true;
      if (isVertical) {
        newHeight = 1;
        style.flexGrow = fraction(height);
        style.flexBasis = 0;
      } else {
        if (heightType === DimensionType.Auto) {
          style.alignSelf = "stretch";
          newHeight = "auto";
        } else {
          newHeight = `${fraction(height) * 100}%`;
        }
      }
      style.height = newHeight;
    }
    if (!hasFraction)
      return child;
    const nextStyle = { ...propsStyle, ...style };
    return cloneElement7(child, {
      width: newWidth,
      height: newHeight,
      style: nextStyle
    });
  });
}
function isGapEnabled(gap, justifyContent) {
  if (!gap) {
    return false;
  }
  if (justifyContent && ["space-between", "space-around", "space-evenly", "stretch"].includes(justifyContent)) {
    return false;
  }
  return true;
}
function wrapInGapElement(children, gap, direction, justifyContent) {
  if (!isGapEnabled(gap, justifyContent)) {
    return children;
  }
  const isVertical = isVerticalDirection(direction);
  const gapStyle = {
    display: "contents",
    ["--stack-gap-x"]: `${isVertical ? 0 : gap}px`,
    ["--stack-gap-y"]: `${isVertical ? gap : 0}px`
  };
  return /* @__PURE__ */ createElement33("div", {
    "data-framer-stack-gap": true,
    style: gapStyle
  }, children);
}
function toFlexDirection(direction) {
  switch (direction) {
    case "vertical":
      return "column";
    case "horizontal":
      return "row";
    default:
      return direction;
  }
}
function isVerticalDirection(direction) {
  return direction === "column" || direction === "column-reverse";
}
function isReverseDirection(direction) {
  switch (direction) {
    case "column-reverse":
    case "row-reverse":
      return true;
    default:
      return false;
  }
}
function toJustifyOrAlignment(distribution) {
  switch (distribution) {
    case "start":
      return "flex-start";
    case "end":
      return "flex-end";
    default:
      return distribution;
  }
}
addPropertyControls(Stack, {
  direction: {
    type: ControlType.SegmentedEnum,
    options: ["horizontal", "vertical"],
    title: "Direction",
    defaultValue: "vertical"
  },
  distribution: {
    type: ControlType.Enum,
    options: ["start", "center", "end", "space-between", "space-around", "space-evenly"],
    optionTitles: ["Start", "Center", "End", "Space Between", "Space Around", "Space Evenly"],
    title: "Distribute",
    defaultValue: "space-around"
  },
  alignment: {
    type: ControlType.SegmentedEnum,
    options: ["start", "center", "end"],
    title: "Align",
    defaultValue: "center"
  },
  gap: {
    type: ControlType.Number,
    min: 0,
    title: "Gap",
    hidden: (props) => {
      return props.distribution !== void 0 && ["space-between", "space-around", "space-evenly"].includes(props.distribution);
    },
    defaultValue: 10
  },
  padding: {
    type: ControlType.FusedNumber,
    toggleKey: "paddingPerSide",
    toggleTitles: ["Padding", "Padding per side"],
    valueKeys: ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
    valueLabels: ["t", "r", "b", "l"],
    min: 0,
    title: "Padding",
    defaultValue: 0
  }
});

// src/components/Page/PageContainer.tsx
var pageContentWrapperType = "PageContentWrapper";
function PageContainer({
  children,
  effect,
  dragEnabled,
  direction,
  contentHeight,
  contentWidth,
  alignment,
  gap,
  isLastPage,
  contentOffsetRef,
  constraintsRef,
  directionLock,
  onDragStart,
  onDrag,
  onDragEnd,
  layoutId
}) {
  const isHorizontalDirection = direction === "horizontal";
  const dragAxis = isHorizontalDirection ? "x" : "y";
  const hasHorizontalGap = isHorizontalDirection && !isLastPage && gap;
  const hasVerticalGap = !isHorizontalDirection && !isLastPage && gap;
  const hasAutoWidth = contentWidth !== "stretch" && isHorizontalDirection;
  const hasAutoHeight = contentHeight !== "stretch" && !isHorizontalDirection;
  const wrapperWidth = hasAutoWidth ? "auto" : "100%";
  const wrapperHeight = hasAutoHeight ? "auto" : "100%";
  const containerWidth = hasHorizontalGap && wrapperWidth === "100%" ? `calc(100% + ${gap}px)` : wrapperWidth;
  const containerHeight = hasVerticalGap && wrapperHeight === "100%" ? `calc(100% + ${gap}px)` : wrapperHeight;
  return /* @__PURE__ */ createElement34(FrameWithMotion, {
    position: "relative",
    "data-framer-component-type": "PageContainer",
    width: containerWidth,
    height: containerHeight,
    layoutId: layoutId ? `${layoutId}-container` : void 0,
    backgroundColor: "transparent",
    drag: dragEnabled ? dragAxis : false,
    dragDirectionLock: directionLock,
    _dragX: contentOffsetRef.current.x,
    _dragY: contentOffsetRef.current.y,
    dragConstraints: constraintsRef.current,
    onDrag,
    onDragStart,
    onDragEnd,
    preserve3d: true,
    style: {
      paddingRight: hasHorizontalGap ? gap : 0,
      paddingBottom: hasVerticalGap ? gap : 0
    }
  }, /* @__PURE__ */ createElement34(FrameWithMotion, {
    position: "relative",
    "data-framer-component-type": pageContentWrapperType,
    width: wrapperWidth,
    height: wrapperHeight,
    preserve3d: false,
    backgroundColor: "transparent",
    _layoutResetTransform: true,
    key: effect ? Object.keys(effect).join("") : "",
    style: {
      ...effect,
      display: "flex",
      flexDirection: isHorizontalDirection ? "row" : "column",
      alignItems: alignment && toJustifyOrAlignment(alignment)
    }
  }, children));
}

// src/components/Page/EmulatedPage.tsx
var Page = forwardRef8(function Page2(props, forwardedRef) {
  const {
    direction = "horizontal",
    contentWidth = "stretch",
    contentHeight = "stretch",
    alignment = "start",
    currentPage = 0,
    animateCurrentPageUpdate = true,
    gap: gapValue = 10,
    padding = 0,
    momentum = false,
    dragEnabled = true,
    defaultEffect = "none",
    background = "transparent",
    overflow = "hidden",
    __fromCodeComponentNode,
    effect,
    children,
    contentOffsetX,
    contentOffsetY,
    onChangePage,
    onScrollStart,
    onScroll,
    onDragStart,
    onDrag,
    onDragEnd,
    directionLock,
    onScrollEnd,
    onDirectionLock,
    onUpdate,
    wheelEnabled = false,
    layoutId: specificLayoutId,
    ...rest
  } = props;
  const layoutId = useLayoutId2(props, { specificLayoutId, postfix: "page" });
  const containerProps = { ...rest, background };
  const hasMountedRef = useRef21(false);
  const hasFixedSize = RenderTarget.hasRestrictions() && props.__fromCodeComponentNode && isFiniteNumber(containerProps.width) && isFiniteNumber(containerProps.height);
  if (!hasFixedSize && __fromCodeComponentNode && !containerProps.__fromCanvasComponent) {
    containerProps.width = "100%";
    containerProps.height = "100%";
    containerProps._constraints = { enabled: true };
  }
  const { initial, prev } = useRef21({
    initial: { x: 0, y: 0 },
    prev: { x: 0, y: 0 }
  }).current;
  const isHorizontal = direction === "horizontal";
  let gap = gapValue;
  if (gap < 0) {
    warnOnce(`The 'gap' property of Page component can not be negative, but is ${gapValue}.`);
    gap = 0;
  }
  injectComponentCSSRules();
  const pageCount = Children10.count(children);
  const maxOffsetRef = useRef21(0);
  const constraints = useRef21({ top: 0, left: 0, right: 0, bottom: 0 });
  const fallbackContainerRef = useRef21(null);
  const containerRef = forwardedRef || fallbackContainerRef;
  const scrollableRef = useRef21(null);
  const pageEffectValuesRef = useRef21([]);
  const pageRectsRef = useRef21([]);
  const internalX = useMotionValue(isMotionValue2(contentOffsetX) ? 0 : contentOffsetX != null ? contentOffsetX : 0);
  const internalY = useMotionValue(isMotionValue2(contentOffsetY) ? 0 : contentOffsetY != null ? contentOffsetY : 0);
  const contentOffsetRef = useRef21({
    x: isMotionValue2(contentOffsetX) ? contentOffsetX : internalX,
    y: isMotionValue2(contentOffsetY) ? contentOffsetY : internalY
  });
  const currentContentPageRef = useRef21(0);
  const propsBoundedCurrentPageRef = useRef21(0);
  const latestPropsRef = useRef21(props);
  latestPropsRef.current = props;
  const lastDirectionRef = useRef21(props.direction);
  const snapToPage = useSnapToPage(currentContentPageRef, contentOffsetRef, isHorizontal);
  const [_, setForceUpdateCount] = useState8(0);
  const containerSizeRef = useRef21({ width: 200, height: 200 });
  if (hasFixedSize && isFiniteNumber(containerProps.width) && isFiniteNumber(containerProps.height)) {
    containerSizeRef.current.width = containerProps.width;
    containerSizeRef.current.height = containerProps.height;
  }
  const updateOnResize = useCallback9(() => {
    if (!hasFixedSize)
      setForceUpdateCount((v) => v + 1);
  }, [hasFixedSize]);
  useEffect21(() => {
    if (RenderTarget.current() !== RenderTarget.preview)
      return;
    globalThis.addEventListener("resize", updateOnResize);
    return () => {
      globalThis.removeEventListener("resize", updateOnResize);
    };
  }, [updateOnResize]);
  const applyEffects = () => {
    pageEffectValuesRef.current.forEach((effectDictionary, index) => {
      const values = effectValues(index, latestPropsRef, pageRectsRef, contentOffsetRef, maxOffsetRef);
      if (!effectDictionary || !values)
        return;
      for (const key6 in values) {
        if (isMotionValue2(effectDictionary[key6])) {
          effectDictionary[key6].set(values[key6]);
        }
      }
    });
  };
  const updateMaxOffsetFromPageContents = (containerSize) => {
    const newPageContentRects = getPageContentRects(containerRef, containerSize, direction, gap);
    if (newPageContentRects)
      pageRectsRef.current = newPageContentRects;
    const newMaxOffset = getMaxOffset(containerSizeRef.current, pageRectsRef.current, direction, latestPropsRef.current);
    if (newMaxOffset !== maxOffsetRef.current) {
      maxOffsetRef.current = newMaxOffset;
      constraints.current.top = -newMaxOffset;
      constraints.current.left = -newMaxOffset;
      if (RenderTarget.current() === RenderTarget.canvas)
        setForceUpdateCount((v) => v + 1);
    }
  };
  const measureContainerSize = () => {
    const element = containerRef.current;
    if (!element)
      return null;
    const { offsetWidth, offsetHeight } = element;
    const currentSize = containerSizeRef.current;
    if (offsetWidth !== currentSize.width || offsetHeight !== currentSize.height) {
      containerSizeRef.current = {
        width: offsetWidth,
        height: offsetHeight
      };
      return containerSizeRef.current;
    }
    return null;
  };
  const updateAndSnapToPage = (newPage, mount = false) => {
    const newBoundedCurrentPage = getBoundedCurrentPage(newPage, pageCount);
    const boundedCurrentPageDidChange = newBoundedCurrentPage !== propsBoundedCurrentPageRef.current;
    if (boundedCurrentPageDidChange) {
      propsBoundedCurrentPageRef.current = newBoundedCurrentPage;
      updateCurrentPage(newBoundedCurrentPage, currentContentPageRef, onChangePage);
    }
    const offset = offsetForPage(newBoundedCurrentPage, pageCount, pageRectsRef, isHorizontal, maxOffsetRef);
    const animated = animateCurrentPageUpdate && RenderTarget.current() !== RenderTarget.canvas && !mount;
    snapToPage(newBoundedCurrentPage, offset, { animated });
  };
  useLayoutEffect8(() => {
    var _a;
    if (hasMountedRef.current)
      return;
    currentContentPageRef.current = currentPage;
    const contentOffset = contentOffsetRef.current;
    contentOffset.x.onChange(applyEffects);
    contentOffset.y.onChange(applyEffects);
    applyEffects();
    hasMountedRef.current = true;
    const containerSize = (_a = measureContainerSize()) != null ? _a : containerSizeRef.current;
    updateMaxOffsetFromPageContents(containerSize);
    updateAndSnapToPage(currentContentPageRef.current, true);
  }, []);
  useEffect21(() => {
    if (currentPage !== currentContentPageRef.current)
      updateAndSnapToPage(currentPage);
  }, [currentPage]);
  const handleMeasureLifecycle = () => {
    const newContainerSize = measureContainerSize();
    updateMaxOffsetFromPageContents(newContainerSize != null ? newContainerSize : containerSizeRef.current);
    updateAndSnapToPage(currentContentPageRef.current);
    if (newContainerSize || direction !== lastDirectionRef.current) {
      if (direction === "horizontal") {
        contentOffsetRef.current.y.set(0);
      } else {
        contentOffsetRef.current.x.set(0);
      }
      lastDirectionRef.current = direction;
    }
  };
  useLayoutEffect8(() => {
    if (RenderTarget.current() !== RenderTarget.canvas)
      return;
    handleMeasureLifecycle();
  });
  const onDragStartHandler = (event, info) => {
    if (onScrollStart)
      onScrollStart(info);
    if (onDragStart)
      onDragStart(event, info);
    prev.x = initial.x = info.point.x;
    prev.y = initial.y = info.point.y;
  };
  const onDragHandler = (event, info) => {
    if (onScroll)
      onScroll(info);
    if (onDrag)
      onDrag(event, info);
    prev.x = info.point.x;
    prev.y = info.point.y;
  };
  const onDragTransitionEnd = () => {
    if (props.onDragTransitionEnd)
      props.onDragTransitionEnd();
    if (onScrollEnd) {
      const { x, y } = contentOffsetRef.current;
      const point = { x: x.get(), y: y.get() };
      onScrollEnd({
        point,
        velocity: { x: x.getVelocity(), y: y.getVelocity() },
        offset: { x: point.x - initial.x, y: point.y - initial.y },
        delta: { x: point.x - prev.x, y: point.y - prev.y }
      });
    }
  };
  const onDragEndHandler = async (event, info) => {
    const contentOffset = isHorizontal ? contentOffsetRef.current.x : contentOffsetRef.current.y;
    contentOffset.stop();
    const startPosition = contentOffset.get();
    const axis = isHorizontal ? "x" : "y";
    const velocity = info.velocity[axis];
    let index = nearestPageIndex(pageRectsRef.current, startPosition, startPosition, isHorizontal, momentum);
    if (velocity) {
      inertia({
        from: startPosition,
        velocity,
        modifyTarget: (endPosition) => {
          index = nearestPageIndex(pageRectsRef.current, startPosition, endPosition, isHorizontal, momentum);
          return endPosition;
        }
      }).stop();
    }
    updateCurrentPage(index, currentContentPageRef, onChangePage);
    const offset = offsetForPage(index, pageCount, pageRectsRef, isHorizontal, maxOffsetRef);
    if (onDragEnd)
      onDragEnd(event, info);
    const handler = contentOffsetRef.current[axis];
    animate2(handler, offset, {
      type: "spring",
      from: startPosition,
      velocity,
      stiffness: 500,
      damping: 50,
      onComplete: onDragTransitionEnd
    });
  };
  pageEffectValuesRef.current = [];
  const childComponents = Children10.map(children, (child, index) => {
    var _a;
    if (!isReactChild(child) || !isReactElement(child)) {
      return child;
    }
    const update = {
      right: void 0,
      bottom: void 0,
      top: void 0,
      left: void 0,
      _constraints: {
        enabled: false
      }
    };
    if (containerProps.__fromCanvasComponent) {
      update.style = (_a = child.props.style) != null ? _a : {};
      if (contentWidth === "stretch")
        update.style.width = "100%";
      if (contentHeight === "stretch")
        update.style.height = "100%";
    } else {
      if (contentWidth === "stretch")
        update.width = "100%";
      if (contentHeight === "stretch")
        update.height = "100%";
    }
    let effectDictionary;
    const values = effectValues(index, latestPropsRef, pageRectsRef, contentOffsetRef, maxOffsetRef);
    if (values) {
      effectDictionary = {};
      for (const key6 in values) {
        effectDictionary[key6] = motionValue(values[key6]);
      }
    }
    pageEffectValuesRef.current.push(effectDictionary);
    return /* @__PURE__ */ createElement35(PageContainer, {
      key: index,
      effect: effectDictionary,
      dragEnabled,
      direction,
      contentHeight,
      contentWidth,
      alignment,
      gap,
      isLastPage: index === pageCount - 1,
      contentOffsetRef,
      constraintsRef: constraints,
      directionLock,
      onDragStart: onDragStartHandler,
      onDrag: onDragHandler,
      onDragEnd: onDragEndHandler,
      layoutId: layoutId ? `${layoutId}-${index}` : void 0
    }, cloneElement8(child, update));
  });
  useWheelScroll(scrollableRef, {
    enabled: wheelEnabled,
    initial,
    prev,
    direction,
    constraints,
    offsetX: contentOffsetRef.current.x,
    offsetY: contentOffsetRef.current.y,
    onScrollStart,
    onScroll,
    onScrollEnd
  });
  return /* @__PURE__ */ createElement35(FrameWithMotion, {
    preserve3d: false,
    perspective: hasEffect(props) ? 1200 : void 0,
    overflow,
    ...containerProps,
    layoutId,
    ref: containerRef,
    onLayoutMeasure: handleMeasureLifecycle
  }, /* @__PURE__ */ createElement35(FrameWithMotion, {
    "data-framer-component-type": "Page",
    ref: scrollableRef,
    background: null,
    x: contentOffsetRef.current.x,
    y: contentOffsetRef.current.y,
    width: "100%",
    height: "100%",
    preserve3d: true,
    layout: true,
    layoutId: layoutId !== void 0 ? layoutId + "-page" : void 0,
    style: {
      padding: makePaddingString(paddingFromProps(props)),
      display: "flex",
      flexDirection: isHorizontal ? "row" : "column"
    }
  }, /* @__PURE__ */ createElement35(EmptyState, {
    title: "Page",
    description: "Click and drag the connector to any frame on the canvas \u2192",
    children,
    size: containerSizeRef.current,
    insideUserCodeComponent: !__fromCodeComponentNode
  }), childComponents));
});
function cubeEffect(info) {
  const { normalizedOffset, direction } = info;
  const isHorizontal = direction === "horizontal";
  return {
    originX: normalizedOffset < 0 ? 1 : 0,
    originY: normalizedOffset < 0 ? 1 : 0,
    rotateY: isHorizontal ? Math.min(Math.max(-90, normalizedOffset * 90), 90) : 0,
    rotateX: isHorizontal ? 0 : Math.min(Math.max(-90, normalizedOffset * -90), 90),
    backfaceVisibility: "hidden",
    WebkitBackfaceVisibility: "hidden"
  };
}
function coverflowEffect(info) {
  const { normalizedOffset, direction, size: size2 } = info;
  const isHorizontal = direction === "horizontal";
  return {
    rotateY: isHorizontal ? Math.min(45, Math.max(-45, normalizedOffset * -45)) : 0,
    rotateX: isHorizontal ? 0 : Math.min(45, Math.max(-45, normalizedOffset * 45)),
    originX: isHorizontal ? normalizedOffset < 0 ? 0 : 1 : 0.5,
    originY: isHorizontal ? 0.5 : normalizedOffset < 0 ? 0 : 1,
    x: isHorizontal ? `${normalizedOffset * -25}%` : 0,
    y: isHorizontal ? 0 : `${normalizedOffset * -25}%`,
    z: -Math.abs(normalizedOffset),
    scale: 1 - Math.abs(normalizedOffset / 10)
  };
}
function calcPileAxisOffset(offset, length) {
  return offset * length - offset * 8;
}
function pileEffect(info) {
  const { normalizedOffset, direction, size: size2 } = info;
  const isHorizontal = direction === "horizontal";
  const absoluteOffset = Math.abs(normalizedOffset);
  return {
    x: normalizedOffset < 0 && isHorizontal ? calcPileAxisOffset(absoluteOffset, size2.width) : 0,
    y: normalizedOffset < 0 && !isHorizontal ? calcPileAxisOffset(absoluteOffset, size2.height) : 0,
    scale: normalizedOffset < 0 ? 1 - absoluteOffset / 50 : 1
  };
}
function wheelEffect(info) {
  const { normalizedOffset, direction, size: size2 } = info;
  const isHorizontal = direction === "horizontal";
  const originZ = (isHorizontal ? size2.width : size2.height) * 18 / (2 * Math.PI);
  const rotateX = isHorizontal ? 0 : normalizedOffset * -20;
  const rotateY = isHorizontal ? normalizedOffset * 20 : 0;
  const y = isHorizontal ? 0 : normalizedOffset * -size2.height;
  const x = isHorizontal ? normalizedOffset * -size2.width : 0;
  return {
    opacity: 1 - Math.abs(normalizedOffset) / 4,
    transform: `translate(${x}px, ${y}px) translateZ(-${originZ}px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateZ(${originZ}px)`
  };
}
function getDefaultEffect(type) {
  switch (type) {
    case "cube":
      return cubeEffect;
    case "coverflow":
      return coverflowEffect;
    case "pile":
      return pileEffect;
    case "wheel":
      return wheelEffect;
    default:
      return null;
  }
}
function nearestPageIndex(pageRects, startPosition, endPosition, isHorizontalDirection, allowSkippingPages) {
  const distanceToStart = function(rect) {
    const rectPosition = isHorizontalDirection ? rect.x : rect.y;
    return Math.abs(rectPosition + startPosition);
  };
  const distanceToEnd = function(rect) {
    const rectPosition = isHorizontalDirection ? rect.x : rect.y;
    return Math.abs(rectPosition + endPosition);
  };
  if (allowSkippingPages) {
    const closestPages = [...pageRects].sort((a2, b2) => distanceToEnd(a2) - distanceToEnd(b2));
    return pageRects.indexOf(closestPages[0]);
  } else {
    const closestToStart = [...pageRects].sort((a2, b2) => distanceToStart(a2) - distanceToStart(b2));
    if (closestToStart.length === 1)
      return pageRects.indexOf(closestToStart[0]);
    const pageA = closestToStart[0];
    const pageB = closestToStart[1];
    const closestPages = [pageA, pageB].sort((a2, b2) => distanceToEnd(a2) - distanceToEnd(b2));
    return pageRects.indexOf(closestPages[0]);
  }
}
function getPageContentRects(containerRef, containerSize, direction, gap) {
  var _a;
  const containerElement = containerRef.current;
  if (!containerElement)
    return;
  const contentWrappers = [];
  (_a = containerElement.firstChild) == null ? void 0 : _a.childNodes.forEach((node) => {
    const childNode = node.firstChild;
    if (!(childNode instanceof HTMLElement))
      return;
    const componentType = childNode.getAttribute("data-framer-component-type");
    if (componentType === pageContentWrapperType) {
      contentWrappers.push(childNode);
    }
  });
  const sizes = [];
  contentWrappers.forEach((contentWrapper) => {
    if (contentWrapper instanceof HTMLElement && contentWrapper.firstChild instanceof HTMLElement) {
      let width = contentWrapper.firstChild.offsetWidth;
      let height = contentWrapper.firstChild.offsetHeight;
      if (false) {
        width = 100;
        height = 100;
      }
      sizes.push({ width, height });
    } else {
      sizes.push(null);
    }
  });
  let maxX = 0;
  let maxY = 0;
  const isHorizontal = direction === "horizontal";
  return sizes.map((queriedSize) => {
    const size2 = queriedSize || containerSize;
    const x = maxX;
    const y = maxY;
    if (isHorizontal) {
      maxX += size2.width + gap;
    } else {
      maxY += size2.height + gap;
    }
    return { ...size2, x, y };
  });
}
function getMaxOffset(containerSize, pageContentRects, direction, paddingProps) {
  const lastPageRect = pageContentRects[pageContentRects.length - 1];
  if (!lastPageRect)
    return 0;
  const paddingSides = paddingFromProps(paddingProps);
  const isHorizontal = direction === "horizontal";
  const paddingStart = isHorizontal ? paddingSides.left : paddingSides.top;
  const paddingEnd = isHorizontal ? paddingSides.right : paddingSides.bottom;
  const pageWidth = isHorizontal ? lastPageRect.width : lastPageRect.height;
  const containerWidth = isHorizontal ? containerSize.width : containerSize.height;
  const freeSpace = containerWidth - paddingStart - paddingEnd - pageWidth;
  const target = isHorizontal ? lastPageRect.x : lastPageRect.y;
  if (freeSpace <= 0)
    return Math.max(target, 0);
  return Math.max(target - freeSpace, 0);
}
function offsetForPage(index, pageCount, pageRectsRef, isHorizontal, maxOffsetRef) {
  const pageIndex = Math.max(0, Math.min(pageCount - 1, index));
  const currentPageRect = pageRectsRef.current[pageIndex];
  if (!currentPageRect) {
    return 0;
  }
  if (isHorizontal) {
    return -Math.min(currentPageRect.x, maxOffsetRef.current);
  } else {
    return -Math.min(currentPageRect.y, maxOffsetRef.current);
  }
}
function useSnapToPage(currentContentPageRef, contentOffsetRef, isHorizontal) {
  return (pageIndex, offset, options) => {
    currentContentPageRef.current = pageIndex;
    const contentOffset = isHorizontal ? contentOffsetRef.current.x : contentOffsetRef.current.y;
    if (!options || !options.animated) {
      contentOffset.set(offset);
      return;
    }
    const axis = isHorizontal ? "x" : "y";
    animate2(contentOffsetRef.current[axis], offset, {
      type: "spring",
      from: contentOffset.get(),
      velocity: contentOffset.getVelocity(),
      stiffness: 500,
      damping: 50
    });
  };
}
function getBoundedCurrentPage(pageIndex, pageCount) {
  return pageIndex >= 0 ? Math.min(pageIndex, pageCount - 1) : (pageIndex % pageCount + pageCount) % pageCount;
}
function effectValues(index, latestPropsRef, pageRectsRef, contentOffsetRef, maxOffsetRef) {
  const {
    direction: latestDirection = "horizontal",
    defaultEffect: latestDefaultEffect,
    effect: latestEffect,
    gap: latestGap = 0
  } = latestPropsRef.current;
  const latestIsHorizontal = latestDirection === "horizontal";
  const pageRect = pageRectsRef.current[index] || {
    x: latestIsHorizontal ? index * 200 + latestGap : 0,
    y: latestIsHorizontal ? 0 : index * 200 + latestGap,
    width: 200,
    height: 200
  };
  const effectFunction = latestEffect || getDefaultEffect(latestDefaultEffect);
  if (!effectFunction)
    return null;
  let offset;
  let normalizedOffset;
  const contentOffset = contentOffsetRef.current;
  const maxScrollOffset = maxOffsetRef.current;
  if (latestIsHorizontal) {
    offset = Math.min(pageRect.x, maxScrollOffset) + (contentOffset ? contentOffset.x.get() : 0);
    normalizedOffset = offset / (pageRect.width + latestGap);
  } else {
    offset = Math.min(pageRect.y, maxScrollOffset) + (contentOffset ? contentOffset.y.get() : 0);
    normalizedOffset = offset / (pageRect.height + latestGap);
  }
  const size2 = { width: pageRect.width, height: pageRect.height };
  return effectFunction({
    offset,
    normalizedOffset,
    size: size2,
    index,
    direction: latestDirection,
    gap: latestGap,
    pageCount: pageRectsRef.current.length
  });
}
function hasEffect(props) {
  return !!props.effect || !!getDefaultEffect(props.defaultEffect);
}
function updateCurrentPage(newPageIndex, currentContentPageRef, onChangePage) {
  if (currentContentPageRef.current === newPageIndex)
    return;
  if (onChangePage)
    onChangePage(newPageIndex, currentContentPageRef.current);
  currentContentPageRef.current = newPageIndex;
}

// src/components/Page/Page.tsx
var ContentDimension;
(function(ContentDimension2) {
  ContentDimension2.Auto = "auto";
  ContentDimension2.Stretch = "stretch";
})(ContentDimension || (ContentDimension = {}));
var pageContentDimensionOptions = [ContentDimension.Auto, ContentDimension.Stretch];
var pageContentDimensionTitles = pageContentDimensionOptions.map((option) => {
  switch (option) {
    case ContentDimension.Auto:
      return "Auto";
    case ContentDimension.Stretch:
      return "Stretch";
  }
});
var pageEffectOptions = ["none", "cube", "coverflow", "wheel", "pile"];
var pageEffectTitles = pageEffectOptions.map((option) => {
  switch (option) {
    case "none":
      return "None";
    case "cube":
      return "Cube";
    case "coverflow":
      return "Cover Flow";
    case "wheel":
      return "Wheel";
    case "pile":
      return "Pile";
  }
});
var pageAlignmentOptions = ["start", "center", "end"];
var genericAlignmentTitles = pageAlignmentOptions.map((option) => {
  switch (option) {
    case "start":
      return "Start";
    case "center":
      return "Center";
    case "end":
      return "End";
  }
});
addPropertyControls(Page, {
  direction: {
    type: ControlType.Enum,
    options: ["horizontal", "vertical"],
    title: "Direction",
    defaultValue: "horizontal",
    displaySegmentedControl: true,
    optionIcons: ["direction-horizontal", "direction-vertical"]
  },
  directionLock: {
    type: ControlType.Boolean,
    title: "Lock",
    enabledTitle: "1 Axis",
    disabledTitle: "Off",
    defaultValue: true
  },
  contentWidth: {
    type: ControlType.Enum,
    options: pageContentDimensionOptions,
    optionTitles: pageContentDimensionTitles,
    title: "Width",
    defaultValue: ContentDimension.Stretch,
    displaySegmentedControl: true
  },
  contentHeight: {
    type: ControlType.Enum,
    options: pageContentDimensionOptions,
    optionTitles: pageContentDimensionTitles,
    title: "Height",
    defaultValue: ContentDimension.Stretch,
    displaySegmentedControl: true
  },
  alignment: {
    type: ControlType.Enum,
    options: pageAlignmentOptions,
    optionTitles: genericAlignmentTitles,
    title: "Align",
    hidden(props) {
      const { direction, contentWidth, contentHeight } = props;
      const isHorizontalDirection = direction === "horizontal";
      const crossDimension = isHorizontalDirection ? contentHeight : contentWidth;
      return crossDimension === ContentDimension.Stretch;
    },
    defaultValue: "start",
    displaySegmentedControl: true,
    optionIcons: {
      direction: {
        horizontal: ["align-top", "align-middle", "align-bottom"],
        vertical: ["align-left", "align-center", "align-right"]
      }
    }
  },
  gap: {
    type: ControlType.Number,
    min: 0,
    title: "Gap",
    defaultValue: 0
  },
  padding: {
    type: ControlType.FusedNumber,
    toggleKey: "paddingPerSide",
    toggleTitles: ["Padding", "Padding per side"],
    valueKeys: ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
    valueLabels: ["T", "R", "B", "L"],
    min: 0,
    title: "Padding",
    defaultValue: 0
  },
  currentPage: {
    type: ControlType.Number,
    min: 0,
    title: "Current",
    displayStepper: true,
    defaultValue: 0
  },
  momentum: {
    type: ControlType.Boolean,
    enabledTitle: "On",
    disabledTitle: "Off",
    title: "Momentum",
    defaultValue: false
  },
  dragEnabled: {
    type: ControlType.Boolean,
    title: "Drag",
    enabledTitle: "On",
    disabledTitle: "Off",
    defaultValue: true
  },
  wheelEnabled: {
    type: ControlType.Boolean,
    title: "Wheel",
    enabledTitle: "On",
    disabledTitle: "Off",
    defaultValue: false
  },
  defaultEffect: {
    type: ControlType.Enum,
    options: pageEffectOptions,
    optionTitles: pageEffectTitles,
    title: "Effect",
    defaultValue: "none"
  },
  children: {
    type: ControlType.Array,
    title: "Content",
    control: { type: ControlType.ComponentInstance, title: "Page" }
  }
});
Page.supportsConstraints = true;

// src/components/hoc/WithNavigator.tsx
import {
  Component as Component13,
  createElement as createElement36
} from "react";

// src/render/types/NavigationLink.ts
var NavigateTo;
(function(NavigateTo2) {
  NavigateTo2["Previous"] = "@Previous";
})(NavigateTo || (NavigateTo = {}));
var NavigationTransitionType;
(function(NavigationTransitionType2) {
  NavigationTransitionType2["push"] = "push";
  NavigationTransitionType2["instant"] = "instant";
  NavigationTransitionType2["fade"] = "fade";
  NavigationTransitionType2["modal"] = "modal";
  NavigationTransitionType2["overlay"] = "overlay";
  NavigationTransitionType2["flip"] = "flip";
  NavigationTransitionType2["magicMotion"] = "magicMotion";
})(NavigationTransitionType || (NavigationTransitionType = {}));

// src/components/hoc/WithNavigator.tsx
var hoistNonReactStatic3 = require_hoist_non_react_statics_cjs();
function WithNavigator(BaseComponent, navigationTransition, navigationTransitionDirection, NavigationTarget2, navigationTransitionOptions) {
  const InternalWithNavigator = class extends Component13 {
    render() {
      return /* @__PURE__ */ createElement36(NavigationContext.Consumer, null, (navigation) => {
        const navigate = () => {
          if (navigationTransition === "goBack") {
            navigation.goBack();
            return;
          }
          if (!NavigationTarget2)
            return;
          const component = NavigationTarget2();
          const appearsFrom = transitionDirectionToSide(navigationTransitionDirection);
          switch (navigationTransition) {
            case NavigationTransitionType.instant:
              navigation.instant(component);
              break;
            case NavigationTransitionType.fade:
              navigation.fade(component);
              break;
            case NavigationTransitionType.modal:
              navigation.modal(component, navigationTransitionOptions);
              break;
            case NavigationTransitionType.push:
              navigation.push(component, { appearsFrom });
              break;
            case NavigationTransitionType.overlay:
              navigation.overlay(component, {
                ...navigationTransitionOptions,
                appearsFrom
              });
              break;
            case NavigationTransitionType.flip:
              navigation.flip(component, { appearsFrom });
              break;
            case NavigationTransitionType.magicMotion:
              navigation.magicMotion(component, {});
              break;
          }
        };
        const { onTap, ...props } = this.props;
        if (onTap) {
          props.onTap = (...args) => {
            onTap.apply(this, args);
            navigate.apply(this, args);
          };
        } else {
          props.onTap = navigate;
        }
        return /* @__PURE__ */ createElement36(BaseComponent, {
          ...props
        });
      });
    }
  };
  hoistNonReactStatic3(InternalWithNavigator, BaseComponent);
  return InternalWithNavigator;
}
function transitionDirectionToSide(direction) {
  switch (direction) {
    case "left":
      return "right";
    case "right":
      return "left";
    case "up":
      return "bottom";
    case "down":
      return "top";
  }
}

// src/animation/Animators/PrecalculatedAnimator.ts
var Defaults2 = {
  delta: 1 / 60,
  maxValues: 1e4
};
var PrecalculatedAnimator = class {
  constructor(options) {
    this.currentTime = 0;
    this.options = { ...Defaults2, ...options };
    this.animator = options.animator;
  }
  preCalculate() {
    if (!this.animator.isReady()) {
      return;
    }
    const { delta: delta2 } = this.options;
    this.values = [];
    while (!this.animator.isFinished() && this.values.length < this.options.maxValues) {
      let value = this.animator.next(this.options.delta);
      if (typeof value === "object" && value) {
        const object = value;
        const copy = { ...object };
        value = copy;
      }
      this.values.push(value);
    }
    this.totalTime = this.values.length * delta2;
  }
  indexForTime(time3) {
    return Math.max(0, Math.min(this.values.length - 1, Math.round(this.values.length * (time3 / this.totalTime)) - 1));
  }
  setFrom(value) {
    this.animator.setFrom(value);
    this.preCalculate();
  }
  setTo(end) {
    this.animator.setTo(end);
    this.preCalculate();
  }
  isReady() {
    return this.values !== void 0 && this.values.length > 0 && this.totalTime > 0;
  }
  next(delta2) {
    this.currentTime += delta2;
    const index = this.indexForTime(this.currentTime);
    return this.values[index];
  }
  isFinished() {
    return this.totalTime === 0 || this.currentTime >= this.totalTime;
  }
  get endValue() {
    this.preCalculate();
    const index = this.indexForTime(this.totalTime);
    return this.values.length > 0 ? this.values[index] : this.animator.next(0);
  }
};

// src/animation/Animators/BezierAnimator.ts
var Bezier;
(function(Bezier2) {
  Bezier2["Linear"] = "linear";
  Bezier2["Ease"] = "ease";
  Bezier2["EaseIn"] = "ease-in";
  Bezier2["EaseOut"] = "ease-out";
  Bezier2["EaseInOut"] = "ease-in-out";
})(Bezier || (Bezier = {}));
var BezierDefaults = {
  curve: Bezier.Ease,
  duration: 1
};
function controlPointsForCurve(curve) {
  switch (curve) {
    case Bezier.Linear:
      return [0, 0, 1, 1];
    case Bezier.Ease:
      return [0.25, 0.1, 0.25, 1];
    case Bezier.EaseIn:
      return [0.42, 0, 1, 1];
    case Bezier.EaseOut:
      return [0, 0, 0.58, 1];
    case Bezier.EaseInOut:
      return [0.42, 0, 0.58, 1];
  }
}
var BezierAnimator = class {
  constructor(options, interpolation) {
    this.interpolation = interpolation;
    this.progress = 0;
    this.next = (delta2) => {
      const { duration } = this.options;
      this.progress += delta2 / duration;
      const value = this.unitBezier.solve(this.progress, this.solveEpsilon(duration));
      this.current = this.interpolator(value);
      return this.current;
    };
    this.options = { ...BezierDefaults, ...options };
    let controlPoints;
    if (typeof this.options.curve === "string") {
      controlPoints = controlPointsForCurve(this.options.curve);
    } else {
      controlPoints = this.options.curve;
    }
    const [p1x, p1y, p2x, p2y] = controlPoints;
    this.unitBezier = new UnitBezier(Point(p1x, p1y), Point(p2x, p2y));
  }
  setFrom(value) {
    this.current = value;
    this.updateInterpolator();
  }
  setTo(value) {
    this.destination = value;
    this.updateInterpolator();
  }
  isReady() {
    return this.interpolator !== void 0;
  }
  updateInterpolator() {
    if (this.current === void 0 || this.destination === void 0) {
      return;
    }
    this.interpolator = this.interpolation.interpolate(this.current, this.destination);
  }
  isFinished() {
    return this.progress >= 1;
  }
  solveEpsilon(duration) {
    return 1 / (200 * duration);
  }
};
var UnitBezier = class {
  constructor(point1, point2) {
    this.c = Point.multiply(point1, 3);
    this.b = Point.subtract(Point.multiply(Point.subtract(point2, point1), 3), this.c);
    this.a = Point.subtract(Point.subtract(Point(1, 1), this.c), this.b);
  }
  solve(x, epsilon2) {
    return this.sampleY(this.solveForT(x, epsilon2));
  }
  sampleX(t) {
    return ((this.a.x * t + this.b.x) * t + this.c.x) * t;
  }
  sampleY(t) {
    return ((this.a.y * t + this.b.y) * t + this.c.y) * t;
  }
  sampleDerivativeX(t) {
    return (3 * this.a.x * t + 2 * this.b.x) * t + this.c.x;
  }
  solveForT(x, epsilon2) {
    let t0, t1, t2, x2, d2, i;
    t2 = x;
    for (i = 0; i < 8; ++i) {
      x2 = this.sampleX(t2) - x;
      if (Math.abs(x2) < epsilon2)
        return t2;
      d2 = this.sampleDerivativeX(t2);
      if (Math.abs(d2) < epsilon2)
        break;
      t2 = t2 - x2 / d2;
    }
    t0 = 0;
    t1 = 1;
    t2 = x;
    if (t2 < t0)
      return t0;
    if (t2 > t1)
      return t1;
    while (t0 < t1) {
      x2 = this.sampleX(t2);
      if (Math.abs(x2 - x) < epsilon2)
        return t2;
      if (x > x2)
        t0 = t2;
      else
        t1 = t2;
      t2 = (t1 - t0) * 0.5 + t0;
    }
    return t2;
  }
};

// src/animation/FramerAnimation.ts
var DefaultDeprecatedAnimationOptions = {
  precalculate: false,
  colorModel: ColorMixModelType.HUSL
};
var FramerAnimation = class {
  constructor(target, from, to, animatorClass, options, driverClass = MainLoopAnimationDriver) {
    this.playStateSource = "idle";
    this.readyPromise = Promise.resolve();
    this.resetFinishedPromise();
    const deprecatedAnimationOptions = { ...DefaultDeprecatedAnimationOptions };
    const animatorOptions = {};
    if (options) {
      Object.assign(deprecatedAnimationOptions, options);
      Object.assign(animatorOptions, options);
    }
    let interpolation;
    if (deprecatedAnimationOptions.customInterpolation) {
      interpolation = deprecatedAnimationOptions.customInterpolation;
    } else {
      interpolation = new ValueInterpolation(options);
    }
    let animator;
    if (!animatorClass) {
      animator = new BezierAnimator({}, interpolation);
    } else {
      animator = new animatorClass(animatorOptions, interpolation);
    }
    if (deprecatedAnimationOptions.precalculate) {
      animator = new PrecalculatedAnimator({ animator });
    }
    animator.setFrom(from);
    animator.setTo(to);
    const updateCallback = (value) => {
      FramerAnimation.driverCallbackHandler(target, value);
    };
    const finishedCallback = (isFinished) => {
      if (isFinished) {
        FramerAnimation.driverCallbackHandler(target, to);
        if (this.playStateSource === "running") {
          this.playStateValue = "finished";
        }
      }
    };
    this.driver = new driverClass(animator, updateCallback, finishedCallback);
  }
  static driverCallbackHandler(target, value) {
    if (isAnimatable2(target) || isMotionValue2(target)) {
      target.set(value);
    } else {
      const targetObject = target;
      Animatable.transaction((update) => {
        for (const key6 in targetObject) {
          const targetValue = targetObject[key6];
          if (isAnimatable2(targetValue)) {
            update(targetValue, value[key6]);
          } else {
            targetObject[key6] = value[key6];
          }
        }
      });
    }
  }
  get playStateValue() {
    return this.playStateSource;
  }
  set playStateValue(value) {
    if (value !== this.playStateSource) {
      const oldValue = value;
      this.playStateSource = value;
      switch (value) {
        case "idle":
          if (oldValue === "running") {
            this.oncancel && this.oncancel();
          }
          this.readyResolve && this.readyResolve();
          this.resetReadyPromise();
          break;
        case "finished":
          if (oldValue === "idle") {
            console.warn("Bad state transition");
            break;
          }
          this.onfinish && this.onfinish();
          this.finishedResolve && this.finishedResolve();
          break;
        case "running":
          this.resetReadyPromise();
          break;
      }
      if (oldValue === "finished") {
        this.resetFinishedPromise();
      }
      if (value === "finished") {
        this.playStateValue = "idle";
      }
    }
  }
  get playState() {
    return this.playStateValue;
  }
  resetReadyPromise() {
    this.readyResolve = null;
    this.readyPromise = new Promise((resolve, reject) => {
      this.readyResolve = resolve;
    });
  }
  get ready() {
    return this.readyPromise;
  }
  resetFinishedPromise() {
    this.finishedResolve = null;
    this.finishedReject = null;
    this.finishedPromise = new Promise((resolve, reject) => {
      this.finishedResolve = resolve;
      this.finishedReject = reject;
    });
    this.finishedPromise.catch((reason) => {
    });
  }
  get finished() {
    return this.finishedPromise;
  }
  play() {
    this.playStateValue = "running";
    this.driver.play();
  }
  cancel() {
    if (this.playStateValue !== "running") {
      return;
    }
    this.driver.cancel();
    if (this.playState !== "idle") {
      const reason = "AbortError";
      this.finishedReject && this.finishedReject(reason);
    }
    this.playStateValue = "idle";
  }
  finish() {
    if (this.playStateSource === "running") {
      this.playStateValue = "finished";
      this.driver.finish();
    }
  }
  isFinished() {
    return this.playStateValue === "finished";
  }
};

// src/animation/animate.ts
function deprecatedAnimate(from, to, animator, options) {
  deprecationWarning("animate()", "2.0.0", "the new animation API (https://www.framer.com/api/animation/)");
  const target = from;
  let fromValue;
  if (isAnimatable2(from) || isMotionValue2(from)) {
    fromValue = from.get();
  } else {
    fromValue = Animatable.objectToValues(from);
  }
  const animation = new FramerAnimation(target, fromValue, to, animator, options);
  animation.play();
  return animation;
}
function animate3(from, to, animatorOrTransition, options) {
  return isAnimatable2(from) ? deprecatedAnimate(from, to, animatorOrTransition, options) : animate2(from, to, animatorOrTransition);
}
(function(animate4) {
  function spring2(from, to, options) {
    return animate4(from, to, SpringAnimator, options);
  }
  animate4.spring = spring2;
  function bezier(from, to, options) {
    return animate4(from, to, BezierAnimator, options);
  }
  animate4.bezier = bezier;
  function linear2(from, to, options) {
    return animate4.bezier(from, to, { ...options, curve: Bezier.Linear });
  }
  animate4.linear = linear2;
  function ease(from, to, options) {
    return animate4.bezier(from, to, { ...options, curve: Bezier.Ease });
  }
  animate4.ease = ease;
  function easeIn2(from, to, options) {
    return animate4.bezier(from, to, { ...options, curve: Bezier.EaseIn });
  }
  animate4.easeIn = easeIn2;
  function easeOut2(from, to, options) {
    return animate4.bezier(from, to, { ...options, curve: Bezier.EaseOut });
  }
  animate4.easeOut = easeOut2;
  function easeInOut2(from, to, options) {
    return animate4.bezier(from, to, { ...options, curve: Bezier.EaseInOut });
  }
  animate4.easeInOut = easeInOut2;
})(animate3 || (animate3 = {}));

// src/render/utils/getConfigFromURL.ts
function getConfigFromPreviewURL(windowURLString = safeWindow.location.href) {
  if (!windowURLString) {
    throw new Error(`getConfigFromURL() called without url argument (location.href = "${safeWindow.location.href}")`);
  }
  const params = new URL(windowURLString).searchParams;
  const imageBaseURL = params.get("imageBaseURL") || "";
  const projectURL = params.get("projectURL") || "";
  const showConsole = params.get("console") === "1";
  const disableDevice = params.get("device") === "0";
  return { imageBaseURL, projectURL, showConsole, disableDevice };
}
function getConfigFromVekterURL(windowURLString = safeWindow.location.href) {
  if (!windowURLString) {
    throw new Error(`getConfigFromURL() called without url argument (location.href = "${safeWindow.location.href}")`);
  }
  const hash2 = decodeURIComponent(new URL(windowURLString).hash.slice(1));
  const [documentURL, imageBaseURL, projectURL] = hash2.split("#&#");
  return { documentURL, imageBaseURL, projectURL };
}

// src/render/assetResolver/serverURL.ts
function parseURL(url, base) {
  try {
    return typeof base === "undefined" ? new URL(url) : new URL(url, base);
  } catch (err) {
    return null;
  }
}
var flatten = (arrays) => [].concat.apply([], arrays);
function joinPaths(paths) {
  let res = "";
  for (const path of paths) {
    if (!path)
      continue;
    if (res.length > 0 && !res.endsWith("/")) {
      res += "/";
    }
    if (Array.isArray(path)) {
      res += joinPaths(path);
    } else {
      res += encodeURIComponent(path).replace(/%2F/g, "/");
    }
  }
  return res;
}
function serverURL(...paths) {
  const notEmptyPaths = flatten(paths).filter(Boolean);
  if (notEmptyPaths.length === 1 && parseURL(notEmptyPaths[0])) {
    return notEmptyPaths[0];
  }
  const path = joinPaths(paths);
  const resolvedAsset = runtime.assetResolver(path, {
    isFramerResourceURL: true,
    isExport: RenderTarget.current() === RenderTarget.export
  });
  return resolvedAsset || "";
}

// src/utils/internalId.ts
var keys = new Map();
var InternalID = class {
  constructor(id) {
    this.id = id;
    this._link = null;
    this._urllink = null;
  }
  add(str) {
    return InternalID.forKey(this.id + str);
  }
  toString() {
    return this.id;
  }
  get link() {
    const res = this._link;
    if (res)
      return res;
    return this._link = "#" + this.id;
  }
  get urlLink() {
    const res = this._urllink;
    if (res)
      return res;
    return this._urllink = "url(#" + this.id + ")";
  }
  static forKey(key6) {
    let res = keys.get(key6);
    if (res)
      return res;
    res = new InternalID("a" + (1e3 + keys.size) + "z");
    keys.set(key6, res);
    return res;
  }
};

// src/render/utils/elementPropertiesForGradient.ts
function elementPropertiesForLinearGradient(gradient, id) {
  return {
    id: `id${id}g${LinearGradient.hash(gradient)}`,
    angle: gradient.angle - 90,
    stops: gradientColorStops(gradient).map((stop) => ({
      color: stop.value,
      alpha: ConvertColor.getAlpha(stop.value) * gradient.alpha,
      position: stop.position
    }))
  };
}
function elementPropertiesForRadialGradient(gradient, id) {
  return {
    id: `id${id}g${RadialGradient.hash(gradient)}`,
    widthFactor: gradient.widthFactor,
    heightFactor: gradient.heightFactor,
    centerAnchorX: gradient.centerAnchorX,
    centerAnchorY: gradient.centerAnchorY,
    stops: gradientColorStops(gradient).map((stop) => ({
      color: stop.value,
      alpha: ConvertColor.getAlpha(stop.value) * gradient.alpha,
      position: stop.position
    }))
  };
}

// src/render/utils/dom.ts
var frameFromElement = (element) => {
  const frame2 = Rect.fromRect(element.getBoundingClientRect());
  frame2.x = frame2.x + safeWindow.scrollX;
  frame2.y = frame2.y + safeWindow.scrollY;
  return frame2;
};
var frameFromElements = (elements) => {
  return Rect.merge(...elements.map(frameFromElement));
};
var convertToPageFrame = (frame2, element) => {
  const point = convertToPagePoint(frame2, element);
  return {
    x: point.x,
    y: point.y,
    width: frame2.width,
    height: frame2.height
  };
};
var convertFromPageFrame = (frame2, element) => {
  const point = convertFromPagePoint(frame2, element);
  return {
    x: point.x,
    y: point.y,
    width: frame2.width,
    height: frame2.height
  };
};
var getPageFrame = (element) => {
  const rect = element.getBoundingClientRect();
  return {
    x: rect.left + safeWindow.scrollX,
    y: rect.top + safeWindow.scrollY,
    width: rect.width,
    height: rect.height
  };
};
var fromEventForPage = (event) => {
  return {
    x: event.pageX,
    y: event.pageY
  };
};
var fromEventForClient = (event) => {
  return {
    x: event.clientX,
    y: event.clientY
  };
};
var convertToPagePoint = (point, element) => {
  const frame2 = getPageFrame(element);
  return {
    x: point.x + frame2.x,
    y: point.y + frame2.y
  };
};
var convertFromPagePoint = (point, element) => {
  const frame2 = getPageFrame(element);
  return {
    x: point.x - frame2.x,
    y: point.y - frame2.y
  };
};
var dispatchKeyDownEvent = (keyCode, options = {}) => {
  const keyboardEvent = new KeyboardEvent("keydown", {
    bubbles: true,
    keyCode,
    ...options
  });
  const activeElement = document.activeElement;
  if (activeElement) {
    activeElement.dispatchEvent(keyboardEvent);
  }
};
var DOM = {
  frameFromElement,
  frameFromElements,
  convertToPageFrame,
  convertFromPageFrame,
  getPageFrame,
  fromEventForPage,
  fromEventForClient,
  convertToPagePoint,
  convertFromPagePoint
};

// src/render/traits/Shape.ts
var key4 = "calculatedPaths";
function withShape(target) {
  return key4 in target;
}

// src/render/utils/gradientForShape.tsx
function gradientForShape(nodeId, node) {
  if (LinearGradient.isLinearGradient(node.fill)) {
    return elementPropertiesForLinearGradient(node.fill, nodeId);
  }
  if (RadialGradient.isRadialGradient(node.fill)) {
    return elementPropertiesForRadialGradient(node.fill, nodeId);
  }
  return void 0;
}

// src/render/utils/throttle.ts
function throttle(fn, time3) {
  let previous = 0;
  let timeout;
  const later = (...args) => {
    previous = Date.now();
    timeout = void 0;
    fn(...args);
  };
  return (...args) => {
    const now = Date.now();
    const remaining = time3 - (now - previous);
    if (remaining <= 0 || remaining > time3) {
      if (timeout) {
        safeWindow.clearTimeout(timeout);
        timeout = void 0;
      }
      previous = now;
      fn(...args);
    } else if (!timeout) {
      timeout = safeWindow.setTimeout(later, remaining, ...args);
    }
  };
}

// ../app/assets/src/assetReference.ts
var mediaType = "framer/asset-reference,";
function isAssetReference(value) {
  return value.startsWith(`data:${mediaType}`);
}

// src/render/utils/imageUrlForAsset.ts
function imageUrlForAsset(asset, size2) {
  var _a;
  if (/^\w+:/.test(asset) && !isAssetReference(asset))
    return asset;
  if (typeof size2 !== "number")
    size2 = void 0;
  else if (size2 <= 512)
    size2 = 512;
  else if (size2 <= 1024)
    size2 = 1024;
  else if (size2 <= 2048)
    size2 = 2048;
  else
    size2 = 4096;
  const isExport = RenderTarget.current() === RenderTarget.export;
  return (_a = runtime.assetResolver(asset, { size: size2, isExport })) != null ? _a : "";
}

// src/render/utils/imagePatternPropsForFill.tsx
function imagePatternPropsForFill(fill, frame2, id) {
  fill = Animatable.get(fill, "#09F");
  if (!BackgroundImage.isImageObject(fill))
    return void 0;
  if (!fill.pixelWidth || !fill.pixelHeight)
    return void 0;
  const imageWidth = fill.pixelWidth;
  const imageHeight = fill.pixelHeight;
  let transform2;
  const { fit } = fill;
  if (fit === "fill" || fit === "fit" || !fit) {
    let scaleX = 1;
    let scaleY = 1;
    let offsetX = 0;
    let offsetY = 0;
    const imageRatio = imageWidth / imageHeight;
    const realWidth = frame2.height * imageRatio;
    const realHeight = frame2.width / imageRatio;
    const validScaleX = realWidth / frame2.width;
    const validScaleY = realHeight / frame2.height;
    if (fit === "fill" || !fit ? validScaleY > validScaleX : validScaleY < validScaleX) {
      scaleY = validScaleY;
      offsetY = (1 - validScaleY) / 2;
    } else {
      scaleX = validScaleX;
      offsetX = (1 - validScaleX) / 2;
    }
    transform2 = `translate(${offsetX}, ${offsetY}) scale(${scaleX}, ${scaleY})`;
  }
  const imageId = `id${id}g${"-fillImage"}`;
  return { id: imageId, path: fill.src, transform: transform2 };
}

// src/render/componentLoader/definition.ts
function isDesignDefinition(d) {
  return d.type === "master";
}
function isOverride(d) {
  return d.type === "override";
}
function isReactDefinition(d) {
  return d.type !== "master";
}

// src/render/componentLoader/package.ts
var localPackageFallbackIdentifier = "|local|";

// src/render/utils/annotateTypeOnStringify.ts
function annotateTypeOnStringify(ctor, typeName) {
  const existingToJSON = ctor.prototype.toJSON;
  ctor.prototype.toJSON = function() {
    const base = existingToJSON ? existingToJSON.apply(this) : this;
    return Object.assign({}, base, { __type__: typeName });
  };
  return ctor;
}
function isOfAnnotatedType(object, typeName) {
  return object && object.__type__ && object.__type__ === typeName;
}

// src/render/types/PathSegment.ts
var PathSegment = class {
  constructor(value) {
    this.__class = "PathSegment";
    this.x = 0;
    this.y = 0;
    this.handleMirroring = "straight";
    this.handleOutX = 0;
    this.handleOutY = 0;
    this.handleInX = 0;
    this.handleInY = 0;
    this.radius = 0;
    if (value) {
      Object.assign(this, value);
    }
  }
  merge(value) {
    return Object.assign(Object.create(Object.getPrototypeOf(this)), this, value);
  }
};
PathSegment.displayName = "WithClassDiscriminatorMixin(PathSegment)";
PathSegment.prototype.__class = "PathSegment";
(function(PathSegment2) {
  PathSegment2.point = (pathSegment) => {
    return { x: pathSegment.x, y: pathSegment.y };
  };
  PathSegment2.handleOut = (pathSegment) => {
    return { x: pathSegment.handleOutX, y: pathSegment.handleOutY };
  };
  PathSegment2.handleIn = (pathSegment) => {
    return { x: pathSegment.handleInX, y: pathSegment.handleInY };
  };
  PathSegment2.calculatedHandleOut = (pathSegment) => {
    switch (pathSegment.handleMirroring) {
      case "symmetric":
      case "disconnected":
      case "asymmetric":
        return Point.add(PathSegment2.point(pathSegment), PathSegment2.handleOut(pathSegment));
      default:
        return { x: pathSegment.x, y: pathSegment.y };
    }
  };
  PathSegment2.calculatedHandleIn = (pathSegment) => {
    switch (pathSegment.handleMirroring) {
      case "symmetric":
        return Point.subtract(PathSegment2.point(pathSegment), PathSegment2.handleOut(pathSegment));
      case "disconnected":
      case "asymmetric":
        return Point.add(PathSegment2.point(pathSegment), PathSegment2.handleIn(pathSegment));
      default:
        return PathSegment2.point(pathSegment);
    }
  };
  PathSegment2.curveDefault = (points, index) => {
    if (points.length > 2) {
      let pointBefore;
      let pointAfter;
      if (index === 0) {
        pointBefore = points[points.length - 1];
      } else {
        pointBefore = points[index - 1];
      }
      if (index === points.length - 1) {
        pointAfter = points[0];
      } else {
        pointAfter = points[index + 1];
      }
      const delta2 = Point.subtract(PathSegment2.point(pointAfter), PathSegment2.point(pointBefore));
      return { x: delta2.x / 4, y: delta2.y / 4 };
    }
    return { x: 10, y: 10 };
  };
})(PathSegment || (PathSegment = {}));

// src/render/traits/Path.ts
var key5 = "pathSegments";
function withPath(target) {
  return key5 in target;
}
var pathDefaults = {
  pathSegments: [],
  pathClosed: false
};
function toSVGPath(withPaths, translate = { x: 0, y: 0 }, canvasMode = RenderTarget.canvas) {
  let pathElements = [];
  let paths = [];
  if (Array.isArray(withPaths)) {
    paths = withPaths;
  } else {
    paths = [withPaths];
  }
  paths.forEach((path, index) => {
    const { pathClosed, pathSegments } = path;
    const segmentCount = pathSegments.length;
    if (segmentCount === 0)
      return "";
    for (let i = 0; i < segmentCount; i++) {
      const segment = pathSegments[i];
      let nextSegment;
      let prevSegment;
      const isFirstSegment = i === 0;
      const isLastSegment = i === segmentCount - 1;
      if (!isLastSegment) {
        nextSegment = pathSegments[i + 1];
      } else if (pathClosed) {
        nextSegment = pathSegments[0];
      }
      if (!isFirstSegment) {
        prevSegment = pathSegments[i - 1];
      } else if (pathClosed) {
        prevSegment = pathSegments[segmentCount - 1];
      }
      if (i === 0) {
        pathElements.push("M");
      } else if (prevSegment && isStraightCurve(prevSegment, segment)) {
        pathElements.push("L");
      }
      pathElements.push(segment.x + translate.x, segment.y + translate.y);
      if (nextSegment && !isStraightCurve(segment, nextSegment)) {
        const handleOut = PathSegment.calculatedHandleOut(segment);
        const handleIn = PathSegment.calculatedHandleIn(nextSegment);
        pathElements.push("C", handleOut.x + translate.x, handleOut.y + translate.y, handleIn.x + translate.x, handleIn.y + translate.y);
      }
      if (isLastSegment && nextSegment) {
        if (isStraightCurve(segment, nextSegment)) {
          pathElements.push("Z");
        } else {
          pathElements.push(nextSegment.x + translate.x, nextSegment.y + translate.y, "Z");
        }
      }
    }
  });
  if (canvasMode === RenderTarget.export || canvasMode === RenderTarget.preview) {
    pathElements = pathElements.map((value) => isFiniteNumber(value) ? roundedNumberString(value, 3) : value);
  }
  return pathElements.join(" ");
}
function isStraightCurve(fromSegment, toSegment) {
  const fromStraight = fromSegment.handleMirroring === "straight" || fromSegment.handleOutX === 0 && fromSegment.handleOutY === 0;
  const toStraight = toSegment.handleMirroring === "straight" || toSegment.handleInX === 0 && toSegment.handleInY === 0;
  return fromStraight && toStraight;
}

// src/render/types/Size.ts
function Size(width, height) {
  return { width, height };
}
(function(Size2) {
  Size2.equals = (sizeA, sizeB) => {
    if (sizeA === sizeB)
      return true;
    if (!sizeA || !sizeB)
      return false;
    return sizeA.width === sizeB.width && sizeA.height === sizeB.height;
  };
  Size2.update = (fromSize, toSize, keepAspectRatio = false) => {
    let { width, height } = fromSize;
    const sizeRatio = width / height;
    width = toSize.width !== void 0 ? toSize.width : width;
    height = toSize.height !== void 0 ? toSize.height : height;
    if (keepAspectRatio) {
      if (toSize.width === void 0 && toSize.height !== void 0) {
        width = toSize.height * sizeRatio;
      }
      if (toSize.width !== void 0 && toSize.height === void 0 && sizeRatio !== 0) {
        height = toSize.width / sizeRatio;
      }
    }
    return { width, height };
  };
  function subtract(sizeA, sizeB) {
    return {
      width: Math.max(0, sizeA.width - sizeB.width),
      height: Math.max(0, sizeA.height - sizeB.height)
    };
  }
  Size2.subtract = subtract;
  Size2.zero = Size2(0, 0);
  Size2.isZero = function(size2) {
    return size2 === Size2.zero || size2.width === 0 && size2.height === 0;
  };
  Size2.defaultIfZero = function(width, height, size2) {
    if (Size2.isZero(size2)) {
      return Size2(width, height);
    }
    return size2;
  };
})(Size || (Size = {}));

// src/render/types/Line.ts
function Line(a2, b2) {
  return { a: a2, b: b2 };
}
(function(Line2) {
  function intersection(lineA, lineB) {
    const x1 = lineA.a.x;
    const y1 = lineA.a.y;
    const x2 = lineA.b.x;
    const y2 = lineA.b.y;
    const x3 = lineB.a.x;
    const y3 = lineB.a.y;
    const x4 = lineB.b.x;
    const y4 = lineB.b.y;
    const d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (d === 0) {
      return null;
    }
    const xi = ((x3 - x4) * (x1 * y2 - y1 * x2) - (x1 - x2) * (x3 * y4 - y3 * x4)) / d;
    const yi = ((y3 - y4) * (x1 * y2 - y1 * x2) - (y1 - y2) * (x3 * y4 - y3 * x4)) / d;
    return { x: xi, y: yi };
  }
  Line2.intersection = intersection;
  Line2.isOrthogonal = (line) => {
    return line.a.x === line.b.x || line.a.y === line.b.y;
  };
  Line2.perpendicular = (line, pointOnLine) => {
    const deltaX = line.a.x - line.b.x;
    const deltaY = line.a.y - line.b.y;
    const pointB = Point(pointOnLine.x - deltaY, pointOnLine.y + deltaX);
    return Line2(pointB, pointOnLine);
  };
  function projectPoint(line, point) {
    const perp = Line2.perpendicular(line, point);
    return intersection(line, perp);
  }
  Line2.projectPoint = projectPoint;
})(Line || (Line = {}));

// src/render/presentation/Image.tsx
import {
  createElement as createElement37
} from "react";
import { forwardRef as forwardRef9 } from "react";
var Image2 = forwardRef9(function Image3(props, ref) {
  const { background, children, ...rest } = props;
  const style = { ...rest.style };
  if (background) {
    delete style.background;
  }
  return /* @__PURE__ */ createElement37(motion.div, {
    ...rest,
    style,
    ref
  }, background && background.src ? /* @__PURE__ */ createElement37(BackgroundImageComponent, {
    image: background
  }) : null, children);
});

// src/render/presentation/SVG.tsx
import {
  Fragment as Fragment7,
  createElement as createElement39,
  createRef as createRef3,
  useRef as useRef22
} from "react";

// src/render/presentation/ImagePatternElement.tsx
import {
  Component as Component14,
  createElement as createElement38
} from "react";
var ImagePatternElement = class extends Component14 {
  render() {
    const { id, path, transform: transform2 } = this.props;
    const xlinkHref = imageUrlForAsset(path);
    return /* @__PURE__ */ createElement38("pattern", {
      id,
      width: "100%",
      height: "100%",
      patternContentUnits: "objectBoundingBox"
    }, /* @__PURE__ */ createElement38("image", {
      key: xlinkHref,
      width: 1,
      height: 1,
      xlinkHref,
      preserveAspectRatio: "none",
      transform: transform2
    }));
  }
};

// src/render/presentation/SVG.tsx
function SVG(props) {
  const parentSize = useParentSize();
  const layoutId = useLayoutId2(props);
  const layoutRef = useRef22(null);
  useMeasureLayout(props, layoutRef);
  return /* @__PURE__ */ createElement39(SVGComponent, {
    ...props,
    innerRef: layoutRef,
    parentSize,
    layoutId
  });
}
function sizeSVG(container, props) {
  var _a, _b;
  const div = container.current;
  if (!div)
    return;
  const { withExternalLayout, parentSize } = props;
  const canUseCalculatedOnCanvasSize = !withExternalLayout && constraintsEnabled(props) && parentSize !== ParentSizeState.Disabled && parentSize !== ParentSizeState.DisabledForCurrentLevel;
  if (canUseCalculatedOnCanvasSize)
    return;
  const svg = div.firstElementChild;
  if (!svg || !(svg instanceof SVGSVGElement)) {
    return;
  }
  const { intrinsicWidth, intrinsicHeight, _constraints } = props;
  if (((_a = svg.viewBox.baseVal) == null ? void 0 : _a.width) === 0 && ((_b = svg.viewBox.baseVal) == null ? void 0 : _b.height) === 0 && isFiniteNumber(intrinsicWidth) && isFiniteNumber(intrinsicHeight)) {
    svg.setAttribute("viewBox", `0 0 ${intrinsicWidth} ${intrinsicHeight}`);
  }
  if (_constraints && _constraints.aspectRatio) {
    svg.setAttribute("preserveAspectRatio", "");
  } else {
    svg.setAttribute("preserveAspectRatio", "none");
  }
  svg.setAttribute("width", "100%");
  svg.setAttribute("height", "100%");
}
var _SVGComponent = class extends Layer {
  constructor() {
    super(...arguments);
    this.container = createRef3();
    this.svgElement = createRef3();
  }
  static frame(props) {
    return calculateRect(props, props.parentSize || ParentSizeState.Unknown);
  }
  getPrefixedSVG(svg, id) {
    if (this.previouslyPrefixedSVG && svg === this.previouslyPrefixedSVG.svg && id === this.previouslyPrefixedSVG.id) {
      return this.previouslyPrefixedSVGResult;
    }
    const prefixedSVG = prefixIdsInSVG(svg, id);
    this.previouslyPrefixedSVGResult = prefixedSVG;
    this.previouslyPrefixedSVG = { svg, id };
    return prefixedSVG;
  }
  get frame() {
    return calculateRect(this.props, this.props.parentSize || ParentSizeState.Unknown);
  }
  componentDidMount() {
    sizeSVG(this.container, this.props);
  }
  componentDidUpdate(prevProps) {
    super.componentDidUpdate(prevProps);
    const { fill } = this.props;
    if (BackgroundImage.isImageObject(fill) && BackgroundImage.isImageObject(prevProps.fill) && fill.src !== prevProps.fill.src) {
      resetSetStyle(this.svgElement.current, "fill", null, false);
    }
    sizeSVG(this.container, this.props);
  }
  collectLayout(style, innerStyle) {
    if (this.props.withExternalLayout) {
      innerStyle.width = innerStyle.height = "inherit";
      return;
    }
    const frame2 = this.frame;
    const { rotation, intrinsicWidth, intrinsicHeight, width, height } = this.props;
    const rotate = Animatable.getNumber(rotation);
    style.opacity = isFiniteNumber(this.props.opacity) ? this.props.opacity : 1;
    if (RenderTarget.hasRestrictions() && frame2) {
      Object.assign(style, {
        transform: `translate(${frame2.x}px, ${frame2.y}px) rotate(${rotate.toFixed(4)}deg)`,
        width: `${frame2.width}px`,
        height: `${frame2.height}px`
      });
      if (constraintsEnabled(this.props)) {
        style.position = "absolute";
      }
      const xFactor = frame2.width / (intrinsicWidth || 1);
      const yFactor = frame2.height / (intrinsicHeight || 1);
      innerStyle.transformOrigin = "top left";
      const { zoom, target } = RenderEnvironment;
      if (target === RenderTarget.export) {
        const zoomFactor = zoom > 1 ? zoom : 1;
        innerStyle.transform = `scale(${xFactor * zoomFactor}, ${yFactor * zoomFactor})`;
        innerStyle.zoom = 1 / zoomFactor;
      } else {
        innerStyle.transform = `scale(${xFactor}, ${yFactor})`;
      }
      if (intrinsicWidth && intrinsicHeight) {
        innerStyle.width = intrinsicWidth;
        innerStyle.height = intrinsicHeight;
      }
    } else {
      const { left, right, top, bottom } = this.props;
      Object.assign(style, {
        left,
        right,
        top,
        bottom,
        width,
        height,
        rotate
      });
      Object.assign(innerStyle, {
        left: 0,
        top: 0,
        bottom: 0,
        right: 0,
        position: "absolute"
      });
    }
  }
  render() {
    var _a;
    if (safeWindow["perf"])
      safeWindow["perf"].nodeRender();
    const {
      id,
      visible,
      style,
      fill,
      svg,
      intrinsicHeight,
      intrinsicWidth,
      layoutId,
      className,
      variants,
      transition,
      withExternalLayout,
      innerRef
    } = this.props;
    if (!withExternalLayout && (!visible || !id))
      return null;
    const identifier = (_a = id != null ? id : layoutId) != null ? _a : "svg";
    injectComponentCSSRules();
    const frame2 = this.frame;
    const size2 = frame2 || { width: intrinsicWidth || 100, height: intrinsicHeight || 100 };
    const outerStyle = { ...style, imageRendering: "pixelated" };
    const innerStyle = {};
    this.collectLayout(outerStyle, innerStyle);
    collectOpacityFromProps(this.props, outerStyle);
    collectFiltersFromProps(this.props, outerStyle);
    Layer.applyWillChange(this.props, outerStyle, false);
    let fillElement = null;
    if (typeof fill === "string" || Color.isColorObject(fill)) {
      const fillColor = Color.isColorObject(fill) ? fill.initialValue || Color.toRgbString(fill) : fill;
      outerStyle.fill = fillColor;
      outerStyle.color = fillColor;
    } else if (LinearGradient.isLinearGradient(fill)) {
      const gradient = fill;
      const gradientId = `${encodeURI(id || "")}g${LinearGradient.hash(gradient)}`;
      outerStyle.fill = `url(#${gradientId})`;
      const elementProperties = elementPropertiesForLinearGradient(gradient, identifier);
      fillElement = /* @__PURE__ */ createElement39("svg", {
        ref: this.svgElement,
        xmlns: "http://www.w3.org/2000/svg",
        width: "100%",
        height: "100%",
        style: { position: "absolute" }
      }, /* @__PURE__ */ createElement39("linearGradient", {
        id: gradientId,
        gradientTransform: `rotate(${elementProperties.angle}, 0.5, 0.5)`
      }, elementProperties.stops.map((stop, idx) => {
        return /* @__PURE__ */ createElement39("stop", {
          key: idx,
          offset: stop.position,
          stopColor: stop.color,
          stopOpacity: stop.alpha
        });
      })));
    } else if (RadialGradient.isRadialGradient(fill)) {
      const gradient = fill;
      const gradientId = `${encodeURI(id || "")}g${RadialGradient.hash(gradient)}`;
      outerStyle.fill = `url(#${gradientId})`;
      const elementProperties = elementPropertiesForRadialGradient(gradient, identifier);
      fillElement = /* @__PURE__ */ createElement39("svg", {
        ref: this.svgElement,
        xmlns: "http://www.w3.org/2000/svg",
        width: "100%",
        height: "100%",
        style: { position: "absolute" }
      }, /* @__PURE__ */ createElement39("radialGradient", {
        id: gradientId,
        cy: gradient.centerAnchorY,
        cx: gradient.centerAnchorX,
        r: gradient.widthFactor
      }, elementProperties.stops.map((stop, idx) => {
        return /* @__PURE__ */ createElement39("stop", {
          key: idx,
          offset: stop.position,
          stopColor: stop.color,
          stopOpacity: stop.alpha
        });
      })));
    } else if (BackgroundImage.isImageObject(fill)) {
      const imagePattern = imagePatternPropsForFill(fill, size2, identifier);
      if (imagePattern) {
        outerStyle.fill = `url(#${imagePattern.id})`;
        fillElement = /* @__PURE__ */ createElement39("svg", {
          ref: this.svgElement,
          xmlns: "http://www.w3.org/2000/svg",
          xmlnsXlink: "http://www.w3.org/1999/xlink",
          width: "100%",
          height: "100%",
          style: { position: "absolute" }
        }, /* @__PURE__ */ createElement39("defs", null, /* @__PURE__ */ createElement39(ImagePatternElement, {
          ...imagePattern
        })));
      }
    }
    const dataProps = {
      "data-framer-component-type": "SVG"
    };
    const hasTransformTemplate = !frame2;
    if (hasTransformTemplate) {
      Object.assign(dataProps, layoutHintDataPropsForCenter(this.props.center));
    }
    const content = /* @__PURE__ */ createElement39(Fragment7, null, fillElement, /* @__PURE__ */ createElement39("div", {
      key: BackgroundImage.isImageObject(fill) ? fill.src : "",
      className: "svgContainer",
      style: innerStyle,
      ref: this.container,
      dangerouslySetInnerHTML: { __html: this.getPrefixedSVG(svg, identifier) }
    }));
    return /* @__PURE__ */ createElement39(motion.div, {
      ...dataProps,
      layoutId,
      transformTemplate: hasTransformTemplate ? transformTemplate(this.props.center) : void 0,
      id,
      ref: innerRef,
      style: outerStyle,
      className,
      variants,
      transition
    }, content);
  }
};
var SVGComponent = _SVGComponent;
SVGComponent.supportsConstraints = true;
SVGComponent.defaultSVGProps = {
  left: void 0,
  right: void 0,
  top: void 0,
  bottom: void 0,
  style: void 0,
  _constraints: {
    enabled: true,
    aspectRatio: null
  },
  parentSize: ParentSizeState.Unknown,
  rotation: 0,
  visible: true,
  svg: "",
  shadows: []
};
SVGComponent.defaultProps = {
  ...Layer.defaultProps,
  ..._SVGComponent.defaultSVGProps
};
function prefixIdsInSVG(svg, prefix) {
  const domParser = new DOMParser();
  try {
    const doc = domParser.parseFromString(svg, "image/svg+xml");
    const el = doc.getElementsByTagName("svg")[0];
    if (!el)
      return svg;
    const sanitizedPrefix = sanitizeString(prefix);
    recursivelyPrefixId(el, sanitizedPrefix);
    return el.outerHTML;
  } catch (error) {
    throw Error(`Failed to parse SVG: ${error}`);
  }
}
function sanitizeString(str) {
  return str.replace(/[^a-z0-9\-_:.]|^[^a-z]+/gi, "");
}
function recursivelyPrefixId(el, prefix) {
  prefixId(el, prefix);
  const childNodes = Array.from(el.children);
  childNodes.forEach((node) => {
    recursivelyPrefixId(node, prefix);
  });
}
function prefixId(el, prefix) {
  const attributes = el.getAttributeNames();
  attributes.forEach((attr) => {
    const value = el.getAttribute(attr);
    if (!value)
      return;
    if (attr === "id") {
      el.setAttribute(attr, `${prefix}_${value}`);
    }
    if (attr === "href" || attr === "xlink:href") {
      const [base, fragmentIdentifier] = value.split("#");
      if (base)
        return;
      el.setAttribute(attr, `#${prefix}_${fragmentIdentifier}`);
      return;
    }
    const URL_REF = "url(#";
    if (value.includes(URL_REF)) {
      const prefixedValue = value.replace(URL_REF, `${URL_REF}${prefix}_`);
      el.setAttribute(attr, prefixedValue);
    }
  });
}

// src/render/presentation/Text.tsx
import {
  createElement as createElement40
} from "react";
import { useRef as useRef23, useEffect as useEffect22 } from "react";

// src/render/fonts/fonts.ts
function convertToObject(descriptors) {
  return Object.fromEntries(descriptors.map((descriptor) => [
    descriptor[0],
    Object.fromEntries(descriptor[1].map((member) => [
      member[0],
      {
        selector: member[1],
        weight: member[2]
      }
    ]))
  ]));
}
var safeFonts = {
  Arial: {
    Regular: { selector: "Arial", weight: void 0 },
    Black: { selector: "Arial-Black", weight: void 0 },
    Narrow: { selector: "Arial Narrow", weight: void 0 },
    "Rounded Bold": { selector: "Arial Rounded MT Bold", weight: void 0 }
  },
  Avenir: {
    Book: { selector: "Avenir", weight: void 0 },
    Light: { selector: "Avenir-Light", weight: void 0 },
    Medium: { selector: "Avenir-Medium", weight: void 0 },
    Heavy: { selector: "Avenir-Heavy", weight: void 0 },
    Black: { selector: "Avenir-Black", weight: void 0 }
  },
  "Avenir Next": {
    Regular: { selector: "Avenir Next", weight: void 0 },
    "Ultra Light": { selector: "AvenirNext-UltraLight", weight: void 0 },
    Medium: { selector: "AvenirNext-Medium", weight: void 0 },
    "Demi Bold": { selector: "AvenirNext-DemiBold", weight: void 0 },
    Heavy: { selector: "AvenirNext-Heavy", weight: void 0 }
  },
  "Avenir Next Condensed": {
    Regular: { selector: "Avenir Next Condensed", weight: void 0 },
    "Ultra Light": { selector: "AvenirNextCondensed-UltraLight", weight: void 0 },
    Medium: { selector: "AvenirNextCondensed-Medium", weight: void 0 },
    "Demi Bold": { selector: "AvenirNextCondensed-DemiBold", weight: void 0 },
    Heavy: { selector: "AvenirNextCondensed-Heavy", weight: void 0 }
  },
  Baskerville: {
    Regular: { selector: "Baskerville", weight: void 0 },
    "Semi Bold": { selector: "Baskerville-SemiBold", weight: void 0 }
  },
  "Bodoni 72": {
    Book: { selector: "Bodoni 72", weight: void 0 },
    Oldstyle: { selector: "Bodoni 72 Oldstyle", weight: void 0 },
    Smallcaps: { selector: "Bodoni 72 Smallcaps", weight: void 0 }
  },
  Courier: { Regular: { selector: "Courier", weight: void 0 } },
  "Courier New": { Regular: { selector: "Courier New", weight: void 0 } },
  Futura: {
    Medium: { selector: "Futura", weight: void 0 },
    Condensed: { selector: "Futura-CondensedMedium", weight: void 0 },
    "Condensed ExtraBold": { selector: "Futura-CondensedExtraBold", weight: void 0 }
  },
  Georgia: { Regular: { selector: "Georgia", weight: void 0 } },
  "Gill Sans": {
    Regular: { selector: "Gill Sans", weight: void 0 },
    Light: { selector: "GillSans-Light", weight: void 0 },
    SemiBold: { selector: "GillSans-SemiBold", weight: void 0 },
    UltraBold: { selector: "GillSans-UltraBold", weight: void 0 }
  },
  Helvetica: {
    Regular: { selector: "Helvetica", weight: void 0 },
    Light: { selector: "Helvetica-Light", weight: void 0 },
    Bold: { selector: "Helvetica-Bold", weight: void 0 },
    Oblique: { selector: "Helvetica-Oblique", weight: void 0 },
    "Light Oblique": { selector: "Helvetica-LightOblique", weight: void 0 },
    "Bold Oblique": { selector: "Helvetica-BoldOblique", weight: void 0 }
  },
  "Helvetica Neue": {
    Regular: { selector: "Helvetica Neue", weight: void 0 },
    UltraLight: { selector: "HelveticaNeue-UltraLight", weight: void 0 },
    Thin: { selector: "HelveticaNeue-Thin", weight: void 0 },
    Light: { selector: "HelveticaNeue-Light", weight: void 0 },
    Medium: { selector: "HelveticaNeue-Medium", weight: void 0 },
    Bold: { selector: "HelveticaNeue-Bold", weight: void 0 },
    Italic: { selector: "HelveticaNeue-Italic", weight: void 0 },
    "UltraLight Italic": { selector: "HelveticaNeue-UltraLightItalic", weight: void 0 },
    "Thin Italic": { selector: "HelveticaNeue-ThinItalic", weight: void 0 },
    "Light Italic": { selector: "HelveticaNeue-LightItalic", weight: void 0 },
    "Medium Italic": { selector: "HelveticaNeue-MediumItalic", weight: void 0 },
    "Bold Italic": { selector: "HelveticaNeue-BoldItalic", weight: void 0 },
    "Condensed Bold": { selector: "HelveticaNeue-CondensedBold", weight: void 0 },
    "Condensed Black": { selector: "HelveticaNeue-CondensedBlack", weight: void 0 }
  },
  "Hoefler Text": { Regular: { selector: "Hoefler Text", weight: void 0 } },
  Impact: { Regular: { selector: "Impact", weight: void 0 } },
  "Lucida Grande": { Regular: { selector: "Lucida Grande", weight: void 0 } },
  Menlo: { Regular: { selector: "Menlo", weight: void 0 } },
  Monaco: { Regular: { selector: "Monaco", weight: void 0 } },
  Optima: {
    Regular: { selector: "Optima", weight: void 0 },
    ExtraBlack: { selector: "Optima-ExtraBlack", weight: void 0 }
  },
  Palatino: { Regular: { selector: "Palatino", weight: void 0 } },
  "SF Pro Display": {
    Regular: { selector: "__SF-UI-Display-Regular__", weight: 400 },
    Ultralight: { selector: "__SF-UI-Display-Ultralight__", weight: 100 },
    Thin: { selector: "__SF-UI-Display-Thin__", weight: 200 },
    Light: { selector: "__SF-UI-Display-Light__", weight: 300 },
    Medium: { selector: "__SF-UI-Display-Medium__", weight: 500 },
    Semibold: { selector: "__SF-UI-Display-Semibold__", weight: 600 },
    Bold: { selector: "__SF-UI-Display-Bold__", weight: 700 },
    Heavy: { selector: "__SF-UI-Display-Heavy__", weight: 800 },
    Black: { selector: "__SF-UI-Display-Black__", weight: 900 },
    Italic: { selector: "__SF-UI-Display-Italic__", weight: 400 },
    "Ultralight Italic": { selector: "__SF-UI-Display-Ultralight-Italic__", weight: 100 },
    "Thin Italic": { selector: "__SF-UI-Display-Thin-Italic__", weight: 200 },
    "Light Italic": { selector: "__SF-UI-Display-Light-Italic__", weight: 300 },
    "Medium Italic": { selector: "__SF-UI-Display-Medium-Italic__", weight: 500 },
    "Semibold Italic": { selector: "__SF-UI-Display-Semibold-Italic__", weight: 600 },
    "Bold Italic": { selector: "__SF-UI-Display-Bold-Italic__", weight: 700 },
    "Heavy Italic": { selector: "__SF-UI-Display-Heavy-Italic__", weight: 800 },
    "Black Italic": { selector: "__SF-UI-Display-Black-Italic__", weight: 900 }
  },
  "SF Pro Display Condensed": {
    Regular: { selector: "__SF-UI-Display-Condensed-Regular__", weight: 400 },
    Ultralight: { selector: "__SF-UI-Display-Condensed-Ultralight__", weight: 100 },
    Thin: { selector: "__SF-UI-Display-Condensed-Thin__", weight: 200 },
    Light: { selector: "__SF-UI-Display-Condensed-Light__", weight: 300 },
    Medium: { selector: "__SF-UI-Display-Condensed-Medium__", weight: 500 },
    Semibold: { selector: "__SF-UI-Display-Condensed-Semibold__", weight: 600 },
    Bold: { selector: "__SF-UI-Display-Condensed-Bold__", weight: 700 },
    Heavy: { selector: "__SF-UI-Display-Condensed-Heavy__", weight: 800 },
    Black: { selector: "__SF-UI-Display-Condensed-Black__", weight: 900 }
  },
  "SF Pro Text": {
    Regular: { selector: "__SF-UI-Text-Regular__", weight: 400 },
    Light: { selector: "__SF-UI-Text-Light__", weight: 200 },
    Medium: { selector: "__SF-UI-Text-Medium__", weight: 500 },
    Semibold: { selector: "__SF-UI-Text-Semibold__", weight: 600 },
    Bold: { selector: "__SF-UI-Text-Bold__", weight: 700 },
    Heavy: { selector: "__SF-UI-Text-Heavy__", weight: 800 },
    Italic: { selector: "__SF-UI-Text-Italic__", weight: 400 },
    "Light Italic": { selector: "__SF-UI-Text-Light-Italic__", weight: 200 },
    "Medium Italic": { selector: "__SF-UI-Text-Medium-Italic__", weight: 500 },
    "Semibold Italic": { selector: "__SF-UI-Text-Semibold-Italic__", weight: 600 },
    "Bold Italic": { selector: "__SF-UI-Text-Bold-Italic__", weight: 700 },
    "Heavy Italic": { selector: "__SF-UI-Text-Heavy-Italic__", weight: 800 }
  },
  "SF Pro Text Condensed": {
    Regular: { selector: "__SF-UI-Text-Condensed-Regular__", weight: 400 },
    Light: { selector: "__SF-UI-Text-Condensed-Light__", weight: 200 },
    Medium: { selector: "__SF-UI-Text-Condensed-Medium__", weight: 500 },
    Semibold: { selector: "__SF-UI-Text-Condensed-Semibold__", weight: 600 },
    Bold: { selector: "__SF-UI-Text-Condensed-Bold__", weight: 700 },
    Heavy: { selector: "__SF-UI-Text-Condensed-Heavy__", weight: 800 }
  },
  Tahoma: { Regular: { selector: "Tahoma", weight: void 0 } },
  Times: { Regular: { selector: "Times", weight: void 0 } },
  "Times New Roman": { Regular: { selector: "Times New Roman", weight: void 0 } },
  Trebuchet: { Regular: { selector: "Trebuchet MS", weight: void 0 } },
  Verdana: { Regular: { selector: "Verdana", weight: void 0 } }
};
var typefaceAliases = {
  "__SF-Compact-Display-Regular__": "SFCompactDisplay-Regular|.SFCompactDisplay-Regular",
  "__SF-Compact-Display-Ultralight__": "SFCompactDisplay-Ultralight|.SFCompactDisplay-Ultralight",
  "__SF-Compact-Display-Thin__": "SFCompactDisplay-Thin|.SFCompactDisplay-Thin",
  "__SF-Compact-Display-Light__": "SFCompactDisplay-Light|.SFCompactDisplay-Light",
  "__SF-Compact-Display-Medium__": "SFCompactDisplay-Medium|.SFCompactDisplay-Medium",
  "__SF-Compact-Display-Semibold__": "SFCompactDisplay-Semibold|.SFCompactDisplay-Semibold",
  "__SF-Compact-Display-Heavy__": "SFCompactDisplay-Heavy|.SFCompactDisplay-Heavy",
  "__SF-Compact-Display-Black__": "SFCompactDisplay-Black|.SFCompactDisplay-Black",
  "__SF-Compact-Display-Bold__": "SFCompactDisplay-Bold|.SFCompactDisplay-Bold",
  "__SF-UI-Text-Regular__": ".SFNSText|SFProText-Regular|SFUIText-Regular|.SFUIText",
  "__SF-UI-Text-Light__": ".SFNSText-Light|SFProText-Light|SFUIText-Light|.SFUIText-Light",
  "__SF-UI-Text-Medium__": ".SFNSText-Medium|SFProText-Medium|SFUIText-Medium|.SFUIText-Medium",
  "__SF-UI-Text-Semibold__": ".SFNSText-Semibold|SFProText-Semibold|SFUIText-Semibold|.SFUIText-Semibold",
  "__SF-UI-Text-Bold__": ".SFNSText-Bold|SFProText-Bold|SFUIText-Bold|.SFUIText-Bold",
  "__SF-UI-Text-Heavy__": ".SFNSText-Heavy|SFProText-Heavy|.SFUIText-Heavy",
  "__SF-UI-Text-Italic__": ".SFNSText-Italic|SFProText-Italic|SFUIText-Italic|.SFUIText-Italic",
  "__SF-UI-Text-Light-Italic__": ".SFNSText-LightItalic|SFProText-LightItalic|SFUIText-LightItalic|.SFUIText-LightItalic",
  "__SF-UI-Text-Medium-Italic__": ".SFNSText-MediumItalic|SFProText-MediumItalic|SFUIText-MediumItalic|.SFUIText-MediumItalic",
  "__SF-UI-Text-Semibold-Italic__": ".SFNSText-SemiboldItalic|SFProText-SemiboldItalic|SFUIText-SemiboldItalic|.SFUIText-SemiboldItalic",
  "__SF-UI-Text-Bold-Italic__": ".SFNSText-BoldItalic|SFProText-BoldItalic|SFUIText-BoldItalic|.SFUIText-BoldItalic",
  "__SF-UI-Text-Heavy-Italic__": ".SFNSText-HeavyItalic|SFProText-HeavyItalic|.SFUIText-HeavyItalic",
  "__SF-Compact-Text-Regular__": "SFCompactText-Regular|.SFCompactText-Regular",
  "__SF-Compact-Text-Light__": "SFCompactText-Light|.SFCompactText-Light",
  "__SF-Compact-Text-Medium__": "SFCompactText-Medium|.SFCompactText-Medium",
  "__SF-Compact-Text-Semibold__": "SFCompactText-Semibold|.SFCompactText-Semibold",
  "__SF-Compact-Text-Bold__": "SFCompactText-Bold|.SFCompactText-Bold",
  "__SF-Compact-Text-Heavy__": "SFCompactText-Heavy|.SFCompactText-Heavy",
  "__SF-Compact-Text-Italic__": "SFCompactText-Italic|.SFCompactText-Italic",
  "__SF-Compact-Text-Light-Italic__": "SFCompactText-LightItalic|.SFCompactText-LightItalic",
  "__SF-Compact-Text-Medium-Italic__": "SFCompactText-MediumItalic|.SFCompactText-MediumItalic",
  "__SF-Compact-Text-Semibold-Italic__": "SFCompactText-SemiboldItalic|.SFCompactText-SemiboldItalic",
  "__SF-Compact-Text-Bold-Italic__": "SFCompactText-BoldItalic|.SFCompactText-BoldItalic",
  "__SF-Compact-Text-Heavy-Italic__": "SFCompactText-HeavyItalic|.SFCompactText-HeavyItalic",
  "__SF-UI-Display-Condensed-Regular__": ".SFNSDisplayCondensed-Regular|SFUIDisplayCondensed-Regular|.SFUIDisplayCondensed-Regular",
  "__SF-UI-Display-Condensed-Ultralight__": ".SFNSDisplayCondensed-Ultralight|SFUIDisplayCondensed-Ultralight|.SFUIDisplayCondensed-Ultralight",
  "__SF-UI-Display-Condensed-Thin__": ".SFNSDisplayCondensed-Thin|SFUIDisplayCondensed-Thin|.SFUIDisplayCondensed-Thin",
  "__SF-UI-Display-Condensed-Light__": ".SFNSDisplayCondensed-Light|SFUIDisplayCondensed-Light|.SFUIDisplayCondensed-Light",
  "__SF-UI-Display-Condensed-Medium__": ".SFNSDisplayCondensed-Medium|SFUIDisplayCondensed-Medium|.SFUIDisplayCondensed-Medium",
  "__SF-UI-Display-Condensed-Semibold__": ".SFNSDisplayCondensed-Semibold|SFUIDisplayCondensed-Semibold|.SFUIDisplayCondensed-Semibold",
  "__SF-UI-Display-Condensed-Bold__": ".SFNSDisplayCondensed-Bold|SFUIDisplayCondensed-Bold|.SFUIDisplayCondensed-Bold",
  "__SF-UI-Display-Condensed-Heavy__": ".SFNSDisplayCondensed-Heavy|SFUIDisplayCondensed-Heavy|.SFUIDisplayCondensed-Heavy",
  "__SF-UI-Display-Condensed-Black__": ".SFNSDisplayCondensed-Black|.SFUIDisplayCondensed-Black",
  "__SF-UI-Display-Regular__": ".SFNSDisplay|SFProDisplay-Regular|SFUIDisplay-Regular|.SFUIDisplay",
  "__SF-UI-Display-Ultralight__": ".SFNSDisplay-Ultralight|SFProDisplay-Ultralight|SFUIDisplay-Ultralight|.SFUIDisplay-Ultralight",
  "__SF-UI-Display-Thin__": ".SFNSDisplay-Thin|SFProDisplay-Thin|SFUIDisplay-Thin|.SFUIDisplay-Thin",
  "__SF-UI-Display-Light__": ".SFNSDisplay-Light|SFProDisplay-Light|SFUIDisplay-Light|.SFUIDisplay-Light",
  "__SF-UI-Display-Medium__": ".SFNSDisplay-Medium|SFProDisplay-Medium|SFUIDisplay-Medium|.SFUIDisplay-Medium",
  "__SF-UI-Display-Semibold__": ".SFNSDisplay-Semibold|SFProDisplay-Semibold|SFUIDisplay-Semibold|.SFUIDisplay-Semibold",
  "__SF-UI-Display-Bold__": ".SFNSDisplay-Bold|SFProDisplay-Bold|SFUIDisplay-Bold|.SFUIDisplay-Bold",
  "__SF-UI-Display-Heavy__": ".SFNSDisplay-Heavy|SFProDisplay-Heavy|SFUIDisplay-Heavy|.SFUIDisplay-Heavy",
  "__SF-UI-Display-Black__": ".SFNSDisplay-Black|SFProDisplay-Black|.SFUIDisplay-Black",
  "__SF-UI-Display-Italic__": ".SFNSDisplay-Italic|SFProDisplay-Italic|SFUIDisplay-Italic",
  "__SF-UI-Display-Ultralight-Italic__": ".SFNSDisplay-UltralightItalic|SFProDisplay-UltralightItalic|SFUIDisplay-UltralightItalic|.SFUIDisplay-UltralightItalic",
  "__SF-UI-Display-Thin-Italic__": ".SFNSDisplay-ThinItalic|SFProDisplay-ThinItalic|SFUIDisplay-ThinItalic|.SFUIDisplay-ThinItalic",
  "__SF-UI-Display-Light-Italic__": ".SFNSDisplay-LightItalic|SFProDisplay-LightItalic|SFUIDisplay-LightItalic|.SFUIDisplay-LightItalic",
  "__SF-UI-Display-Medium-Italic__": ".SFNSDisplay-MediumItalic|SFProDisplay-MediumItalic|SFUIDisplay-MediumItalic|.SFUIDisplay-MediumItalic",
  "__SF-UI-Display-Semibold-Italic__": ".SFNSDisplay-SemiboldItalic|SFProDisplay-SemiboldItalic|SFUIDisplay-SemiboldItalic|.SFUIDisplay-SemiboldItalic",
  "__SF-UI-Display-Bold-Italic__": ".SFNSDisplay-BoldItalic|SFProDisplay-BoldItalic|SFUIDisplay-BoldItalic|.SFUIDisplay-BoldItalic",
  "__SF-UI-Display-Heavy-Italic__": ".SFNSDisplay-HeavyItalic|SFProDisplay-HeavyItalic|SFUIDisplay-HeavyItalic|.SFUIDisplay-HeavyItalic",
  "__SF-UI-Display-Black-Italic__": ".SFNSDisplay-BlackItalic|SFProDisplay-BlackItalic|.SFUIDisplay-BlackItalic",
  "__SF-UI-Text-Condensed-Regular__": ".SFNSTextCondensed-Regular|SFUITextCondensed-Regular|.SFUITextCondensed-Regular",
  "__SF-UI-Text-Condensed-Light__": ".SFNSTextCondensed-Light|SFUITextCondensed-Light|.SFUITextCondensed-Light",
  "__SF-UI-Text-Condensed-Medium__": ".SFNSTextCondensed-Medium|SFUITextCondensed-Medium|.SFUITextCondensed-Medium",
  "__SF-UI-Text-Condensed-Semibold__": ".SFNSTextCondensed-Semibold|SFUITextCondensed-Semibold|.SFUITextCondensed-Semibold",
  "__SF-UI-Text-Condensed-Bold__": ".SFNSTextCondensed-Bold|SFUITextCondensed-Bold|.SFUITextCondensed-Bold",
  "__SF-UI-Text-Condensed-Heavy__": ".SFNSTextCondensed-Heavy|.SFUITextCondensed-Heavy",
  "__SF-Compact-Rounded-Regular__": "SFCompactRounded-Regular|.SFCompactRounded-Regular",
  "__SF-Compact-Rounded-Ultralight__": "SFCompactRounded-Ultralight|.SFCompactRounded-Ultralight",
  "__SF-Compact-Rounded-Thin__": "SFCompactRounded-Thin|.SFCompactRounded-Thin",
  "__SF-Compact-Rounded-Light__": "SFCompactRounded-Light|.SFCompactRounded-Light",
  "__SF-Compact-Rounded-Medium__": "SFCompactRounded-Medium|.SFCompactRounded-Medium",
  "__SF-Compact-Rounded-Semibold__": "SFCompactRounded-Semibold|.SFCompactRounded-Semibold",
  "__SF-Compact-Rounded-Bold__": "SFCompactRounded-Bold|.SFCompactRounded-Bold",
  "__SF-Compact-Rounded-Heavy__": "SFCompactRounded-Heavy|.SFCompactRounded-Heavy",
  "__SF-Compact-Rounded-Black__": "SFCompactRounded-Black|.SFCompactRounded-Black"
};
var typefaces = typeof safeWindow !== "undefined" && safeWindow["SystemTypefaceDescriptors"] !== void 0 ? convertToObject(safeWindow["SystemTypefaceDescriptors"]) : safeFonts;
var defaultFontSelector = typeof safeWindow !== "undefined" && typeof safeWindow["SystemTypefaceDefaultSelector"] === "string" ? safeWindow["SystemTypefaceDefaultSelector"] : "Inter";

// src/render/fonts/types.ts
var TypefaceSourceNames;
(function(TypefaceSourceNames2) {
  TypefaceSourceNames2["Google"] = "google";
  TypefaceSourceNames2["Local"] = "local";
  TypefaceSourceNames2["Custom"] = "custom";
})(TypefaceSourceNames || (TypefaceSourceNames = {}));

// src/render/fonts/GoogleFontSource.ts
var googleFontSelectorPrefix = "GF;";
var GoogleFontSource = class {
  constructor() {
    this.name = TypefaceSourceNames.Google;
    this.typefaces = [];
    this.byFamily = new Map();
  }
  getTypefaceByFamily(family) {
    var _a;
    return (_a = this.byFamily.get(family)) != null ? _a : null;
  }
  parseSelector(selector) {
    if (!selector.startsWith(googleFontSelectorPrefix))
      return null;
    const tokens = selector.split("-");
    if (tokens.length !== 2)
      return null;
    const family = tokens[0].replace(googleFontSelectorPrefix, "");
    const variant = tokens[1];
    return { family, variant, source: this.name };
  }
  createTypeface(family) {
    const typeface = { family, fonts: [], source: this.name };
    this.addTypeface(typeface);
    return typeface;
  }
  addTypeface(typeface) {
    this.typefaces.push(typeface);
    this.byFamily.set(typeface.family, typeface);
  }
  importFonts(webFonts) {
    let fontLocators = [];
    webFonts.forEach((webFont) => {
      const locators = webFont.variants.map((variant) => ({
        source: this.name,
        variant,
        family: webFont.family,
        file: webFont.files[variant].replace("http://", "https://")
      }));
      fontLocators = fontLocators.concat(locators);
    });
    return fontLocators;
  }
};

// src/render/fonts/LocalFontSource.ts
var systemTypefaceName = "System Default";
var LocalFontSource = class {
  constructor() {
    this.name = TypefaceSourceNames.Local;
    this.typefaces = [];
    this.byFamily = new Map();
    this.typefaceAliasBySelector = new Map();
    this.typefaceAliases = new Map();
    this.interTypefaceSelectors = new Set();
  }
  getTypefaceByFamily(family) {
    var _a;
    return (_a = this.byFamily.get(family)) != null ? _a : null;
  }
  createTypeface(family) {
    const typeface = { family, fonts: [], source: this.name };
    this.addTypeface(typeface);
    return typeface;
  }
  addTypeface(typeface) {
    this.typefaces.push(typeface);
    this.byFamily.set(typeface.family, typeface);
  }
  importFonts() {
    const fonts = [];
    for (const family of Object.keys(typefaces)) {
      const members = typefaces[family];
      if (!members)
        continue;
      const typeface = this.createTypeface(family);
      for (const variant of Object.keys(members)) {
        const member = members[variant];
        if (!member)
          continue;
        const { selector, weight } = member;
        const font = {
          variant,
          selector,
          weight,
          typeface,
          status: "loaded"
        };
        typeface.fonts.push(font);
      }
      fonts.push(...typeface.fonts);
    }
    for (const [key6, value] of Object.entries(typefaceAliases)) {
      this.addTypefaceAlias(key6, value);
    }
    const { typeface: systemTypeface, aliases } = this.getSystemTypeface();
    this.addTypeface(systemTypeface);
    for (const [key6, value] of aliases) {
      this.addTypefaceAlias(key6, value);
    }
    fonts.push(...systemTypeface.fonts);
    const interTypeface = this.importInterTypeface();
    fonts.push(...interTypeface.fonts);
    return fonts;
  }
  importInterTypeface() {
    const inter = [
      ["Regular", "Inter", void 0],
      ["Thin", "Inter-Thin", 100],
      ["Extra Light", "Inter-ExtraLight", 200],
      ["Light", "Inter-Light", 300],
      ["Medium", "Inter-Medium", 500],
      ["Semibold", "Inter-SemiBold", 600],
      ["Bold", "Inter-Bold", 700],
      ["Extra Bold", "Inter-ExtraBold", 800],
      ["Black", "Inter-Black", 900],
      ["Thin Italic", "Inter-ThinItalic", 100],
      ["Extra Light Italic", "Inter-ExtraLightItalic", 300],
      ["Light Italic", "Inter-LightItalic", 300],
      ["Italic", "Inter-Italic", void 0],
      ["Medium Italic", "Inter-MediumItalic", 500],
      ["Semibold Italic", "Inter-SemiBoldItalic", 600],
      ["Bold Italic", "Inter-BoldItalic", 700],
      ["Extra Bold Italic", "Inter-ExtraBoldItalic", 800],
      ["Black Italic", "Inter-BlackItalic", 900]
    ];
    const typeface = this.createTypeface("Inter");
    for (const entry of inter) {
      const [variant, selector, weight] = entry;
      const font = {
        variant,
        selector,
        weight,
        typeface,
        style: /italic/i.test(selector) ? "italic" : void 0
      };
      typeface.fonts.push(font);
    }
    typeface.fonts.forEach((t) => this.interTypefaceSelectors.add(t.selector));
    return typeface;
  }
  addTypefaceAlias(key6, value) {
    this.typefaceAliases.set(key6, value);
    this.typefaceAliasBySelector.set(value, key6);
  }
  getSystemTypeface() {
    const fontFamilies = this.workaroundChrome81and82("system-ui|-apple-system|BlinkMacSystemFont|Segoe UI|Roboto|Oxygen|Ubuntu|Cantarell|Fira Sans|Droid Sans|Helvetica Neue|sans-serif");
    const typeface = { family: systemTypefaceName, fonts: [], source: this.name };
    const aliases = new Map();
    const weights = [400, 100, 200, 300, 500, 600, 700, 800, 900];
    const styles = ["normal", "italic"];
    for (const style of styles) {
      for (const weight of weights) {
        const variant = createVariantName(weight, style);
        const alias = `__SystemDefault-${weight}-${style}__`;
        const font = {
          variant,
          selector: alias,
          style: style === "normal" ? void 0 : style,
          weight: weight === 400 ? void 0 : weight,
          typeface,
          status: "loaded"
        };
        typeface.fonts.push(font);
        aliases.set(alias, fontFamilies);
      }
    }
    return { typeface, aliases };
  }
  getTypefaceAliasBySelector(selector) {
    return this.typefaceAliasBySelector.get(selector) || null;
  }
  getTypefaceSelectorByAlias(alias) {
    return this.typefaceAliases.get(alias) || null;
  }
  isTypefaceAlias(value) {
    if (value && value.match(/^__.*__$/))
      return true;
    return false;
  }
  workaroundChrome81and82(s) {
    const userAgent = navigator.userAgent;
    if (!userAgent.includes("Mac OS X 10_15"))
      return s;
    if (!userAgent.includes("Chrome/81") && !userAgent.includes("Chrome/82"))
      return s;
    return `Inter|${s}`;
  }
};
var fontWeightNames = {
  "100": "Thin",
  "200": "Extra Light",
  "300": "Light",
  "400": "Normal",
  "500": "Medium",
  "600": "Semi Bold",
  "700": "Bold",
  "800": "Extra Bold",
  "900": "Black"
};
function createVariantName(weight, style) {
  const friendlyStyle = style === "normal" ? "Regular" : "Italic";
  if (weight === 400) {
    return friendlyStyle;
  }
  if (style !== "normal") {
    return `${fontWeightNames[weight]} ${friendlyStyle}`;
  }
  return `${fontWeightNames[weight]}`;
}

// src/render/fonts/utils.ts
function parseVariant(variant) {
  if (variant === "regular")
    return { style: "normal", weight: 400 };
  const res = /([0-9]*)([a-z]*)/.exec(variant);
  if (!res)
    return null;
  const weight = parseInt(res[1] || "400");
  const style = res[2] || "normal";
  return { weight, style };
}

// src/render/fonts/CustomFontSource.ts
var customFontSelectorPrefix = "CUSTOM;";
function getCustomFontName(fileName, properties) {
  if (!properties)
    return fileName.substring(0, fileName.lastIndexOf("."));
  const fontFamily = properties.font.preferredFamily === "" ? properties.font.fontFamily : properties.font.preferredFamily;
  const variant = properties.font.preferredSubFamily === "" ? properties.font.fontSubFamily : properties.font.preferredSubFamily;
  return `${fontFamily} ${variant}`;
}
var CustomFontSource = class {
  constructor() {
    this.name = TypefaceSourceNames.Custom;
    this.typefaces = [];
    this.byFamily = new Map();
    this.assetsByFamily = new Map();
  }
  importFonts(assets) {
    this.typefaces.length = 0;
    this.byFamily.clear();
    this.assetsByFamily.clear();
    const fonts = [];
    assets.forEach((asset) => {
      var _a;
      if (!this.isValidCustomFontAsset(asset)) {
        return;
      }
      const fontName = getCustomFontName(asset.name, asset.properties);
      const typeface = this.createTypeface(fontName);
      const font = {
        typeface,
        selector: `${customFontSelectorPrefix}${fontName}`,
        variant: this.inferVariantName(fontName),
        postscriptName: (_a = asset.properties) == null ? void 0 : _a.font.postscriptName,
        file: asset.url
      };
      typeface.fonts.push(font);
      typeface.owner = asset.ownerType === "team" ? "team" : "project";
      this.assetsByFamily.set(fontName, asset);
      fonts.push(...typeface.fonts);
    });
    return fonts;
  }
  isValidCustomFontAsset(asset) {
    var _a, _b;
    return asset.mimeType.startsWith("font/") && asset.properties && "font" in asset.properties && ((_a = asset.properties) == null ? void 0 : _a.kind) === "font" && "fontFamily" in ((_b = asset.properties) == null ? void 0 : _b.font);
  }
  inferVariantName(family) {
    const possibleValues = [
      "thin",
      "ultra light",
      "extra light",
      "light",
      "normal",
      "medium",
      "semi bold",
      "bold",
      "extra bold",
      "black"
    ];
    const possibleValuesWithItalics = [...possibleValues.map((value) => `${value} italic`), ...possibleValues];
    const lowerCaseFamily = family.toLowerCase();
    const tokens = [...lowerCaseFamily.split(" "), ...lowerCaseFamily.split("-"), ...lowerCaseFamily.split("_")];
    const foundToken = possibleValuesWithItalics.find((value) => tokens.includes(value) || tokens.includes(value.replace(/\s+/g, "")));
    if (foundToken)
      return foundToken.replace(/(^\w|\s\w)/g, (char) => char.toUpperCase());
    return "Regular";
  }
  createTypeface(family) {
    const existingTypeface = this.byFamily.get(family);
    if (existingTypeface)
      return existingTypeface;
    const typeface = {
      source: this.name,
      family,
      fonts: []
    };
    this.addTypeface(typeface);
    return typeface;
  }
  addTypeface(typeface) {
    this.typefaces.push(typeface);
    this.byFamily.set(typeface.family, typeface);
  }
  parseSelector(selector) {
    if (!selector.startsWith(customFontSelectorPrefix))
      return null;
    const tokens = selector.split(customFontSelectorPrefix);
    const locator = { source: "custom", family: tokens[1] };
    return locator;
  }
  getFontBySelector(selector, createFont = true) {
    const locator = this.parseSelector(selector);
    if (!locator)
      return null;
    if (!createFont && !this.byFamily.get(locator.family))
      return null;
    return this.getTypefaceByFamily(locator.family).fonts[0];
  }
  getTypefaceByFamily(family) {
    const foundTypeface = this.byFamily.get(family);
    if (foundTypeface)
      return foundTypeface;
    const typeface = {
      source: "custom",
      family,
      fonts: []
    };
    typeface.fonts.push({
      selector: `${customFontSelectorPrefix}${family}`,
      variant: this.inferVariantName(family),
      typeface
    });
    return typeface;
  }
};

// src/render/fonts/loadFont.ts
var import_fontfaceobserver = __toModule(require_fontfaceobserver_standalone());
var FONT_LOADING_TIMEOUT = 5e3;
var MAX_RETRIES = 3;
var FontLoadingError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "FontLoadingError";
  }
};
var fontRequests = new Map();
var fontReadyPromises = new Map();
var loadFont = (data, doc) => loadFontWithRetries(data, doc);
async function loadFontWithRetries(data, doc, attempt = 0) {
  const { family, url } = data;
  const weight = data.weight || 500;
  const style = data.style || "normal";
  const requestId = `${family}-${style}-${weight}-${url}`;
  if (!fontRequests.has(requestId) || attempt > 0) {
    const fontFace = new FontFace(family, `url(${url})`, {
      weight: weight == null ? void 0 : weight.toString(),
      style
    });
    const readyPromise = fontFace.load().then(() => {
      doc.fonts.add(fontFace);
      return isFontReady(family, style, weight);
    }).catch((e) => {
      if (e.name !== "NetworkError") {
        throw e;
      }
      if (attempt < MAX_RETRIES) {
        return loadFontWithRetries(data, doc, attempt + 1);
      }
      throw new FontLoadingError(`Font loading failed after ${attempt} retries due to network error`);
    });
    fontRequests.set(requestId, readyPromise);
  }
  await fontRequests.get(requestId);
}
async function isFontReady(family, style, weight) {
  const readyPromiseId = `${family}-${style}-${weight}`;
  if (!fontReadyPromises.has(readyPromiseId)) {
    const observer = new import_fontfaceobserver.default(family, {
      style,
      weight
    });
    const readyPromise = observer.load(null, FONT_LOADING_TIMEOUT);
    fontReadyPromises.set(readyPromiseId, readyPromise);
  }
  try {
    await fontReadyPromises.get(readyPromiseId);
  } catch (e) {
    throw new FontLoadingError(`Failed to check if font is ready (${FONT_LOADING_TIMEOUT}ms timeout exceeded)`);
  }
}

// src/render/fonts/fontStore.ts
var LoadFontResult;
(function(LoadFontResult2) {
  LoadFontResult2[LoadFontResult2["AlreadyLoaded"] = 0] = "AlreadyLoaded";
  LoadFontResult2[LoadFontResult2["Loaded"] = 1] = "Loaded";
})(LoadFontResult || (LoadFontResult = {}));
var FontStore = class {
  constructor() {
    this.bySelector = new Map();
    this.loadedSelectors = new Set();
    this.createGoogleFont = (locator) => {
      const { source, family, variant, file } = locator;
      let typeface = this.getTypeface(locator);
      if (!typeface) {
        typeface = this[source].createTypeface(family);
      }
      const variantInfo = parseVariant(variant) || {};
      const { weight, style } = variantInfo;
      const selector = `GF;${family}-${variant}`;
      const font = {
        typeface,
        variant,
        selector,
        weight,
        style,
        file
      };
      typeface.fonts.push(font);
      return font;
    };
    this.local = new LocalFontSource();
    this.google = new GoogleFontSource();
    this.custom = new CustomFontSource();
    this.bySelector = new Map();
    this.importLocalFonts();
    this.defaultFont = this.getFontBySelector(defaultFontSelector);
    if (this.defaultFont) {
      this.loadFont(this.defaultFont);
    }
  }
  addFont(font) {
    this.bySelector.set(font.selector, font);
  }
  getAvailableFonts() {
    return Array.from(this.bySelector.values());
  }
  importLocalFonts() {
    this.local.importFonts().forEach((font) => {
      this.addFont(font);
      if (!this.local.interTypefaceSelectors.has(font.selector)) {
        this.loadFont(font);
      }
    });
  }
  async importGoogleFonts() {
    if (!this.getGoogleFontsListPromise) {
      this.getGoogleFontsListPromise = runtime.fetchGoogleFontsList();
      const googleFonts = await this.getGoogleFontsListPromise;
      this.google.importFonts(googleFonts).forEach((locator) => {
        const font = this.createGoogleFont(locator);
        this.addFont(font);
      });
    }
    return this.getGoogleFontsListPromise;
  }
  importCustomFonts(assets) {
    this.bySelector.forEach((_, key6) => {
      if (key6.startsWith(customFontSelectorPrefix)) {
        this.bySelector.delete(key6);
      }
    });
    this.custom.importFonts(assets).forEach((font) => this.addFont(font));
  }
  getTypeface(info) {
    const typeface = this[info.source].getTypefaceByFamily(info.family);
    return typeface;
  }
  getFontBySelector(selector, createFont = true) {
    if (selector.startsWith(customFontSelectorPrefix)) {
      return this.custom.getFontBySelector(selector, createFont);
    }
    return this.bySelector.get(selector) || null;
  }
  getDraftPropertiesBySelector(selector) {
    const font = this.getFontBySelector(selector);
    if (font) {
      return {
        style: font.style,
        weight: font.weight,
        variant: font.variant,
        family: font.typeface.family,
        source: font.typeface.source
      };
    }
    const locator = this.google.parseSelector(selector);
    if (locator) {
      const fontVariant = parseVariant(locator.variant);
      if (fontVariant) {
        return {
          style: fontVariant.style,
          weight: fontVariant.weight,
          variant: locator.variant,
          family: locator.family,
          source: TypefaceSourceNames.Google
        };
      }
    }
    return null;
  }
  isSelectorLoaded(selector) {
    return this.loadedSelectors.has(selector);
  }
  async loadTypeface(typeface) {
    await Promise.all(typeface.fonts.map((f) => this.loadFont(f)));
  }
  async loadFont(font) {
    if (this.isSelectorLoaded(font.selector)) {
      return 0;
    }
    if (font.typeface.source === TypefaceSourceNames.Local) {
      if (this.local.interTypefaceSelectors.has(font.selector) && true) {
        await isFontReady(font.typeface.family, font.style, font.weight);
      }
      this.loadedSelectors.add(font.selector);
      return 1;
    }
    if (!font.file) {
      return Promise.reject(`Unable to load font: ${font.selector}`);
    }
    await loadFont({
      family: font.typeface.family,
      url: font.file,
      weight: font.weight,
      style: font.style
    }, document);
    this.loadedSelectors.add(font.selector);
    return 1;
  }
  async loadWebFontsFromSelectors(selectors) {
    if (selectors.some((s) => s.startsWith(googleFontSelectorPrefix))) {
      await this.importGoogleFonts();
    }
    const fonts = selectors.map((s) => this.bySelector.get(s)).filter((f) => !!f);
    return Promise.allSettled(fonts.map((f) => this.loadFont(f)));
  }
};
var fontStore = new FontStore();
Promise.allSettled = Promise.allSettled || ((promises) => Promise.all(promises.map((p) => p.then((v) => ({ status: "fulfilled", value: v })).catch((e) => ({ status: "rejected", reason: e })))));

// src/render/utils/isShallowEqualArray.ts
function isShallowEqualArray(a2, b2) {
  return a2.length === b2.length && a2.every((v, i) => v === b2[i]);
}

// src/render/presentation/Text.tsx
function Text(props) {
  var _a;
  const parentSize = useParentSize();
  const layoutId = useLayoutId2(props);
  const layoutRef = useRef23(null);
  useMeasureLayout(props, layoutRef);
  const { fonts, __fromCanvasComponent } = props;
  const prevFontsRef = useRef23([]);
  const fontsDidChange = !isShallowEqualArray((_a = prevFontsRef.current) != null ? _a : [], fonts != null ? fonts : []);
  prevFontsRef.current = fonts;
  useEffect22(() => {
    if (!fontsDidChange || !fonts)
      return;
    fontStore.loadWebFontsFromSelectors(fonts).then((results) => {
      if (!__fromCanvasComponent || !layoutRef.current || RenderTarget.current() !== RenderTarget.canvas)
        return;
      const didLoadNewFonts = results.some((result) => result.status === "fulfilled" && result.value === LoadFontResult.Loaded);
      if (!didLoadNewFonts)
        return;
      measureClosestComponentContainer(layoutRef.current);
    });
  }, [fonts]);
  return /* @__PURE__ */ createElement40(TextComponent, {
    ...props,
    innerRef: layoutRef,
    layoutId,
    parentSize
  });
}
var _TextComponent = class extends Layer {
  constructor() {
    super(...arguments);
    this.renderMain = (inCodeComponent) => {
      if (safeWindow["perf"])
        safeWindow["perf"].nodeRender();
      const {
        font,
        visible,
        alignment,
        willChangeTransform,
        opacity,
        id,
        layoutId,
        className,
        transition,
        variants,
        name,
        innerRef,
        __fromCanvasComponent,
        widthType,
        heightType,
        _usesDOMRect,
        autoSize,
        style: styleProp
      } = this.props;
      const frame2 = this.frame;
      if (!visible) {
        return null;
      }
      injectComponentCSSRules();
      const isHidden2 = this.props.isEditable && this.props.environment() === RenderTarget.canvas;
      const justifyContent = convertVerticalAlignment(this.props.verticalAlignment);
      const style = {
        outline: "none",
        display: "flex",
        flexDirection: "column",
        justifyContent,
        opacity: isHidden2 ? 0 : opacity,
        flexShrink: 0
      };
      const dataProps = {
        "data-framer-component-type": "Text",
        "data-framer-name": name
      };
      if (autoSize) {
        dataProps["data-framer-component-text-autosized"] = "true";
      }
      this.collectLayout(style, inCodeComponent);
      collectFiltersFromProps(this.props, style);
      collectTextShadowsForProps(this.props, style);
      if (style.opacity === 1 || style.opacity === void 0) {
        delete style.opacity;
      }
      if (willChangeTransform) {
        forceLayerBackingWithCSSProperties(style);
      }
      let rawHTML = this.props.rawHTML;
      const text = this.getOverrideText() || this.props.text;
      if (isString2(text)) {
        if (rawHTML) {
          rawHTML = replaceDraftHTMLWithText(rawHTML, text);
        } else {
          rawHTML = `<p style="font: ${font}">${text}</p>`;
        }
      }
      if (this.props.style) {
        Object.assign(style, this.props.style);
      }
      const isDOMLayoutAutoSized = _usesDOMRect && (widthType === DimensionType.Auto || heightType === DimensionType.Auto);
      const hasTransformTemplate = !frame2 || !RenderTarget.hasRestrictions() || __fromCanvasComponent || isDOMLayoutAutoSized;
      if (hasTransformTemplate) {
        Object.assign(dataProps, layoutHintDataPropsForCenter(this.props.center));
      }
      if (rawHTML) {
        style.textAlign = alignment;
        style.lineHeight = "1px";
        style.fontSize = "0px";
        return /* @__PURE__ */ createElement40(motion.div, {
          layoutId,
          id,
          ...dataProps,
          style: { ...style, ...styleProp },
          transformTemplate: hasTransformTemplate ? transformTemplate(this.props.center) : void 0,
          dangerouslySetInnerHTML: { __html: rawHTML },
          "data-center": this.props.center,
          className,
          transition,
          variants,
          ref: innerRef
        });
      }
    };
  }
  get frame() {
    return calculateRect(this.props, this.props.parentSize || ParentSizeState.Unknown, false);
  }
  getOverrideText() {
    const { _forwardedOverrideId, _forwardedOverrides, id } = this.props;
    const forwardedOverrideId = _forwardedOverrideId != null ? _forwardedOverrideId : id;
    if (forwardedOverrideId && _forwardedOverrides) {
      const text = _forwardedOverrides[forwardedOverrideId];
      if (isString2(text)) {
        return text;
      }
    }
  }
  render() {
    return /* @__PURE__ */ createElement40(ComponentContainerContext.Consumer, null, this.renderMain);
  }
  collectLayout(style, inCodeComponent) {
    if (this.props.withExternalLayout)
      return;
    const frame2 = this.frame;
    const {
      rotation,
      autoSize,
      positionSticky,
      positionStickyTop,
      positionStickyRight,
      positionStickyBottom,
      positionStickyLeft,
      width: externalWidth,
      height: externalHeight,
      _usesDOMRect
    } = this.props;
    const rotate = Animatable.getNumber(rotation);
    const isDOMLayoutAutoSized = _usesDOMRect && (externalWidth === "auto" || externalHeight === "auto");
    if (frame2 && !isDOMLayoutAutoSized && RenderTarget.hasRestrictions()) {
      Object.assign(style, {
        transform: `translate(${frame2.x}px, ${frame2.y}px) rotate(${rotate.toFixed(4)}deg)`,
        width: autoSize ? "auto" : `${frame2.width}px`,
        minWidth: `${frame2.width}px`,
        height: `${frame2.height}px`
      });
    } else {
      const { left, right, top, bottom } = this.props;
      let width;
      let height;
      if (autoSize) {
        width = "auto";
        height = "auto";
      } else {
        if (!isFiniteNumber(left) || !isFiniteNumber(right)) {
          width = externalWidth;
        }
        if (!isFiniteNumber(top) || !isFiniteNumber(bottom)) {
          height = externalHeight;
        }
      }
      Object.assign(style, {
        left,
        right,
        top,
        bottom,
        width,
        height,
        rotate
      });
    }
    if (positionSticky) {
      const onCanvas = RenderTarget.current() === RenderTarget.canvas;
      if (!onCanvas || inCodeComponent) {
        style.position = "sticky";
        style.willChange = "transform";
        style.zIndex = 1;
        style.top = positionStickyTop;
        style.right = positionStickyRight;
        style.bottom = positionStickyBottom;
        style.left = positionStickyLeft;
      }
    }
  }
};
var TextComponent = _TextComponent;
TextComponent.supportsConstraints = true;
TextComponent.defaultTextProps = {
  opacity: void 0,
  left: void 0,
  right: void 0,
  top: void 0,
  bottom: void 0,
  _constraints: {
    enabled: true,
    aspectRatio: null
  },
  rotation: 0,
  visible: true,
  alignment: void 0,
  verticalAlignment: "top",
  shadows: [],
  font: "16px " + deviceFont()
};
TextComponent.defaultProps = {
  ...Layer.defaultProps,
  ..._TextComponent.defaultTextProps,
  isEditable: false,
  environment: RenderTarget.current,
  withExternalLayout: false
};
var textContentRegex = /(<span [^>]+>).*<\/span>/s;
function replaceDraftHTMLWithText(rawHTML, text) {
  return rawHTML.replace(textContentRegex, (_, span) => span + text + "</span>");
}
function convertVerticalAlignment(verticalAlignment) {
  switch (verticalAlignment) {
    case "top":
      return "flex-start";
    case "center":
      return "center";
    case "bottom":
      return "flex-end";
  }
}

// src/render/presentation/Vector.tsx
import {
  createElement as createElement43
} from "react";

// src/render/utils/transformString.ts
function transformString(transform2) {
  if (transform2 === void 0) {
    return void 0;
  }
  const { x, y, rotation, width, height } = transform2;
  let result;
  if (x !== 0 || y !== 0) {
    result = `translate(${roundedNumberString(x, 3)} ${roundedNumberString(y, 3)})`;
  }
  if (rotation !== 0) {
    const roundedRotation = roundedNumberString(rotation, 4);
    const roundedWidth = roundedNumberString(width / 2, 3);
    const roundedHeight = roundedNumberString(height / 2, 3);
    const rotationString = `rotate(${roundedRotation} ${roundedWidth} ${roundedHeight})`;
    result = result ? `${result} ${rotationString}` : rotationString;
  }
  return result;
}

// src/render/presentation/SVGRoot.tsx
import {
  Component as Component15,
  createElement as createElement41
} from "react";
var SVGRoot = class extends Component15 {
  render() {
    const { children, frame: frame2 } = this.props;
    const { width, height } = frame2;
    const fx = Math.floor(frame2.x);
    const fy = Math.floor(frame2.y);
    const svgStyle = {
      position: "absolute",
      width: Math.ceil(width),
      height: Math.ceil(height),
      overflow: "visible",
      display: "block",
      transform: `translate(${fx}px, ${fy}px)`
    };
    Layer.applyWillChange(this.props, svgStyle, false);
    return /* @__PURE__ */ createElement41("svg", {
      width: "100%",
      height: "100%",
      xmlns: "http://www.w3.org/2000/svg",
      xmlnsXlink: "http://www.w3.org/1999/xlink",
      style: svgStyle
    }, children);
  }
};

// src/render/presentation/GradientElement.tsx
import {
  Component as Component16,
  createElement as createElement42
} from "react";
var LinearGradientElement = class extends Component16 {
  render() {
    const { id, angle, stops } = this.props;
    return /* @__PURE__ */ createElement42("linearGradient", {
      id,
      gradientTransform: `rotate(${angle}, 0.5, 0.5)`
    }, stops.map((stop, idx) => {
      return /* @__PURE__ */ createElement42("stop", {
        key: idx,
        offset: stop.position,
        stopColor: stop.color,
        stopOpacity: stop.alpha
      });
    }));
  }
};
var RadialGradientElement = class extends Component16 {
  render() {
    const { centerAnchorX, centerAnchorY, id, widthFactor, heightFactor, stops } = this.props;
    return /* @__PURE__ */ createElement42("radialGradient", {
      id,
      cy: centerAnchorY,
      cx: centerAnchorX,
      r: widthFactor,
      gradientTransform: `translate(${centerAnchorX}, ${centerAnchorY}) scale(1 ${heightFactor / widthFactor}) translate(-${centerAnchorX}, -${centerAnchorY})`
    }, stops.map((stop, idx) => {
      return /* @__PURE__ */ createElement42("stop", {
        key: idx,
        offset: stop.position,
        stopColor: stop.color,
        stopOpacity: stop.alpha
      });
    }));
  }
};

// src/render/utils/createTransformValues.ts
function createTransformValues(baseTransform, mode) {
  let { x, y } = baseTransform;
  const { width, height, rotation } = baseTransform;
  if (mode === "resetXYKeepFraction") {
    x = x - Math.floor(x);
    y = y - Math.floor(y);
  } else if (mode === "resetXY") {
    x = 0;
    y = 0;
  }
  return { x, y, width, height, rotation };
}
function getTransformMode(isRootVectorNode, includeTransform) {
  if (includeTransform !== void 0) {
    if (includeTransform) {
      return "asIs";
    }
  } else {
    if (!isRootVectorNode) {
      return "asIs";
    }
  }
  if (isRootVectorNode) {
    return "resetXYKeepFraction";
  } else {
    return "resetXY";
  }
}
function transformValues2(rect, rotation, isRootVectorNode, includeTransform) {
  const transformMode = getTransformMode(isRootVectorNode, includeTransform);
  const baseTransform = { ...rect, rotation };
  const transform2 = createTransformValues(baseTransform, transformMode);
  return transform2;
}

// src/render/types/svgElementAttributeDefaults.ts
var svgElementAttributeDefaults = {
  stroke: "none",
  strokeWidth: 1,
  strokeLinecap: "butt",
  strokeLinejoin: "miter",
  strokeMiterlimit: 4,
  strokeDasharray: "0",
  strokeDashoffset: 0,
  strokeOpacity: 1,
  fill: "black",
  fillRule: "nonzero",
  fillOpacity: 1
};

// src/render/presentation/Vector.tsx
var _Vector = class extends Layer {
  render() {
    var _a, _b;
    if (safeWindow["perf"])
      safeWindow["perf"].nodeRender();
    const {
      opacity,
      calculatedPath,
      d,
      insideStroke,
      shapeId,
      strokeEnabled,
      strokeClipId,
      strokeWidth,
      idAttribute,
      rect,
      shadows,
      strokeAlpha,
      name,
      includeTransform,
      isRootVectorNode,
      rotation,
      id,
      lineCap,
      lineJoin,
      strokeColor,
      strokeMiterLimit,
      strokeDashArray,
      strokeDashOffset,
      fill,
      variants,
      transition
    } = this.props;
    if (!id || !shapeId || !strokeClipId)
      return null;
    const rotate = (_b = (_a = this.props.rotate) != null ? _a : rotation) != null ? _b : 0;
    const { target } = RenderEnvironment;
    const transform2 = transformValues2(rect, rotate, isRootVectorNode, includeTransform);
    let vectorFill;
    let fillAlpha = 0;
    let imagePattern;
    let linearGradient;
    let radialGradient;
    if (typeof fill === "string" || Color.isColorObject(fill)) {
      const fillColor = Color.isColorObject(fill) ? fill.initialValue || Color.toRgbString(fill) : fill;
      if (fillColor !== "transparent") {
        vectorFill = fillColor;
        fillAlpha = ConvertColor.getAlpha(vectorFill);
      }
    } else if (LinearGradient.isLinearGradient(fill)) {
      linearGradient = elementPropertiesForLinearGradient(fill, id);
      vectorFill = `url(#${linearGradient.id})`;
      fillAlpha = 1;
    } else if (RadialGradient.isRadialGradient(fill)) {
      radialGradient = elementPropertiesForRadialGradient(fill, id);
      vectorFill = `url(#${radialGradient.id})`;
      fillAlpha = 1;
    } else if (BackgroundImage.isImageObject(fill)) {
      imagePattern = imagePatternPropsForFill(fill, transform2, id);
      if (imagePattern) {
        vectorFill = `url(#${imagePattern.id})`;
        fillAlpha = 1;
      }
    }
    if (vectorFill === svgElementAttributeDefaults.fill) {
      vectorFill = void 0;
    }
    if (vectorFill === void 0) {
      vectorFill = "transparent";
    }
    const fillEnabled = vectorFill !== void 0 && vectorFill !== "transparent" && fillAlpha !== 0;
    if (!fillEnabled && !strokeEnabled) {
      fillAlpha = 1;
    }
    let mainElement;
    let strokeClipPath = null;
    let shapeReference = null;
    let strokeElement = null;
    let pathTranslate;
    let elementTransform;
    const translatePaths = target === RenderTarget.export;
    if (transform2.rotation === 0 && translatePaths) {
      pathTranslate = transform2;
    } else {
      pathTranslate = { x: 0, y: 0 };
      elementTransform = transformString(transform2);
    }
    const pathAttributes = {
      d: d != null ? d : toSVGPath(calculatedPath, pathTranslate, target),
      transform: elementTransform
    };
    const svgStrokeAttributes = {};
    if (strokeEnabled && strokeWidth !== 0) {
      svgStrokeAttributes.strokeWidth = strokeWidth;
      svgStrokeAttributes.stroke = strokeColor;
      svgStrokeAttributes.strokeLinecap = lineCap;
      svgStrokeAttributes.strokeLinejoin = lineJoin;
      if (lineJoin === "miter") {
        svgStrokeAttributes.strokeMiterlimit = strokeMiterLimit;
      }
      svgStrokeAttributes.strokeDasharray = strokeDashArray;
      if (strokeDashOffset !== 0) {
        svgStrokeAttributes.strokeDashoffset = strokeDashOffset;
      }
    }
    for (const key6 in svgElementAttributeDefaults) {
      if (svgStrokeAttributes[key6] === svgElementAttributeDefaults[key6]) {
        svgStrokeAttributes[key6] = void 0;
      }
    }
    const internalShapeId = InternalID.forKey(shapeId);
    const internalStrokeClipId = InternalID.forKey(strokeClipId);
    const shadow = shadowForShape(shadows, rect, internalShapeId, fillAlpha, strokeAlpha, strokeWidth, internalStrokeClipId, svgStrokeAttributes);
    const currentName = target === RenderTarget.preview ? name || void 0 : void 0;
    if (shadow.insetElement !== null || shadow.outsetElement !== null || insideStroke) {
      pathAttributes.id = internalShapeId.id;
      shapeReference = /* @__PURE__ */ createElement43(motion.path, {
        ...{ ...pathAttributes },
        variants,
        transition
      });
      if (shadow.needsStrokeClip || insideStroke) {
        strokeClipPath = /* @__PURE__ */ createElement43("clipPath", {
          id: internalStrokeClipId.id
        }, /* @__PURE__ */ createElement43("use", {
          xlinkHref: internalShapeId.link
        }));
      }
      if (shadow.insetElement !== null && strokeEnabled && strokeWidth && strokeWidth > 0) {
        mainElement = /* @__PURE__ */ createElement43("use", {
          xlinkHref: internalShapeId.link,
          fill: vectorFill,
          strokeOpacity: "0",
          name: currentName
        });
        strokeElement = /* @__PURE__ */ createElement43("use", {
          xlinkHref: internalShapeId.link,
          clipPath: internalStrokeClipId.urlLink,
          fill: "transparent",
          ...svgStrokeAttributes,
          strokeWidth
        });
      } else {
        mainElement = /* @__PURE__ */ createElement43("use", {
          xlinkHref: internalShapeId.link,
          fill: vectorFill,
          clipPath: internalStrokeClipId.urlLink,
          ...svgStrokeAttributes,
          strokeWidth,
          name: currentName
        });
      }
    } else {
      pathAttributes.id = idAttribute;
      mainElement = /* @__PURE__ */ createElement43(motion.path, {
        ...{
          ...pathAttributes,
          fill: vectorFill,
          ...svgStrokeAttributes
        },
        name: currentName,
        variants,
        transition
      });
    }
    const imagePatternElement = imagePattern ? /* @__PURE__ */ createElement43(ImagePatternElement, {
      ...imagePattern
    }) : void 0;
    let gradient;
    if (linearGradient) {
      gradient = /* @__PURE__ */ createElement43(LinearGradientElement, {
        ...linearGradient
      });
    } else if (radialGradient) {
      gradient = /* @__PURE__ */ createElement43(RadialGradientElement, {
        ...radialGradient
      });
    }
    let defs = null;
    if (shapeReference || strokeClipPath || shadow.definition && shadow.definition.length || gradient || imagePatternElement) {
      defs = /* @__PURE__ */ createElement43("defs", null, shapeReference, strokeClipPath, shadow.definition, gradient, imagePatternElement);
    }
    const opacityValue = opacity != null ? opacity : variants ? 1 : void 0;
    if (defs === null && shadow.outsetElement === null && shadow.insetElement === null && strokeElement === null) {
      mainElement = /* @__PURE__ */ createElement43(motion.path, {
        ...{
          ...pathAttributes,
          fill: vectorFill,
          ...svgStrokeAttributes
        },
        opacity: opacityValue,
        variants,
        transition,
        name: currentName
      });
      return this.renderElement(mainElement);
    } else {
      return this.renderElement(/* @__PURE__ */ createElement43(motion.g, {
        opacity: opacityValue,
        variants,
        transition
      }, defs, shadow.outsetElement, mainElement, shadow.insetElement, strokeElement));
    }
  }
  renderElement(element) {
    var _a, _b;
    const { isRootVectorNode, width, height, rect, willChangeTransform } = this.props;
    const frame2 = (_b = (_a = this.props.frame) != null ? _a : rect) != null ? _b : { x: 0, y: 0, width: 100, height: 100 };
    if (!isRootVectorNode)
      return element;
    return /* @__PURE__ */ createElement43(SVGRoot, {
      ...{ frame: frame2, width, height, willChangeTransform }
    }, element);
  }
};
var Vector = _Vector;
Vector.defaultVectorProps = {
  isRootVectorNode: false,
  name: null,
  includeTransform: void 0,
  defaultFillColor: void 0,
  defaultStrokeColor: void 0,
  defaultStrokeWidth: void 0,
  defaultStrokeAlignment: "center",
  width: 100,
  height: 100,
  rotation: 0,
  rotate: void 0,
  frame: void 0,
  opacity: void 0,
  calculatedPath: [],
  d: void 0,
  shapeId: void 0,
  insideStroke: false,
  strokeEnabled: true,
  strokeClipId: void 0,
  strokeWidth: void 0,
  idAttribute: void 0,
  transition: void 0,
  shadows: [],
  strokeAlpha: 1,
  rect: { x: 0, y: 0, width: 0, height: 0 },
  lineCap: "butt",
  strokeColor: "#0AF",
  lineJoin: "miter",
  strokeMiterLimit: 4,
  strokeDashArray: "0",
  strokeDashOffset: 0,
  fill: "rgba(0,170,255,0.5)"
};
Vector.defaultProps = {
  ...Layer.defaultProps,
  ..._Vector.defaultVectorProps
};

// src/render/presentation/VectorGroup.tsx
import {
  createElement as createElement44
} from "react";
var _VectorGroup = class extends Layer {
  render() {
    if (safeWindow["perf"])
      safeWindow["perf"].nodeRender();
    const {
      id,
      name: nameProp,
      opacity,
      visible,
      targetName,
      defaultName,
      children,
      includeTransform,
      x,
      y,
      width,
      height,
      rotation,
      isRootVectorNode
    } = this.props;
    if (!visible)
      return null;
    const { target } = RenderEnvironment;
    const rect = { x, y, width, height };
    const transform2 = transformValues2(rect, rotation, isRootVectorNode, includeTransform);
    const addNames = target === RenderTarget.preview;
    let name = void 0;
    if (addNames) {
      if (targetName) {
        name = targetName;
      } else if (nameProp) {
        name = nameProp;
      } else {
        name = defaultName;
      }
    }
    return this.renderElement(/* @__PURE__ */ createElement44("g", {
      transform: transformString(transform2),
      ...{ id, name, opacity }
    }, children));
  }
  renderElement(element) {
    const { isRootVectorNode, width, height, frame: frame2, willChangeTransform } = this.props;
    if (!isRootVectorNode) {
      return element;
    }
    return /* @__PURE__ */ createElement44(SVGRoot, {
      ...{ frame: frame2, width, height, willChangeTransform }
    }, element);
  }
};
var VectorGroup = _VectorGroup;
VectorGroup.defaultVectorGroupProps = {
  name: void 0,
  opacity: void 0,
  visible: true,
  x: 0,
  y: 0,
  rotation: 0,
  width: 100,
  height: 100,
  targetName: void 0,
  defaultName: "",
  isRootVectorNode: false,
  includeTransform: void 0,
  frame: { x: 0, y: 0, width: 100, height: 100 }
};
VectorGroup.defaultProps = {
  ...Layer.defaultProps,
  ..._VectorGroup.defaultVectorGroupProps
};

// src/render/presentation/DeprecatedComponentContainer.tsx
import {
  Children as Children11,
  cloneElement as cloneElement9,
  createElement as createElement45
} from "react";
var _DeprecatedComponentContainer = class extends Layer {
  constructor() {
    super(...arguments);
    this.state = {};
  }
  componentDidCatch(error, info) {
    let stack = info.componentStack.split("\n").filter((line) => line.length !== 0);
    let currentIndex = 0;
    for (const line of stack) {
      if (line.startsWith(`    in ${this.constructor.name}`)) {
        break;
      }
      currentIndex++;
    }
    stack = stack.slice(0, currentIndex);
    this.setState({
      lastError: {
        children: this.props.children,
        name: error.name,
        message: error.message,
        componentStack: stack
      }
    });
  }
  renderErrorPlaceholder(file, error) {
    const { RenderPlaceholder } = runtime;
    return /* @__PURE__ */ createElement45(FrameWithMotion, {
      ...this.props,
      background: null
    }, /* @__PURE__ */ createElement45(RenderPlaceholder, {
      error: { error, file }
    }));
  }
  render() {
    var _a, _b;
    if (safeWindow["perf"])
      safeWindow["perf"].nodeRender();
    let { children } = this.props;
    const { componentIdentifier, innerRef } = this.props;
    const { lastError: error } = this.state;
    const noChildren = !children || Array.isArray(children) && children.filter((c2) => c2).length === 0;
    if (noChildren) {
      const errorComponent = runtime.componentLoader.errorForIdentifier(componentIdentifier);
      if (errorComponent) {
        return this.renderErrorPlaceholder(errorComponent.file, errorComponent.error);
      }
    }
    if (error && error.children === children) {
      const component = runtime.componentLoader.componentForIdentifier(componentIdentifier);
      const file = component ? component.file : "???";
      return this.renderErrorPlaceholder(file, error.message);
    }
    (_b = (_a = safeWindow)["__checkComponentBudget__"]) == null ? void 0 : _b.call(_a);
    let frameProps = this.props;
    if (RenderTarget.current() !== RenderTarget.canvas) {
      const {
        left,
        right,
        top,
        bottom,
        center,
        centerX,
        centerY,
        aspectRatio,
        parentSize,
        width,
        height,
        rotation,
        opacity,
        visible,
        _constraints,
        _initialStyle,
        name,
        positionSticky,
        positionStickyTop,
        positionStickyRight,
        positionStickyBottom,
        positionStickyLeft,
        componentIdentifier: originalComponentIdentifier,
        children: originalChildren,
        style,
        duplicatedFrom,
        widthType,
        heightType,
        ...childProps
      } = frameProps;
      children = Children11.map(originalChildren, (child) => {
        var _a2;
        if (!isReactChild(child) || !isReactElement(child)) {
          return child;
        }
        if (!isPageOrScroll(originalComponentIdentifier)) {
          return /* @__PURE__ */ createElement45(LayoutGroupContext.Provider, {
            value: (_a2 = this.props.__layoutId) != null ? _a2 : null
          }, /* @__PURE__ */ createElement45(AnimateSharedLayout, null, /* @__PURE__ */ createElement45(AutomaticLayoutIds, {
            enabled: false
          }, cloneElement9(child, childProps))));
        }
        return cloneElement9(child, childProps);
      });
      frameProps = {
        style,
        _constraints,
        _initialStyle,
        left,
        right,
        top,
        bottom,
        center,
        centerX,
        centerY,
        aspectRatio,
        parentSize,
        width,
        height,
        rotation,
        visible,
        name,
        duplicatedFrom,
        id: frameProps.id,
        layoutId: this.props.__layoutId,
        widthType,
        heightType,
        positionSticky,
        positionStickyTop,
        positionStickyRight,
        positionStickyBottom,
        positionStickyLeft
      };
    }
    return /* @__PURE__ */ createElement45(ComponentContainerContext.Provider, {
      value: true
    }, /* @__PURE__ */ createElement45(FrameWithMotion, {
      "data-framer-component-container": true,
      background: null,
      overflow: "visible",
      ref: innerRef,
      ...frameProps
    }, children));
  }
};
var DeprecatedComponentContainer = _DeprecatedComponentContainer;
DeprecatedComponentContainer.supportsConstraints = true;
DeprecatedComponentContainer.defaultComponentContainerProps = {
  style: {},
  visible: true,
  componentIdentifier: ""
};
DeprecatedComponentContainer.defaultProps = {
  ...Layer.defaultProps,
  ..._DeprecatedComponentContainer.defaultComponentContainerProps
};
DeprecatedComponentContainer.contextType = ComponentContainerContext;
function isPageOrScroll(identifier) {
  if (!identifier)
    return false;
  if (identifier === "framer/Page")
    return true;
  if (identifier === "framer/Scroll")
    return true;
  return false;
}

// src/render/presentation/PresentationTree.ts
function convertPresentationTree(node, converter, componentDefinitionProvider, getCachedNode, skipCodeComponentPropsCache = false) {
  const cachedNode = getCachedNode && getCachedNode(node);
  if (cachedNode)
    return cachedNode;
  let children;
  if (isCodeComponentContainerPresentation(node)) {
    children = convertCodeComponentContainer(componentDefinitionProvider, node, converter, getCachedNode, skipCodeComponentPropsCache);
  } else if (node.children) {
    children = node.children.map((n) => convertPresentationTree(n, converter, componentDefinitionProvider, getCachedNode, skipCodeComponentPropsCache));
  }
  return converter(node, children);
}
function isCodeComponentContainerPresentation(value) {
  return !!value.codeComponentIdentifier;
}
function convertCodeComponentContainer(componentDefinitionProvider, node, converter, getCachedNode, skipCodeComponentPropsCache = false) {
  const codeComponentChildren = node.getComponentChildren ? node.getComponentChildren(componentDefinitionProvider) : [];
  const codeComponentSlots = node.getComponentSlotChildren ? node.getComponentSlotChildren(componentDefinitionProvider) : {};
  let codeComponentPresentation;
  const props = node.getCodeComponentProps ? node.getCodeComponentProps(componentDefinitionProvider, { skipCache: skipCodeComponentPropsCache }) : void 0;
  if (node.cache.codeComponentPresentation) {
    codeComponentPresentation = node.cache.codeComponentPresentation;
    if (!isShallowEqualArray(codeComponentPresentation.children, codeComponentChildren)) {
      codeComponentPresentation.cache.reactElement = null;
      codeComponentPresentation.children = codeComponentChildren;
    }
    if (!isEqual(codeComponentPresentation.props, props)) {
      codeComponentPresentation.cache.reactElement = null;
      codeComponentPresentation.cache.props = null;
      codeComponentPresentation.props = props;
    }
  } else {
    const { id: containerId, codeComponentIdentifier: identifier, codeComponentPackageVersion } = node;
    node.cache.codeComponentPresentation = codeComponentPresentation = new CodeComponentPresentation(containerId + identifier, identifier, codeComponentPackageVersion, props, codeComponentChildren);
  }
  codeComponentPresentation.props.placeholders = node.cache.placeholders;
  const slotKeys = Object.keys(codeComponentSlots);
  if (slotKeys.length) {
    codeComponentPresentation.props = { ...codeComponentPresentation.props };
    codeComponentPresentation.props.__slotKeys = slotKeys;
    for (const slotKey of slotKeys) {
      const slotChildren = codeComponentSlots[slotKey].map((child) => convertPresentationTree(child, converter, componentDefinitionProvider, getCachedNode, skipCodeComponentPropsCache));
      codeComponentPresentation.props[slotKey] = slotChildren;
    }
  }
  return [
    converter(codeComponentPresentation, codeComponentPresentation.children.map((child) => convertPresentationTree(child, converter, componentDefinitionProvider, getCachedNode, skipCodeComponentPropsCache)))
  ];
}
var CodeComponentPresentation = class {
  constructor(id, componentIdentifier, packageVersion, props, children, codeOverrideIdentifier) {
    this.id = id;
    this.componentIdentifier = componentIdentifier;
    this.packageVersion = packageVersion;
    this.props = props;
    this.children = children;
    this.codeOverrideIdentifier = codeOverrideIdentifier;
    this.cache = {};
  }
  getProps() {
    return {
      ...this.props,
      id: this.id,
      key: this.id
    };
  }
  rect(parentSize) {
    return { x: 0, y: 0, width: 0, height: 0 };
  }
};

// src/components/useNavigation.ts
import { useContext as useContext26 } from "react";
function useNavigation() {
  return useContext26(NavigationContext);
}

// src/render/style/getCSSTextColorFromStyle.ts
function _getCSSTextColorFromStyle(css) {
  let color2;
  if (typeof css["webkitTextFillColor"] === "string") {
    color2 = css["webkitTextFillColor"];
  }
  if (typeof css.WebkitTextFillColor === "string") {
    color2 = css.WebkitTextFillColor;
  }
  if (typeof css.color === "string") {
    color2 = css.color;
  }
  if (color2) {
    return ConvertColor.toRgbString(color2);
  }
}

// src/render/DesignComponentWrapper.tsx
import {
  Component as Component18,
  createContext as createContext17,
  createElement as createElement48,
  isValidElement as isValidElement3
} from "react";

// src/deprecated/WithOverride.tsx
import {
  createElement as createElement47
} from "react";
import { useContext as useContext28 } from "react";

// src/deprecated/DataObserver.tsx
import {
  Component as Component17,
  createContext as createContext16,
  createElement as createElement46,
  useContext as useContext27
} from "react";

// src/data/Data.ts
function Data(initial = {}) {
  const data = ObservableObject(initial, false, false);
  Data.addData(data);
  return data;
}
(function(Data2) {
  Data2._stores = [];
  function addData(data) {
    Data2._stores.push(data);
  }
  Data2.addData = addData;
  function reset() {
    Data2._stores.forEach((target) => ObservableObject.resetObject(target));
  }
  Data2.reset = reset;
  function addObserver(target, observer) {
    return ObservableObject.addObserver(target, observer);
  }
  Data2.addObserver = addObserver;
})(Data || (Data = {}));

// src/deprecated/DataObserver.tsx
var initialState = { update: 0 };
var DataObserverContext = createContext16(initialState);
function useObserveData() {
  useContext27(DataObserverContext);
}
var DataObserver = class extends Component17 {
  constructor() {
    super(...arguments);
    this.observers = [];
    this.state = initialState;
    this.taskAdded = false;
    this.frameTask = () => {
      this.setState({ update: this.state.update + 1 });
      this.taskAdded = false;
    };
    this.observer = () => {
      if (this.taskAdded)
        return;
      this.taskAdded = true;
      MainLoop.addFrameTask(this.frameTask);
    };
  }
  componentWillUnmount() {
    this.observers.map((cancel) => cancel());
    Data.reset();
  }
  render() {
    const { children } = this.props;
    this.observers.map((cancel) => cancel());
    this.observers = [];
    Data._stores.forEach((d) => {
      const observer = Data.addObserver(d, this.observer);
      this.observers.push(observer);
    });
    return /* @__PURE__ */ createElement46(DataObserverContext.Provider, {
      value: { ...this.state }
    }, children);
  }
};

// src/deprecated/convertColorProps.ts
function convertColorObject(prop) {
  if (typeof prop === "string" || isMotionValue2(prop)) {
    return prop;
  } else if (LinearGradient.isLinearGradient(prop)) {
    return LinearGradient.toCSS(prop);
  } else if (RadialGradient.isRadialGradient(prop)) {
    return RadialGradient.toCSS(prop);
  } else if (Color.isColorObject(prop)) {
    return Color.toRgbString(prop);
  }
  return prop;
}
function convertColorProps(props) {
  if (props.background || props.color) {
    const converted = Object.assign({}, props);
    if (props.background) {
      converted.background = convertColorObject(props.background);
    }
    if (props.color) {
      converted.color = convertColorObject(props.color);
    }
    return converted;
  }
  return props;
}

// src/deprecated/WithOverride.tsx
var hoistNonReactStatic4 = require_hoist_non_react_statics_cjs();
function WithOverride(Component19, override) {
  const useOverride = typeof override === "function" ? (props) => override(convertColorProps(props)) : () => convertColorProps(override);
  const ComponentWithOverride = function(props) {
    useContext28(DataObserverContext);
    const overrideProps = useOverride(props);
    const { style, ...rest } = props;
    return /* @__PURE__ */ createElement47(Component19, {
      ...rest,
      ...overrideProps,
      _initialStyle: style
    });
  };
  hoistNonReactStatic4(ComponentWithOverride, Component19);
  ComponentWithOverride["displayName"] = `WithOverride(${Component19.displayName || Component19.name})`;
  return ComponentWithOverride;
}

// src/render/DesignComponentWrapper.tsx
var _CanvasStore = class {
  constructor() {
    this.canvas = { children: [] };
    this.listeners = [];
    this.ids = [];
  }
  static shared(data) {
    if (data) {
      const store = new _CanvasStore();
      store.setCanvas(data);
      return store;
    }
    if (!_CanvasStore.__shared) {
      _CanvasStore.__shared = new _CanvasStore();
    }
    return _CanvasStore.__shared;
  }
  updateNode(presentationNode) {
    const id = presentationNode.props.id;
    let children = this.canvas.children;
    if (!children) {
      this.canvas.children = children = [];
    }
    let found = false;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.props.id === id) {
        found = true;
        children[i] = presentationNode;
        break;
      }
    }
    if (!found) {
      children.push(presentationNode);
    }
    this.setCanvas(this.canvas);
  }
  setCanvas(canvas) {
    if (!canvas.children)
      return;
    this.canvas = canvas;
    this.listeners.forEach((l, at) => {
      const id = this.ids[at];
      const data = findNodeFor(canvas, id);
      l.setState({ data });
    });
  }
  registerListener(listener, idOrName) {
    this.listeners.push(listener);
    this.ids.push(idOrName);
    return findNodeFor(this.canvas, idOrName);
  }
  removeListener(listener) {
    const at = this.listeners.indexOf(listener);
    if (at === -1)
      return;
    this.listeners.splice(at, 1);
    this.ids.splice(at, 1);
  }
};
var CanvasStore = _CanvasStore;
CanvasStore.__shared = null;
var builtInComponents = { Frame, Vector, Stack, VectorGroup, SVG, Text, DeprecatedComponentContainer };
var DesignComponent = class extends Component18 {
  _typeForName(name) {
    const builtIn = builtInComponents[name];
    if (builtIn)
      return builtIn;
    const codeComponent = runtime.componentLoader.componentForIdentifier(name);
    if (codeComponent && isReactDefinition(codeComponent)) {
      return codeComponent.class;
    }
    return Frame;
  }
  _renderData(presentation, componentProps, topLevelProps) {
    safeWindow["__checkBudget__"]();
    const { componentClass, name } = presentation;
    let { props, children } = presentation;
    props = { ...props, _constraints: { enabled: false } };
    const type = this._typeForName(componentClass);
    if (!type)
      return null;
    if (topLevelProps) {
      const { style, ...rest } = props;
      props = { ...rest, ...topLevelProps, _initialStyle: style };
    }
    if (!props.size && props._sizeOfMasterOnCanvas) {
      if (!props.width) {
        props.width = props._sizeOfMasterOnCanvas.width;
      }
      if (!props.height) {
        props.height = props._sizeOfMasterOnCanvas.height;
      }
    }
    if (name && componentProps.hasOwnProperty(name)) {
      if (componentClass === "Text") {
        const text = componentProps[name];
        if (text) {
          props = { ...props, text: componentProps[name] };
        }
      } else {
        const orig = props.background;
        const background = { src: componentProps[name], fit: orig.fit };
        props = { ...props, background };
      }
    }
    const c2 = children && children.map((child) => this._renderData(child, componentProps, void 0));
    children = children ? c2 : [];
    return createElement48(type, props, children);
  }
  render() {
    safeWindow["__checkBudget__"]();
    const data = this.state.data;
    if (!data) {
      throw new Error("Unable to connect to canvas data store.");
    }
    return this._renderData(this.state.data, this.props, this.props);
  }
};
function isNode2(id, presentation) {
  const { name, props } = presentation;
  return props && props.id === id || name === id;
}
function findNodeFor(presentation, id) {
  if (!presentation)
    return null;
  if (isNode2(id, presentation)) {
    return presentation;
  }
  const { children } = presentation;
  if (!children || !isArray(children))
    return null;
  for (const child of children) {
    if (isNode2(id, child)) {
      return child;
    }
  }
  for (const child of children) {
    const result = findNodeFor(child, id);
    if (result)
      return result;
  }
  return null;
}
function createDesignComponent(canvasStore, id, propertyControls, width = 200, height = 200) {
  var _a;
  return _a = class extends DesignComponent {
    static rect(props) {
      const constraintValues = ConstraintValues.fromProperties(props);
      return ConstraintValues.toRect(constraintValues, props.parentSize || null, null);
    }
    static minSize(props, parentSize) {
      const constraintValues = ConstraintValues.fromProperties(props);
      return ConstraintValues.toMinSize(constraintValues, parentSize || null);
    }
    static size(props, parentSize, freeSpace) {
      const constraintValues = ConstraintValues.fromProperties(props);
      return ConstraintValues.toSize(constraintValues, parentSize || null, null, freeSpace);
    }
    constructor(props, context) {
      super(props, context);
      const data = canvasStore.registerListener(this, id);
      this.state = { data };
    }
    render() {
      const maybeRenderWithProvider = (renderNode) => {
        const nodeId = nodeIdFromString(id);
        if (!this.state.data && renderNode) {
          safeWindow["__checkBudget__"]();
          const el = renderNode(nodeId);
          if (el && isValidElement3(el) && typeof el.type !== "string") {
            return createElement48(WithOverride(el.type, this.props), el.props);
          }
        }
        return super.render();
      };
      return /* @__PURE__ */ createElement48(RenderNodeContext.Consumer, null, maybeRenderWithProvider);
    }
    componentWillUnmount() {
      canvasStore.removeListener(this);
    }
  }, _a.displayName = `DesignComponent(${id})`, _a.propertyControls = propertyControls, _a.supportsConstraints = true, _a.defaultProps = {
    _sizeOfMasterOnCanvas: {
      width,
      height
    }
  }, _a;
}
var RenderNodeContext = createContext17(null);
var RenderNodeProvider = RenderNodeContext.Provider;

// src/render/utils/withGeneratedLayoutId.tsx
import {
  createElement as createElement49,
  forwardRef as forwardRef10
} from "react";
var withGeneratedLayoutId = (Component19) => forwardRef10((props, ref) => {
  const layoutId = useLayoutId2(props);
  return /* @__PURE__ */ createElement49(Component19, {
    layoutId,
    ...props,
    layoutIdKey: void 0,
    duplicatedFrom: void 0,
    ref
  });
});

// src/data/useData/index.ts
import { useEffect as useEffect23, useMemo as useMemo11, useState as useState9, createContext as createContext18, useContext as useContext29 } from "react";

// src/data/useData/store.ts
function bindActionsToStore(get, set, actions) {
  const boundActions = {};
  for (const key6 in actions) {
    boundActions[key6] = (data) => set(actions[key6](get(), data));
  }
  return boundActions;
}
function createStore(initialState2, unboundActions) {
  let state = initialState2;
  let version2 = 0;
  const subscribers = new Set();
  const notifySubscriber = (sub) => sub(version2);
  const get = () => state;
  const set = (latestState) => {
    version2++;
    state = latestState;
    subscribers.forEach(notifySubscriber);
  };
  const actions = unboundActions ? bindActionsToStore(get, set, unboundActions) : set;
  return {
    get,
    set,
    getVersion: () => version2,
    getActions: () => actions,
    subscribe: (sub) => {
      subscribers.add(sub);
      return () => subscribers.delete(sub);
    }
  };
}

// src/data/useData/index.ts
var defaultId = Symbol("default");
var DataContext = createContext18(defaultId);
function createData(defaultState2, actions) {
  const stores = new Map();
  const useData = (id, initialState2) => {
    const contextId = useContext29(DataContext);
    id = id || contextId;
    const store = useMemo11(() => {
      if (!stores.has(id)) {
        stores.set(id, createStore(initialState2 || defaultState2, actions));
      }
      return stores.get(id);
    }, [id]);
    const [, notifyUpdates] = useState9(store.getVersion());
    const storeValueAtHookCallTime = useMemo11(() => store.get(), [store]);
    useEffect23(() => {
      const unsubscribe = store.subscribe(notifyUpdates);
      if (storeValueAtHookCallTime !== store.get())
        notifyUpdates(store.getVersion());
      return unsubscribe;
    }, [store, storeValueAtHookCallTime]);
    return [store.get(), store.getActions()];
  };
  return useData;
}

// src/utils/addActionControls.ts
function addActionControls(action, title, controls) {
  runtime.addActionControls(action, title, controls);
}

// src/data/PropertyStore.ts
function PropertyStore(initial = {}, makeAnimatables = false) {
  deprecationWarning("PropertyStore", "1.0.0", "Data() or ObservableObject()");
  return ObservableObject(initial, makeAnimatables);
}
(function(PropertyStore2) {
  function addObserver(target, observer) {
    return ObservableObject.addObserver(target, observer);
  }
  PropertyStore2.addObserver = addObserver;
})(PropertyStore || (PropertyStore = {}));

// src/utils/network.ts
function loadJSON(url) {
  return fetch(url, { mode: "cors" }).then((res) => res.json());
}

// src/utils/inspectObjectType.ts
function inspectObjectType(item) {
  let className;
  if ((item.constructor !== null ? item.constructor.name : void 0) !== null && (item.constructor !== null ? item.constructor.name : void 0) !== "Object") {
    return item.constructor.name;
  }
  const extract = function(str) {
    if (!str) {
      return null;
    }
    const regex = /\[object (\w+)\]/;
    const match = regex.exec(str);
    if (match) {
      return match[1];
    }
    return null;
  };
  if (item.toString) {
    className = extract(item.toString());
    if (className) {
      return className;
    }
  }
  if (item.constructor !== null ? item.constructor.toString : void 0) {
    className = extract(item.constructor !== null ? item.constructor.toString() : void 0);
    if (className) {
      return className.replace("Constructor", "");
    }
  }
  return "Object";
}

// src/utils/inspect.ts
function inspect(item, max, l) {
  if (max === void 0) {
    max = 5;
  }
  if (l === void 0) {
    l = 0;
  }
  if (item === null) {
    return "null";
  }
  if (item === void 0) {
    return "undefined";
  }
  if (isFunction(item.toInspect)) {
    return item.toInspect();
  }
  if (isString2(item)) {
    return `"${item}"`;
  }
  if (isNumber(item)) {
    return `${item}`;
  }
  if (isFunction(item)) {
    let code = item.toString().slice("function ".length).replace(/\n/g, "").replace(/\s+/g, " ");
    const limit = 50;
    if (code.length > limit && l > 0) {
      code = `${code.slice(0, +limit + 1 || void 0).trim()}\u2026 }`;
    }
    return `<Function ${code}>`;
  }
  if (isArray(item)) {
    if (l > max) {
      return "[...]";
    }
    return `[${item.map((i) => inspect(i, max, (l || 0) + 1)).join(", ")}]`;
  }
  if (isObject(item)) {
    let objectInfo;
    const objectType = inspectObjectType(item);
    if (/HTML\w+?Element/.test(objectType)) {
      return `<${objectType}>`;
    }
    if (l > max) {
      objectInfo = "{...}";
    } else {
      const itemKeys = Object.keys(item);
      objectInfo = `{${itemKeys.map((k) => `${k}:${inspect(item[k], max, (l || 0) + 1)}`).join(", ")}}`;
    }
    if (objectType === "Object") {
      return objectInfo;
    }
    return `<${objectType} ${objectInfo}>`;
  }
  return `${item}`;
}

// src/utils/print.ts
function print(...args) {
  const line = args.map((arg) => {
    return inspect(arg);
  }).join(", ");
  console.log(line);
}

// src/utils/addFonts.ts
function addFonts(component, fonts) {
  Object.assign(component, { fonts });
}
function getFonts(component) {
  const fonts = component.fonts;
  return fonts || [];
}

// src/version.ts
var version = "1.3.6";

// src/animation/Motion/MotionSetup.tsx
import {
  Fragment as Fragment8,
  createElement as createElement50
} from "react";

// src/animation/Motion/autoValueHandlers.ts
var correctBorderScale = (axis) => ({
  process: (latest, { delta: delta2, treeScale }) => {
    if (typeof latest === "string")
      latest = parseFloat(latest);
    if (latest === 0)
      return "0px";
    let corrected = Math.round(latest / delta2[axis].scale / treeScale[axis]);
    corrected = Math.max(corrected, 1);
    return corrected + "px";
  }
});

// src/animation/Motion/MotionSetup.tsx
addScaleCorrection({
  borderTopWidth: correctBorderScale("y"),
  borderLeftWidth: correctBorderScale("x"),
  borderRightWidth: correctBorderScale("x"),
  borderBottomWidth: correctBorderScale("y")
});
function MotionSetup({ children }) {
  return /* @__PURE__ */ createElement50(Fragment8, null, children);
}

// src/animation/Motion/startAnimation.ts
function startAnimation2(_key, value, target, transition = {}) {
  warnOnce(`"startAnimation" is unsupported. Use "animate" instead: https://www.framer.com/api/motion/utilities/#animate`);
  return new Promise((resolve) => {
    animate2(value, target, {
      ...transition,
      onComplete: () => resolve()
    });
  });
}

// src/modules/useAddVariantProps.ts
import {
  useCallback as useCallback10
} from "react";
function useAddVariantProps(baseVariant, gestureVariant, variantProps2) {
  return useCallback10((id) => {
    var _a, _b, _c;
    if (!variantProps2)
      return {};
    if (!baseVariant)
      return {};
    if (gestureVariant) {
      return Object.assign({}, (_a = variantProps2[baseVariant]) == null ? void 0 : _a[id], (_b = variantProps2[gestureVariant]) == null ? void 0 : _b[id]);
    }
    return ((_c = variantProps2[baseVariant]) == null ? void 0 : _c[id]) || {};
  }, [baseVariant, gestureVariant, variantProps2]);
}

// src/modules/useVariantState.ts
import {
  useCallback as useCallback11,
  useLayoutEffect as useLayoutEffect9,
  useMemo as useMemo12,
  useRef as useRef24
} from "react";
function createGestureVariant(variant, type) {
  return `${variant}-${type}`;
}
function nextVariant(allVariants, currentVariant) {
  const index = allVariants.indexOf(currentVariant);
  let nextIndex = index + 1;
  if (nextIndex >= allVariants.length) {
    nextIndex = 0;
  }
  return allVariants[nextIndex];
}
var VariantSelector;
(function(VariantSelector2) {
  VariantSelector2["Variant"] = "v";
})(VariantSelector || (VariantSelector = {}));
function getGesture(enabledGestures, isHovered, isPressed) {
  const { hover, pressed } = enabledGestures || {};
  if (pressed && isPressed)
    return "pressed";
  if (hover && isHovered)
    return "hover";
}
function createVariantClassName(baseVariant, variantClassNames) {
  const mappedClassName = variantClassNames[baseVariant];
  if (mappedClassName)
    return mappedClassName;
  return `framer-${VariantSelector.Variant}-${baseVariant}`;
}
var CycleVariantState = Symbol("cycle");
function useVariantState({
  variant,
  defaultVariant: externalDefaultVariant,
  transitions: externalTransitions,
  enabledGestures: externalEnabledGestures,
  cycleOrder: externalCycleOrder = [],
  variantProps: variantProps2 = {},
  variantClassNames = {}
}) {
  const forceUpdate = useForceUpdate2();
  const internalState = useRef24({
    isHovered: false,
    isPressed: false,
    baseVariant: variant != null ? variant : externalDefaultVariant,
    gestureVariant: void 0,
    defaultVariant: externalDefaultVariant,
    enabledGestures: externalEnabledGestures,
    cycleOrder: externalCycleOrder,
    transitions: externalTransitions
  });
  const resolveNextVariant = useCallback11((nextBaseVariant = internalState.current.defaultVariant) => {
    const {
      baseVariant: baseVariant2,
      gestureVariant: gestureVariant2,
      isPressed: isPressed2,
      isHovered: isHovered2,
      defaultVariant: defaultVariant2,
      enabledGestures: enabledGestures2
    } = internalState.current;
    const gesture = getGesture(enabledGestures2 == null ? void 0 : enabledGestures2[nextBaseVariant], isHovered2, isPressed2);
    const nextGestureVariant = gesture ? createGestureVariant(nextBaseVariant, gesture) : void 0;
    if (nextBaseVariant !== baseVariant2 || nextGestureVariant !== gestureVariant2) {
      internalState.current.baseVariant = nextBaseVariant || defaultVariant2;
      internalState.current.gestureVariant = nextGestureVariant;
      forceUpdate();
    }
  }, [forceUpdate]);
  const setGestureState = useCallback11(({ isHovered: isHovered2, isPressed: isPressed2 }) => {
    if (isHovered2 !== void 0)
      internalState.current.isHovered = isHovered2;
    if (isPressed2 !== void 0)
      internalState.current.isPressed = isPressed2;
    resolveNextVariant(internalState.current.baseVariant);
  }, [resolveNextVariant]);
  const setVariant = useCallback11((proposedVariant) => {
    const { defaultVariant: defaultVariant2, cycleOrder, baseVariant: baseVariant2 } = internalState.current;
    const nextBaseVariant = proposedVariant === CycleVariantState ? nextVariant(cycleOrder || [], baseVariant2 || defaultVariant2) : proposedVariant;
    resolveNextVariant(nextBaseVariant || defaultVariant2);
  }, [resolveNextVariant]);
  useLayoutEffect9(() => {
    if (variant !== internalState.current.baseVariant)
      setVariant(variant);
  }, [variant, setVariant]);
  const { baseVariant } = internalState.current;
  const transition = useMemo12(() => {
    const { transitions } = internalState.current;
    if (!transitions)
      return void 0;
    if (baseVariant) {
      const variantTransition = transitions[baseVariant];
      if (variantTransition)
        return variantTransition;
    }
    return transitions.default;
  }, [baseVariant]);
  const variants = [];
  const { gestureVariant, defaultVariant, enabledGestures, isHovered, isPressed } = internalState.current;
  if (baseVariant && baseVariant !== defaultVariant)
    variants.push(baseVariant);
  if (gestureVariant)
    variants.push(gestureVariant);
  const addVariantProps = useAddVariantProps(baseVariant, gestureVariant, variantProps2);
  return {
    variants,
    baseVariant,
    gestureVariant,
    transition,
    setVariant,
    setGestureState,
    addVariantProps,
    classNames: cx(createVariantClassName(baseVariant, variantClassNames), getGesture(enabledGestures == null ? void 0 : enabledGestures[baseVariant], isHovered, isPressed))
  };
}

// src/modules/withCSS.tsx
import {
  createElement as createElement51,
  forwardRef as forwardRef11,
  useLayoutEffect as useLayoutEffect10
} from "react";
var withCSS = (Component19, escapedCSS) => forwardRef11((props, ref) => {
  useLayoutEffect10(() => {
    const css = Array.isArray(escapedCSS) ? escapedCSS : escapedCSS.split("\n");
    css.forEach((rule) => rule && setDocumentStyles(rule));
  }, []);
  return /* @__PURE__ */ createElement51(Component19, {
    ...props,
    ref
  });
});

// src/modules/Container.tsx
import {
  Children as Children12,
  cloneElement as cloneElement10,
  createElement as createElement52,
  isValidElement as isValidElement4
} from "react";
function Providers({ children, layoutId, ...props }) {
  const context = useConstant2(createBatcher);
  const outerLayoutId = useConstant2(() => layoutId ? `${layoutId}-container` : void 0);
  return /* @__PURE__ */ createElement52(motion.div, {
    layoutId: outerLayoutId,
    ...props
  }, /* @__PURE__ */ createElement52(ComponentContainerContext.Provider, {
    value: true
  }, /* @__PURE__ */ createElement52(SharedLayoutContext.Provider, {
    value: context
  }, /* @__PURE__ */ createElement52(AutomaticLayoutIds, {
    enabled: false
  }, /* @__PURE__ */ createElement52(LayoutGroupContext.Provider, {
    value: layoutId != null ? layoutId : null
  }, Children12.map(children, (child) => {
    return isValidElement4(child) ? cloneElement10(child, { layoutId }) : child;
  }))))));
}
var Container = withGeneratedLayoutId(Providers);

// src/modules/callEach.ts
var callEach = (...fns) => fns.forEach((fn) => fn && fn());

// src/modules/useOnVariantChange.ts
import {
  useEffect as useEffect24,
  useRef as useRef25
} from "react";

// src/modules/useIsOnFramerCanvas.ts
function useIsOnFramerCanvas() {
  return RenderTarget.current() === RenderTarget.canvas;
}

// src/modules/useOnVariantChange.ts
function callbackForVariant(map, variant) {
  if (map[variant])
    return map[variant];
  if (variant in map)
    return void 0;
  return map.default;
}
function useOnVariantChange(variant, callbackMap) {
  const isOnFramerCanvas = useIsOnFramerCanvas();
  if (isOnFramerCanvas)
    return;
  const isInCurrentTargetRef = useRef25(true);
  useOnCurrentTargetChange((isInTarget) => {
    if (!isInCurrentTargetRef.current && isInTarget) {
      const callback = callbackForVariant(callbackMap, variant);
      if (callback)
        callback();
    }
    isInCurrentTargetRef.current = isInTarget;
  }, [callbackMap]);
  useEffect24(() => {
    if (isInCurrentTargetRef.current) {
      const callback = callbackForVariant(callbackMap, variant);
      if (callback)
        callback();
    }
  }, [variant, callbackMap]);
}
function useOnAppear(callback) {
  useOnVariantChange("default", { default: callback });
}

// src/modules/useActiveVariantCallback.ts
import {
  useEffect as useEffect25,
  useRef as useRef26
} from "react";
function rejectPending(pendingTimers, pendingPromises) {
  pendingTimers.forEach((t) => clearTimeout(t));
  pendingTimers.clear();
  pendingPromises.forEach((reject) => reject && reject("Callback cancelled by variant change"));
  pendingPromises.clear();
}
function createSet() {
  return new Set();
}
function useActiveVariantCallback(baseVariant) {
  const pendingPromises = useConstant2(createSet);
  const pendingTimers = useConstant2(createSet);
  useOnCurrentTargetChange(() => {
    return () => rejectPending(pendingTimers, pendingPromises);
  });
  useEffect25(() => {
    return () => rejectPending(pendingTimers, pendingPromises);
  }, [pendingPromises, pendingTimers]);
  useEffect25(() => {
    rejectPending(pendingTimers, pendingPromises);
  }, [baseVariant, pendingPromises, pendingTimers]);
  return useRef26({
    activeVariantCallback: (callback) => (...args) => {
      return new Promise((resolve, reject) => {
        pendingPromises.add(reject);
        return callback(...args).then(resolve);
      }).catch(() => {
      });
    },
    delay: async (callback, msDelay) => {
      await new Promise((resolve) => pendingTimers.add(globalThis.setTimeout(() => resolve(true), msDelay)));
      callback();
    }
  }).current;
}
function useActiveTargetCallback() {
  const value = useActiveVariantCallback(void 0);
  return useRef26({
    activeTargetCallback: value.activeVariantCallback,
    delay: value.delay
  }).current;
}

// src/modules/useNavigate.tsx
import {
  createElement as createElement53,
  forwardRef as forwardRef12,
  lazy,
  useEffect as useEffect26
} from "react";
function lazy2(factory) {
  const LazyComponent = lazy(factory);
  let factoryPromise;
  let LoadedComponent;
  const Component19 = forwardRef12(function LazyWithPreload(props, ref) {
    return createElement53(LoadedComponent != null ? LoadedComponent : LazyComponent, Object.assign(ref ? { ref } : {}, props));
  });
  Component19.preload = () => {
    if (!factoryPromise) {
      factoryPromise = factory().then((module) => {
        LoadedComponent = module.default;
      });
    }
    return factoryPromise;
  };
  return Component19;
}
function useNavigate({ preload } = {}) {
  const navigation = useNavigation();
  useEffect26(() => {
    if (!navigation)
      return;
    preload == null ? void 0 : preload.forEach((component) => "preload" in component && component.preload());
  }, []);
  if (!navigation)
    return () => {
    };
  return async (target, options = {}) => {
    if (target === "previous") {
      navigation.goBack();
      return false;
    }
    const { appearsFrom, backdropColor, animation } = options;
    if (!target)
      return;
    switch (options.transition) {
      case "instant":
        navigation.instant(target);
        break;
      case "fade":
        navigation.fade(target, { animation });
        break;
      case "push":
        navigation.push(target, { appearsFrom, animation });
        break;
      case "modal":
        navigation.modal(target, { backdropColor, animation });
        break;
      case "overlay":
        navigation.overlay(target, { appearsFrom, backdropColor, animation });
        break;
      case "flip":
        navigation.flip(target, { appearsFrom, animation });
        break;
      case "magicMotion":
        navigation.magicMotion(target, { animation });
        break;
    }
    return false;
  };
}

// src/modules/LayoutGroup.tsx
import {
  Fragment as Fragment9,
  createElement as createElement54
} from "react";
import { useContext as useContext30 } from "react";
var LayoutGroup = ({
  id,
  children
}) => {
  const parentLayoutId = useContext30(LayoutGroupContext);
  if (!id)
    return /* @__PURE__ */ createElement54(Fragment9, null, children);
  const combinedLayoutId = parentLayoutId && parentLayoutId !== id ? `${parentLayoutId}-${id}` : id;
  return /* @__PURE__ */ createElement54(LayoutGroupContext.Provider, {
    value: combinedLayoutId
  }, children);
};

// src/modules/useHotkey.ts
import {
  useCallback as useCallback12,
  useEffect as useEffect27,
  useRef as useRef27
} from "react";
var modifierDefaults = {
  altKey: false,
  ctrlKey: false,
  metaKey: false,
  shiftKey: false
};
function createShortcutDefinition(shortcut) {
  const keys2 = shortcut.split("+");
  const key6 = keys2.pop();
  if (!key6)
    return void 0;
  const modifiers = {};
  for (const modifier of keys2) {
    modifiers[`${modifier}Key`] = true;
  }
  return {
    ...modifierDefaults,
    ...modifiers,
    key: key6
  };
}
function useHotkey(shortcut, callback) {
  const inTarget = useRef27(true);
  const shortcutDefinition = useConstant2(() => createShortcutDefinition(shortcut));
  useOnCurrentTargetChange((isCurrentTarget, isOverlayed) => {
    inTarget.current = isCurrentTarget && !isOverlayed;
    return () => inTarget.current = false;
  });
  const eventHandler = useCallback12((event) => {
    if (!shortcutDefinition)
      return;
    if (!inTarget.current)
      return;
    if (!Object.keys(shortcutDefinition).every((key6) => shortcutDefinition[key6] === event[key6]))
      return;
    event.preventDefault();
    callback();
  }, [shortcutDefinition, callback]);
  useEffect27(() => {
    document.addEventListener("keydown", eventHandler);
    return () => document.removeEventListener("keydown", eventHandler);
  }, [eventHandler]);
}

// src/modules/useGamepad.ts
import {
  createContext as createContext19,
  useCallback as useCallback13,
  useContext as useContext31,
  useEffect as useEffect28
} from "react";
function isFramerGamepadKeydownData(value) {
  return isObject(value) && value.mapping !== void 0;
}
function createGamepadPoller() {
  const callbacks2 = new Set();
  let isConnected = false;
  let isPolling = null;
  let lastKey = null;
  const startPolling = () => {
    const input = getFirstAvailableGamepadInput();
    if (!input)
      return;
    const { gamepad, key: key6 } = input;
    const { mapping, id } = gamepad;
    if (key6 && lastKey !== key6)
      callbacks2.forEach((callback) => callback({ key: key6, mapping, id }));
    lastKey = key6;
    isPolling = window.requestAnimationFrame(startPolling);
  };
  const handleConnection = () => {
    if (isConnected || isPolling)
      return;
    startPolling();
    isConnected = true;
  };
  const stopPolling = () => {
    if (!isPolling)
      return;
    window.cancelAnimationFrame(isPolling);
    isPolling = null;
  };
  const handleDisconnection = () => {
    if (!isConnected)
      return;
    stopPolling();
    isConnected = false;
  };
  const setupAndStartPolling = () => {
    if (isPolling)
      return;
    const gamepad = getFirstAvailableGamepadInput();
    if (!gamepad) {
      window.addEventListener("gamepadconnected", handleConnection);
      return;
    }
    window.addEventListener("gamepaddisconnected", handleDisconnection);
    isConnected = true;
    startPolling();
  };
  const cleanupAndStopPolling = () => {
    if (!isPolling)
      return;
    window.removeEventListener("gamepadconnected", handleConnection);
    window.removeEventListener("gamepaddisconnected", handleDisconnection);
    stopPolling();
  };
  return {
    register(callback) {
      if (callbacks2.size === 0)
        setupAndStartPolling();
      callbacks2.add(callback);
    },
    unregister(callback) {
      callbacks2.delete(callback);
      if (callbacks2.size === 0)
        cleanupAndStopPolling();
    }
  };
}
var GamepadContext = createContext19(createGamepadPoller());
function getFirstAvailableGamepadInput() {
  let firstConnectedGamepad = null;
  const gamepads = navigator.getGamepads();
  for (const gamepad of gamepads) {
    if (!gamepad)
      continue;
    if (!firstConnectedGamepad) {
      firstConnectedGamepad = gamepad;
    }
    const axis = scanPressedAxis(gamepad);
    if (axis !== null)
      return { gamepad, key: axis };
    const button = scanPressedButton(gamepad);
    if (button !== null)
      return { gamepad, key: button };
  }
  if (firstConnectedGamepad)
    return { gamepad: firstConnectedGamepad, key: null };
  return null;
}
function scanPressedAxis(gamepad) {
  for (const [idx, axis] of gamepad.axes.entries()) {
    if (idx > 3)
      return null;
    if (axis <= -0.5)
      return `Axis ${idx}-`;
    if (axis > 0.5)
      return `Axis ${idx}+`;
  }
  return null;
}
function scanPressedButton(gamepad) {
  for (const [idx, button] of gamepad.buttons.entries()) {
    if (isButtonPressed(button))
      return `Button ${idx}`;
  }
  return null;
}
function isButtonPressed(button) {
  return button.pressed === true || button.value > 0;
}
function useGamepad(key6, callback, options = { mapping: "standard" }) {
  const context = useContext31(GamepadContext);
  const mapping = useConstant2(() => options.mapping);
  const cb2 = useCallback13((input) => {
    if (key6 === input.key && mapping === input.mapping)
      callback();
  }, [key6, mapping, callback]);
  useOnCurrentTargetChange((isInTarget, isOverlayed) => {
    const isActive = isInTarget && !isOverlayed;
    if (isActive) {
      context.register(cb2);
    } else {
      context.unregister(cb2);
    }
    return () => context.unregister(cb2);
  }, []);
  useEffect28(() => {
    return () => context.unregister(cb2);
  }, [cb2, context]);
}

// src/index.ts
if (undefined === "framer") {
  MainLoop.start();
}
export {
  Animatable,
  AnimatePresence,
  AnimateSharedLayout,
  AnyInterpolation,
  AutomaticLayoutIds,
  BackgroundImage,
  BezierAnimator,
  BoxShadow,
  CanvasStore,
  Color,
  ColorFormat,
  ColorMixModelType,
  ComponentContainerContext,
  ConstraintMask,
  ConstraintValues,
  Container,
  ControlType,
  ConvertColor,
  CustomProperties,
  CustomPropertiesContext,
  CycleVariantState,
  DOM,
  Data,
  DataContext,
  DataObserver,
  DataObserverContext,
  DeprecatedComponentContainer,
  DeprecatedFrameWithEvents,
  DimensionType,
  DragControls,
  Draggable,
  EmptyState,
  FlatTree,
  Frame,
  FrameWithMotion,
  FramerAnimation,
  FramerEvent,
  FramerEventListener,
  FramerEventSession,
  FramerTreeLayoutContext,
  GamepadContext,
  Image2 as Image,
  InternalID,
  Layer,
  LayoutGroup,
  LayoutGroupContext,
  LayoutIdContext,
  LazyMotion,
  Line,
  LinearGradient,
  MainLoop,
  MotionConfig,
  MotionConfigContext,
  MotionSetup,
  MotionValue,
  NavigateTo,
  Navigation,
  NavigationCallbackProvider,
  NavigationConsumer,
  NavigationTransitionType,
  ObservableObject,
  Page,
  ParentSizeState,
  PathSegment,
  Point,
  PresenceContext,
  PropertyStore,
  ProvideParentSize,
  RadialGradient,
  Rect,
  RenderNodeProvider,
  RenderTarget,
  SVG,
  Scroll,
  Shadow,
  SharedLayoutContext,
  Size,
  SpringAnimator,
  Stack,
  Text,
  TypefaceSourceNames,
  ValueInterpolation,
  VariantSelector,
  Vector,
  VectorGroup,
  VisibilityAction,
  WithNavigator,
  WithOverride,
  _getCSSTextColorFromStyle,
  _injectRuntime,
  addActionControls,
  addFonts,
  addPropertyControls,
  addScaleCorrection,
  animate3 as animate,
  animateVisualElement,
  animationControls,
  annotateTypeOnStringify,
  backgroundImageFromProps,
  calculateRect,
  callEach,
  collectVisualStyleFromProps,
  constraintsEnabled,
  convertPresentationTree,
  createBatcher,
  createCrossfader,
  createData,
  createDesignComponent,
  createDomMotionComponent,
  createMotionComponent,
  cssBackgroundSize,
  cx,
  debounce,
  dispatchKeyDownEvent,
  domAnimation,
  domMax,
  environment,
  executeInRenderEnvironment,
  finiteNumber,
  fontStore,
  forceLayerBackingWithCSSProperties,
  fraction,
  frameFromElement,
  frameFromElements,
  getConfigFromPreviewURL,
  getConfigFromPreviewURL as getConfigFromURL,
  getConfigFromVekterURL,
  getFonts,
  getMeasurableCodeComponentChildren,
  getMergedConstraintsProps,
  getPropertyControls,
  gradientForShape,
  imagePatternPropsForFill,
  imageUrlForAsset,
  isAnimatable2 as isAnimatable,
  isDesignDefinition,
  isEqual,
  isFiniteNumber,
  isFractionDimension,
  isFramerGamepadKeydownData,
  isGapEnabled,
  isMotionValue2 as isMotionValue,
  isOfAnnotatedType,
  isOverride,
  isReactDefinition,
  isShallowEqualArray,
  isStraightCurve,
  isValidMotionProp,
  lazy2 as lazy,
  loadFont,
  loadJSON,
  localPackageFallbackIdentifier,
  localShadowFrame,
  m,
  makePaddingString,
  memoize,
  motion,
  motionValue,
  paddingFromProps,
  parseVariant,
  pathDefaults,
  print,
  resolveMotionValue,
  roundWithOffset,
  roundedNumber,
  roundedNumberString,
  serverURL,
  setGlobalRenderEnvironment,
  snapshotViewportBox,
  startAnimation2 as startAnimation,
  systemTypefaceName,
  throttle,
  toFlexDirection,
  toJustifyOrAlignment,
  toSVGPath,
  transform,
  transformString,
  transformTemplate,
  useActiveTargetCallback,
  useActiveVariantCallback,
  useAddVariantProps,
  useAnimatedState,
  useAnimation,
  useCycle,
  useAnimatedState as useDeprecatedAnimatedState,
  useInvertedScale as useDeprecatedInvertedScale,
  useDomEvent,
  useDragControls,
  useElementScroll,
  useGamepad,
  useHotkey,
  useInvertedScale,
  useIsInCurrentNavigationTarget,
  useIsOnFramerCanvas,
  useIsPresent,
  useMeasureLayout,
  useMotionTemplate,
  useMotionValue,
  useNavigate,
  useNavigation,
  useObserveData,
  useOnAppear,
  useOnCurrentTargetChange,
  useOnVariantChange,
  usePresence,
  useReducedMotion,
  useRenderEnvironment,
  useSpring,
  useTransform,
  useVariantState,
  useVelocity,
  useViewportScroll,
  valueToDimensionType,
  version,
  visualElement,
  withCSS,
  withGeneratedLayoutId,
  withMeasuredSize,
  withOpacity,
  withPath,
  withShape
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=framer.debug.js.map
